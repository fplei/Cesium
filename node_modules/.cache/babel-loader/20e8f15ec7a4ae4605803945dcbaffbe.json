{"remainingRequest":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_babel-loader@8.2.5@babel-loader/lib/index.js!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--1-0!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js??vue-loader-options!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/GanttElastic.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/GanttElastic.vue","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/babel.config.js","mtime":1658370777000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_babel-loader@8.2.5@babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js","mtime":1655715099000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIjsKaW1wb3J0IFZ1ZUluc3RhbmNlIGZyb20gJ3Z1ZSc7CmltcG9ydCBkYXlqcyBmcm9tICdkYXlqcyc7CmltcG9ydCBNYWluVmlldyBmcm9tICcuL2NvbXBvbmVudHMvTWFpblZpZXcudnVlJzsKaW1wb3J0IGdldFN0eWxlIGZyb20gJy4vc3R5bGUuanMnOwppbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJzsKY29uc3QgY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTsKbGV0IFZ1ZUluc3QgPSBWdWVJbnN0YW5jZTsKCmZ1bmN0aW9uIGluaXRWdWUoKSB7CiAgaWYgKHR5cGVvZiBWdWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBWdWVJbnN0ID09PSAndW5kZWZpbmVkJykgewogICAgVnVlSW5zdCA9IFZ1ZTsKICB9Cn0KCmluaXRWdWUoKTsKbGV0IGhvdXJXaWR0aENhY2hlID0gbnVsbDsKLyoqCiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaWxsIG91dCBlbXB0eSBvcHRpb25zIGluIHVzZXIgc2V0dGluZ3MKICoKICogQHBhcmFtIHtvYmplY3R9IHVzZXJPcHRpb25zIC0gaW5pdGlhbCB1c2VyIG9wdGlvbnMgdGhhdCB3aWxsIG1lcmdlIHdpdGggdGhvc2UgYmVsb3cKICogQHJldHVybnMge29iamVjdH0gbWVyZ2VkIG9wdGlvbnMKICovCgpmdW5jdGlvbiBnZXRPcHRpb25zKHVzZXJPcHRpb25zKSB7CiAgbGV0IGxvY2FsZU5hbWUgPSAnZW4nOwoKICBpZiAodHlwZW9mIHVzZXJPcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHVzZXJPcHRpb25zLmxvY2FsZS5uYW1lICE9PSAndW5kZWZpbmVkJykgewogICAgbG9jYWxlTmFtZSA9IHVzZXJPcHRpb25zLmxvY2FsZS5uYW1lOwogIH0KCiAgcmV0dXJuIHsKICAgIHNsb3RzOiB7CiAgICAgIGhlYWRlcjoge30KICAgIH0sCiAgICB0YXNrTWFwcGluZzogewogICAgICAvLyoKICAgICAgaWQ6ICdpZCcsCiAgICAgIHN0YXJ0OiAnc3RhcnQnLAogICAgICBsYWJlbDogJ2xhYmVsJywKICAgICAgZHVyYXRpb246ICdkdXJhdGlvbicsCiAgICAgIHByb2dyZXNzOiAncHJvZ3Jlc3MnLAogICAgICB0eXBlOiAndHlwZScsCiAgICAgIHN0eWxlOiAnc3R5bGUnLAogICAgICBjb2xsYXBzZWQ6ICdjb2xsYXBzZWQnCiAgICB9LAogICAgd2lkdGg6IDAsCiAgICBoZWlnaHQ6IDAsCiAgICBjbGllbnRXaWR0aDogMCwKICAgIG91dGVySGVpZ2h0OiAwLAogICAgcm93c0hlaWdodDogMCwKICAgIGFsbFZpc2libGVUYXNrc0hlaWdodDogMCwKICAgIHNjcm9sbDogewogICAgICBzY3JvbGxpbmc6IGZhbHNlLAogICAgICBkcmFnWE1vdmVNdWx0aXBsaWVyOiAzLAogICAgICAvLyoKICAgICAgZHJhZ1lNb3ZlTXVsdGlwbGllcjogMiwKICAgICAgLy8qCiAgICAgIHRvcDogMCwKICAgICAgdGFza0xpc3Q6IHsKICAgICAgICBsZWZ0OiAwLAogICAgICAgIHJpZ2h0OiAwLAogICAgICAgIHRvcDogMCwKICAgICAgICBib3R0b206IDAKICAgICAgfSwKICAgICAgY2hhcnQ6IHsKICAgICAgICBsZWZ0OiAwLAogICAgICAgIHJpZ2h0OiAwLAogICAgICAgIHBlcmNlbnQ6IDAsCiAgICAgICAgdGltZVBlcmNlbnQ6IDAsCiAgICAgICAgdG9wOiAwLAogICAgICAgIGJvdHRvbTogMCwKICAgICAgICB0aW1lOiAwLAogICAgICAgIHRpbWVDZW50ZXI6IDAsCiAgICAgICAgZGF0ZVRpbWU6IHsKICAgICAgICAgIGxlZnQ6ICcnLAogICAgICAgICAgcmlnaHQ6ICcnCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgc2NvcGU6IHsKICAgICAgLy8qCiAgICAgIGJlZm9yZTogMSwKICAgICAgYWZ0ZXI6IDEKICAgIH0sCiAgICB0aW1lczogewogICAgICB0aW1lU2NhbGU6IDYwICogMTAwMCwKICAgICAgdGltZVpvb206IDE3LAogICAgICAvLyoKICAgICAgdGltZVBlclBpeGVsOiAwLAogICAgICBmaXJzdFRpbWU6IG51bGwsCiAgICAgIGxhc3RUaW1lOiBudWxsLAogICAgICBmaXJzdFRhc2tUaW1lOiAwLAogICAgICBsYXN0VGFza1RpbWU6IDAsCiAgICAgIHRvdGFsVmlld0R1cmF0aW9uTXM6IDAsCiAgICAgIHRvdGFsVmlld0R1cmF0aW9uUHg6IDAsCiAgICAgIHN0ZXBEdXJhdGlvbjogJ2RheScsCiAgICAgIHN0ZXBzOiBbXQogICAgfSwKICAgIHJvdzogewogICAgICBoZWlnaHQ6IDI0IC8vKgoKICAgIH0sCiAgICBtYXhSb3dzOiAyMCwKICAgIC8vKgogICAgbWF4SGVpZ2h0OiAwLAogICAgLy8qCiAgICBjaGFydDogewogICAgICBncmlkOiB7CiAgICAgICAgaG9yaXpvbnRhbDogewogICAgICAgICAgZ2FwOiA2IC8vKgoKICAgICAgICB9CiAgICAgIH0sCiAgICAgIHByb2dyZXNzOiB7CiAgICAgICAgd2lkdGg6IDIwLAogICAgICAgIC8vKgogICAgICAgIGhlaWdodDogNiwKICAgICAgICAvLyoKICAgICAgICBwYXR0ZXJuOiB0cnVlLAogICAgICAgIGJhcjogZmFsc2UKICAgICAgfSwKICAgICAgdGV4dDogewogICAgICAgIG9mZnNldDogNCwKICAgICAgICAvLyoKICAgICAgICB4UGFkZGluZzogMTAsCiAgICAgICAgLy8qCiAgICAgICAgZGlzcGxheTogdHJ1ZSAvLyoKCiAgICAgIH0sCiAgICAgIGV4cGFuZGVyOiB7CiAgICAgICAgdHlwZTogJ2NoYXJ0JywKICAgICAgICBkaXNwbGF5OiBmYWxzZSwKICAgICAgICAvLyoKICAgICAgICBkaXNwbGF5SWZUYXNrTGlzdEhpZGRlbjogdHJ1ZSwKICAgICAgICAvLyoKICAgICAgICBvZmZzZXQ6IDQsCiAgICAgICAgLy8qCiAgICAgICAgc2l6ZTogMTgKICAgICAgfQogICAgfSwKICAgIHRhc2tMaXN0OiB7CiAgICAgIGRpc3BsYXk6IHRydWUsCiAgICAgIC8vKgogICAgICByZXNpemVBZnRlclRocmVzaG9sZDogdHJ1ZSwKICAgICAgLy8qCiAgICAgIHdpZHRoVGhyZXNob2xkOiA3NSwKICAgICAgLy8qCiAgICAgIGNvbHVtbnM6IFsvLyoKICAgICAgewogICAgICAgIGlkOiAwLAogICAgICAgIGxhYmVsOiAnSUQnLAogICAgICAgIHZhbHVlOiAnaWQnLAogICAgICAgIHdpZHRoOiA0MAogICAgICB9XSwKICAgICAgcGVyY2VudDogMTAwLAogICAgICAvLyoKICAgICAgd2lkdGg6IDAsCiAgICAgIGZpbmFsV2lkdGg6IDAsCiAgICAgIHdpZHRoRnJvbVBlcmNlbnRhZ2U6IDAsCiAgICAgIG1pbldpZHRoOiAxOCwKICAgICAgZXhwYW5kZXI6IHsKICAgICAgICB0eXBlOiAndGFzay1saXN0JywKICAgICAgICBzaXplOiAxNiwKICAgICAgICBjb2x1bW5XaWR0aDogMjQsCiAgICAgICAgcGFkZGluZzogMTYsCiAgICAgICAgbWFyZ2luOiAxMCwKICAgICAgICBzdHJhaWdodDogZmFsc2UKICAgICAgfQogICAgfSwKICAgIGNhbGVuZGFyOiB7CiAgICAgIHdvcmtpbmdEYXlzOiBbMSwgMiwgMywgNCwgNV0sCiAgICAgIC8vKgogICAgICBnYXA6IDYsCiAgICAgIC8vKgogICAgICBoZWlnaHQ6IDAsCiAgICAgIHN0cm9rZVdpZHRoOiAxLAogICAgICBob3VyOiB7CiAgICAgICAgaGVpZ2h0OiAyMCwKICAgICAgICAvLyoKICAgICAgICBkaXNwbGF5OiB0cnVlLAogICAgICAgIC8vKgogICAgICAgIHdpZHRoczogW10sCiAgICAgICAgbWF4V2lkdGhzOiB7CiAgICAgICAgICBzaG9ydDogMCwKICAgICAgICAgIG1lZGl1bTogMCwKICAgICAgICAgIGxvbmc6IDAKICAgICAgICB9LAogICAgICAgIGZvcm1hdHRlZDogewogICAgICAgICAgbG9uZzogW10sCiAgICAgICAgICBtZWRpdW06IFtdLAogICAgICAgICAgc2hvcnQ6IFtdCiAgICAgICAgfSwKICAgICAgICBmb3JtYXQ6IHsKICAgICAgICAgIC8vKgogICAgICAgICAgbG9uZyhkYXRlKSB7CiAgICAgICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnSEg6bW0nKTsKICAgICAgICAgIH0sCgogICAgICAgICAgbWVkaXVtKGRhdGUpIHsKICAgICAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdISDptbScpOwogICAgICAgICAgfSwKCiAgICAgICAgICBzaG9ydChkYXRlKSB7CiAgICAgICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnSEgnKTsKICAgICAgICAgIH0KCiAgICAgICAgfQogICAgICB9LAogICAgICBkYXk6IHsKICAgICAgICBoZWlnaHQ6IDIwLAogICAgICAgIC8vKgogICAgICAgIGRpc3BsYXk6IHRydWUsCiAgICAgICAgLy8qCiAgICAgICAgd2lkdGhzOiBbXSwKICAgICAgICBtYXhXaWR0aHM6IHsKICAgICAgICAgIHNob3J0OiAwLAogICAgICAgICAgbWVkaXVtOiAwLAogICAgICAgICAgbG9uZzogMAogICAgICAgIH0sCiAgICAgICAgZm9ybWF0OiB7CiAgICAgICAgICBsb25nKGRhdGUpIHsKICAgICAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdERCBkZGRkJyk7CiAgICAgICAgICB9LAoKICAgICAgICAgIG1lZGl1bShkYXRlKSB7CiAgICAgICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnREQgZGRkJyk7CiAgICAgICAgICB9LAoKICAgICAgICAgIHNob3J0KGRhdGUpIHsKICAgICAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdERCcpOwogICAgICAgICAgfQoKICAgICAgICB9CiAgICAgIH0sCiAgICAgIG1vbnRoOiB7CiAgICAgICAgaGVpZ2h0OiAyMCwKICAgICAgICAvLyoKICAgICAgICBkaXNwbGF5OiB0cnVlLAogICAgICAgIC8vKgogICAgICAgIHdpZHRoczogW10sCiAgICAgICAgbWF4V2lkdGhzOiB7CiAgICAgICAgICBzaG9ydDogMCwKICAgICAgICAgIG1lZGl1bTogMCwKICAgICAgICAgIGxvbmc6IDAKICAgICAgICB9LAogICAgICAgIGZvcm1hdDogewogICAgICAgICAgLy8qCiAgICAgICAgICBzaG9ydChkYXRlKSB7CiAgICAgICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnTU0nKTsKICAgICAgICAgIH0sCgogICAgICAgICAgbWVkaXVtKGRhdGUpIHsKICAgICAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCJNTU0gJ1lZIik7CiAgICAgICAgICB9LAoKICAgICAgICAgIGxvbmcoZGF0ZSkgewogICAgICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ01NTU0gWVlZWScpOwogICAgICAgICAgfQoKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBsb2NhbGU6IHsKICAgICAgLy8qCiAgICAgIG5hbWU6ICdlbicsCiAgICAgIHdlZWtkYXlzOiAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyksCiAgICAgIHdlZWtkYXlzU2hvcnQ6ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksCiAgICAgIHdlZWtkYXlzTWluOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksCiAgICAgIG1vbnRoczogJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyksCiAgICAgIG1vbnRoc1Nob3J0OiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksCiAgICAgIHdlZWtTdGFydDogMSwKICAgICAgcmVsYXRpdmVUaW1lOiB7CiAgICAgICAgZnV0dXJlOiAnaW4gJXMnLAogICAgICAgIHBhc3Q6ICclcyBhZ28nLAogICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJywKICAgICAgICBtOiAnYSBtaW51dGUnLAogICAgICAgIG1tOiAnJWQgbWludXRlcycsCiAgICAgICAgaDogJ2FuIGhvdXInLAogICAgICAgIGhoOiAnJWQgaG91cnMnLAogICAgICAgIGQ6ICdhIGRheScsCiAgICAgICAgZGQ6ICclZCBkYXlzJywKICAgICAgICBNOiAnYSBtb250aCcsCiAgICAgICAgTU06ICclZCBtb250aHMnLAogICAgICAgIHk6ICdhIHllYXInLAogICAgICAgIHl5OiAnJWQgeWVhcnMnCiAgICAgIH0sCiAgICAgIGZvcm1hdHM6IHsKICAgICAgICBMVDogJ0hIOm1tJywKICAgICAgICBMVFM6ICdISDptbTpzcycsCiAgICAgICAgTDogJ0REL01NL1lZWVknLAogICAgICAgIExMOiAnRCBNTU1NIFlZWVknLAogICAgICAgIExMTDogJ0QgTU1NTSBZWVlZIEhIOm1tJywKICAgICAgICBMTExMOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nCiAgICAgIH0sCiAgICAgIG9yZGluYWw6IG4gPT4gewogICAgICAgIGNvbnN0IHMgPSBbJ3RoJywgJ3N0JywgJ25kJywgJ3JkJ107CiAgICAgICAgY29uc3QgdiA9IG4gJSAxMDA7CiAgICAgICAgcmV0dXJuIGBbJHtufSR7c1sodiAtIDIwKSAlIDEwXSB8fCBzW3ZdIHx8IHNbMF19XWA7CiAgICAgIH0KICAgIH0KICB9Owp9Ci8qKgogKiBQcmVwYXJlIHN0eWxlCiAqCiAqIEByZXR1cm5zIHtvYmplY3R9CiAqLwoKCmZ1bmN0aW9uIHByZXBhcmVTdHlsZSh1c2VyU3R5bGUpIHsKICBsZXQgZm9udFNpemUgPSAnMTJweCc7CiAgbGV0IGZvbnRGYW1pbHkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LWZhbWlseScpLnRvU3RyaW5nKCk7CgogIGlmICh0eXBlb2YgdXNlclN0eWxlICE9PSAndW5kZWZpbmVkJykgewogICAgaWYgKHR5cGVvZiB1c2VyU3R5bGUuZm9udFNpemUgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgIGZvbnRTaXplID0gdXNlclN0eWxlLmZvbnRTaXplOwogICAgfQoKICAgIGlmICh0eXBlb2YgdXNlclN0eWxlLmZvbnRGYW1pbHkgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgIGZvbnRGYW1pbHkgPSB1c2VyU3R5bGUuZm9udEZhbWlseTsKICAgIH0KICB9CgogIHJldHVybiBnZXRTdHlsZShmb250U2l6ZSwgZm9udEZhbWlseSk7Cn0KLyoqCiAqIEhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgc3BlY2lmaWVkIHZhcmlhYmxlIGlzIGFuIG9iamVjdAogKgogKiBAcGFyYW0ge2FueX0gaXRlbQogKgogKiBAcmV0dXJucyB7Ym9vbGVhbn0KICovCgoKZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkgewogIHJldHVybiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgJiYgIShpdGVtIGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSAmJiB0eXBlb2YgaXRlbSAhPT0gJ2Z1bmN0aW9uJzsKfQovKioKICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIHdpbGwgbWVyZ2Ugb2JqZWN0cyByZWN1cnNpdmVseSAtIGNyZWF0aW5nIGJyYW5kIG5ldyBvbmUgLSBsaWtlIGNsb25lCiAqCiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQKICogQHBhcmFtcyB7b2JqZWN0fSBzb3VyY2VzCiAqCiAqIEByZXR1cm5zIHtvYmplY3R9CiAqLwoKCmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZXAodGFyZ2V0LCAuLi5zb3VyY2VzKSB7CiAgaWYgKCFzb3VyY2VzLmxlbmd0aCkgewogICAgcmV0dXJuIHRhcmdldDsKICB9CgogIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTsKCiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkgewogICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7CiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHsKICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTsKICAgICAgICB9CgogICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7CiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2Vba2V5XSkpIHsKICAgICAgICB0YXJnZXRba2V5XSA9IFtdOwoKICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHNvdXJjZVtrZXldKSB7CiAgICAgICAgICBpZiAoaXNPYmplY3QoaXRlbSkpIHsKICAgICAgICAgICAgdGFyZ2V0W2tleV0ucHVzaChtZXJnZURlZXAoe30sIGl0ZW0pKTsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CgogICAgICAgICAgdGFyZ2V0W2tleV0ucHVzaChpdGVtKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpOwp9Ci8qKgogKiBEZXRlY3QgaWYgb2JqZWN0IG9yIGFycmF5IGlzIG9ic2VydmFibGUKICoKICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IG9iagogKgogKiBAcmV0dXJucyB7Ym9vbGVhbn0KICovCgpmdW5jdGlvbiBpc09ic2VydmFibGUob2JqKSB7CiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgnX19vYl9fJyk7Cn0KLyoqCiAqIFNhbWUgYXMgYWJvdmUgYnV0IHdpdGggcmVhY3Rpdml0eSBpbiBtaW5kCiAqCiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQKICogQHBhcmFtcyB7b2JqZWN0fSBzb3VyY2VzCiAqCiAqIEByZXR1cm5zIHtvYmplY3R9CiAqLwoKCmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZXBSZWFjdGl2ZShjb21wb25lbnQsIHRhcmdldCwgLi4uc291cmNlcykgewogIGlmICghc291cmNlcy5sZW5ndGgpIHsKICAgIHJldHVybiB0YXJnZXQ7CiAgfQoKICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CgogIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHsKICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkgewogICAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7CiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIGNvbXBvbmVudC4kc2V0KHRhcmdldCwga2V5LCB7fSk7CiAgICAgICAgfQoKICAgICAgICBtZXJnZURlZXBSZWFjdGl2ZShjb21wb25lbnQsIHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7CiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2Vba2V5XSkpIHsKICAgICAgICBjb21wb25lbnQuJHNldCh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOwogICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2Vba2V5XSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgIGlmIChzb3VyY2Vba2V5XS50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSA9PT0gLTEpIHsKICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGNvbXBvbmVudC4kc2V0KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBtZXJnZURlZXBSZWFjdGl2ZShjb21wb25lbnQsIHRhcmdldCwgLi4uc291cmNlcyk7Cn0KLyoqCiAqIENoZWNrIGlmIG9iamVjdHMgb3IgYXJyYXlzIGFyZSBlcXVhbCBieSBjb21wYXJpbmcgbmVzdGVkIHZhbHVlcwogKgogKiBAcGFyYW0ge29iamVjdHxhcnJheX0gbGVmdAogKiBAcGFyYW0ge29iamVjdHxhcnJheX0gcmlnaHQKICoKICogQHJldHVybnMge2Jvb2xlYW59CiAqLwoKZXhwb3J0IGZ1bmN0aW9uIG5vdEVxdWFsRGVlcChsZWZ0LCByaWdodCwgY2FjaGUgPSBbXSwgcGF0aCA9ICcnKSB7CiAgaWYgKHR5cGVvZiByaWdodCAhPT0gdHlwZW9mIGxlZnQpIHsKICAgIHJldHVybiB7CiAgICAgIGxlZnQsCiAgICAgIHJpZ2h0LAogICAgICB3aGF0OiBwYXRoICsgJy50eXBlb2YnCiAgICB9OwogIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsZWZ0KSAmJiAhQXJyYXkuaXNBcnJheShyaWdodCkpIHsKICAgIHJldHVybiB7CiAgICAgIGxlZnQsCiAgICAgIHJpZ2h0LAogICAgICB3aGF0OiBwYXRoICsgJy5pc0FycmF5JwogICAgfTsKICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmlnaHQpICYmICFBcnJheS5pc0FycmF5KGxlZnQpKSB7CiAgICByZXR1cm4gewogICAgICBsZWZ0LAogICAgICByaWdodCwKICAgICAgd2hhdDogcGF0aCArICcuaXNBcnJheScKICAgIH07CiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGxlZnQpICYmIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7CiAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkgewogICAgICByZXR1cm4gewogICAgICAgIGxlZnQsCiAgICAgICAgcmlnaHQsCiAgICAgICAgd2hhdDogcGF0aCArICcubGVuZ3RoJwogICAgICB9OwogICAgfQoKICAgIGxldCB3aGF0OwoKICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuID0gbGVmdC5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7CiAgICAgIGlmICh3aGF0ID0gbm90RXF1YWxEZWVwKGxlZnRbaW5kZXhdLCByaWdodFtpbmRleF0sIGNhY2hlLCBwYXRoICsgJy4nICsgaW5kZXgpKSB7CiAgICAgICAgcmV0dXJuIHdoYXQ7CiAgICAgIH0KICAgIH0KICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxlZnQpICYmICFpc09iamVjdChyaWdodCkpIHsKICAgIHJldHVybiB7CiAgICAgIGxlZnQsCiAgICAgIHJpZ2h0LAogICAgICB3aGF0OiBwYXRoICsgJy5pc09iamVjdCcKICAgIH07CiAgfSBlbHNlIGlmIChpc09iamVjdChyaWdodCkgJiYgIWlzT2JqZWN0KGxlZnQpKSB7CiAgICByZXR1cm4gewogICAgICBsZWZ0LAogICAgICByaWdodCwKICAgICAgd2hhdDogcGF0aCArICcuaXNPYmplY3QnCiAgICB9OwogIH0gZWxzZSBpZiAoaXNPYmplY3QobGVmdCkgJiYgaXNPYmplY3QocmlnaHQpKSB7CiAgICBmb3IgKGxldCBrZXkgaW4gbGVmdCkgewogICAgICBpZiAoIWxlZnQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAhbGVmdC5wcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KCiAgICAgIGlmICghcmlnaHQuaGFzT3duUHJvcGVydHkoa2V5KSkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBsZWZ0LAogICAgICAgICAgcmlnaHQsCiAgICAgICAgICB3aGF0OiBwYXRoICsgJy4nICsga2V5CiAgICAgICAgfTsKICAgICAgfQoKICAgICAgbGV0IHdoYXQ7CgogICAgICBpZiAod2hhdCA9IG5vdEVxdWFsRGVlcChsZWZ0W2tleV0sIHJpZ2h0W2tleV0sIGNhY2hlLCBwYXRoICsgJy4nICsga2V5KSkgewogICAgICAgIHJldHVybiB3aGF0OwogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmIChsZWZ0ICE9PSByaWdodCkgewogICAgcmV0dXJuIHsKICAgICAgbGVmdCwKICAgICAgcmlnaHQsCiAgICAgIHdoYXQ6IHBhdGggKyAnLiAhPT0nCiAgICB9OwogIH0KCiAgcmV0dXJuIGZhbHNlOwp9Ci8qKgogKiBHYW50dEVsYXN0aWMKICogTWFpbiB2dWUgY29tcG9uZW50CiAqLwoKY29uc3QgR2FudHRFbGFzdGljID0gewogIG5hbWU6ICdHYW50dEVsYXN0aWMnLAogIGNvbXBvbmVudHM6IHsKICAgIE1haW5WaWV3CiAgfSwKICBwcm9wczogWyd0YXNrcycsICdvcHRpb25zJywgJ2R5bmFtaWNTdHlsZSddLAoKICBwcm92aWRlKCkgewogICAgY29uc3QgcHJvdmlkZXIgPSB7fTsKICAgIGNvbnN0IHNlbGYgPSB0aGlzOwogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3ZpZGVyLCAncm9vdCcsIHsKICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgZ2V0OiAoKSA9PiBzZWxmCiAgICB9KTsKICAgIHJldHVybiBwcm92aWRlcjsKICB9LAoKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgc3RhdGU6IHsKICAgICAgICB0YXNrczogW10sCiAgICAgICAgb3B0aW9uczogewogICAgICAgICAgc2Nyb2xsQmFySGVpZ2h0OiAwLAogICAgICAgICAgYWxsVmlzaWJsZVRhc2tzSGVpZ2h0OiAwLAogICAgICAgICAgb3V0ZXJIZWlnaHQ6IDAsCiAgICAgICAgICBzY3JvbGw6IHsKICAgICAgICAgICAgbGVmdDogMCwKICAgICAgICAgICAgdG9wOiAwCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBkeW5hbWljU3R5bGU6IHt9LAogICAgICAgIHJlZnM6IHt9LAogICAgICAgIHRhc2tzQnlJZDoge30sCiAgICAgICAgdGFza1RyZWU6IHt9LAogICAgICAgIGN0eCwKICAgICAgICBlbWl0VGFza3NDaGFuZ2VzOiB0cnVlLAogICAgICAgIC8vIHNvbWUgb3BlcmF0aW9ucyBtYXkgcGF1c2UgZW1pdHRpbmcgY2hhbmdlcyB0byBwYXJlbnQgY29tcG9uZW50CiAgICAgICAgZW1pdE9wdGlvbnNDaGFuZ2VzOiB0cnVlLAogICAgICAgIC8vIHNvbWUgb3BlcmF0aW9ucyBtYXkgcGF1c2UgZW1pdHRpbmcgY2hhbmdlcyB0byBwYXJlbnQgY29tcG9uZW50CiAgICAgICAgcmVzaXplT2JzZXJ2ZXI6IG51bGwsCiAgICAgICAgdW53YXRjaFRhc2tzOiBudWxsLAogICAgICAgIHVud2F0Y2hPcHRpb25zOiBudWxsLAogICAgICAgIHVud2F0Y2hTdHlsZTogbnVsbCwKICAgICAgICB1bndhdGNoT3V0cHV0VGFza3M6IG51bGwsCiAgICAgICAgdW53YXRjaE91dHB1dE9wdGlvbnM6IG51bGwsCiAgICAgICAgdW53YXRjaE91dHB1dFN0eWxlOiBudWxsCiAgICAgIH0KICAgIH07CiAgfSwKCiAgbWV0aG9kczogewogICAgbWVyZ2VEZWVwLAogICAgbWVyZ2VEZWVwUmVhY3RpdmUsCgogICAgLyoqCiAgICAgKiBDYWxjdWxhdGUgaGVpZ2h0IG9mIHNjcm9sbGJhciBpbiBjdXJyZW50IGJyb3dzZXIKICAgICAqCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfQogICAgICovCiAgICBnZXRTY3JvbGxCYXJIZWlnaHQoKSB7CiAgICAgIGNvbnN0IG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgICAgIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJzsKICAgICAgb3V0ZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JzsKICAgICAgb3V0ZXIuc3R5bGUubXNPdmVyZmxvd1N0eWxlID0gJ3Njcm9sbGJhcic7CiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpOwogICAgICB2YXIgbm9TY3JvbGwgPSBvdXRlci5vZmZzZXRIZWlnaHQ7CiAgICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7CiAgICAgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOwogICAgICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7CiAgICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTsKICAgICAgdmFyIHdpdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRIZWlnaHQ7CiAgICAgIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpOwogICAgICBjb25zdCBoZWlnaHQgPSBub1Njcm9sbCAtIHdpdGhTY3JvbGw7CiAgICAgIHRoaXMuc3R5bGVbJ2NoYXJ0LXNjcm9sbC1jb250YWluZXItLXZlcnRpY2FsJ11bJ21hcmdpbi1sZWZ0J10gPSBgLSR7aGVpZ2h0fXB4YDsKICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGxCYXJIZWlnaHQgPSBoZWlnaHQ7CiAgICB9LAoKICAgIC8qKgogICAgICogRmlsbCBvdXQgZW1wdHkgdGFzayBwcm9wZXJ0aWVzIGFuZCBtYWtlIGl0IHJlYWN0aXZlCiAgICAgKgogICAgICogQHBhcmFtIHthcnJheX0gdGFza3MKICAgICAqLwogICAgZmlsbFRhc2tzKHRhc2tzKSB7CiAgICAgIGZvciAobGV0IHRhc2sgb2YgdGFza3MpIHsKICAgICAgICBpZiAodHlwZW9mIHRhc2sueCA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2sueCA9IDA7CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIHRhc2sueSA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2sueSA9IDA7CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIHRhc2sud2lkdGggPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLndpZHRoID0gMDsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgdGFzay5oZWlnaHQgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLmhlaWdodCA9IDA7CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIHRhc2subW91c2VPdmVyID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFzay5tb3VzZU92ZXIgPSBmYWxzZTsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgdGFzay5jb2xsYXBzZWQgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLmNvbGxhcHNlZCA9IGZhbHNlOwogICAgICAgIH0KCiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLmRlcGVuZGVudE9uID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFzay5kZXBlbmRlbnRPbiA9IFtdOwogICAgICAgIH0KCiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLnBhcmVudElkID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFzay5wYXJlbnRJZCA9IG51bGw7CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIHRhc2suc3R5bGUgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLnN0eWxlID0ge307CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIHRhc2suY2hpbGRyZW4gPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLmNoaWxkcmVuID0gW107CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIHRhc2suYWxsQ2hpbGRyZW4gPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLmFsbENoaWxkcmVuID0gW107CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIHRhc2sucGFyZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2sucGFyZW50cyA9IFtdOwogICAgICAgIH0KCiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLnBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2sucGFyZW50ID0gbnVsbDsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgdGFzay5zdGFydFRpbWUgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLnN0YXJ0VGltZSA9IGRheWpzKHRhc2suc3RhcnQpLnZhbHVlT2YoKTsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgdGFzay5lbmRUaW1lID09PSAndW5kZWZpbmVkJyAmJiB0YXNrLmhhc093blByb3BlcnR5KCdlbmQnKSkgewogICAgICAgICAgdGFzay5lbmRUaW1lID0gZGF5anModGFzay5lbmQpLnZhbHVlT2YoKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXNrLmVuZFRpbWUgPT09ICd1bmRlZmluZWQnICYmIHRhc2suaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykpIHsKICAgICAgICAgIHRhc2suZW5kVGltZSA9IHRhc2suc3RhcnRUaW1lICsgdGFzay5kdXJhdGlvbjsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgdGFzay5kdXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgJiYgdGFzay5oYXNPd25Qcm9wZXJ0eSgnZW5kVGltZScpKSB7CiAgICAgICAgICB0YXNrLmR1cmF0aW9uID0gdGFzay5lbmRUaW1lIC0gdGFzay5zdGFydFRpbWU7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdGFza3M7CiAgICB9LAoKICAgIC8qKgogICAgICogTWFwIHRhc2tzCiAgICAgKgogICAgICogQHBhcmFtIHtBcnJheX0gdGFza3MKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zCiAgICAgKi8KICAgIG1hcFRhc2tzKHRhc2tzLCBvcHRpb25zKSB7CiAgICAgIGZvciAobGV0IFtpbmRleCwgdGFza10gb2YgdGFza3MuZW50cmllcygpKSB7CiAgICAgICAgdGFza3NbaW5kZXhdID0geyAuLi50YXNrLAogICAgICAgICAgaWQ6IHRhc2tbb3B0aW9ucy50YXNrTWFwcGluZy5pZF0sCiAgICAgICAgICBzdGFydDogdGFza1tvcHRpb25zLnRhc2tNYXBwaW5nLnN0YXJ0XSwKICAgICAgICAgIGxhYmVsOiB0YXNrW29wdGlvbnMudGFza01hcHBpbmcubGFiZWxdLAogICAgICAgICAgZHVyYXRpb246IHRhc2tbb3B0aW9ucy50YXNrTWFwcGluZy5kdXJhdGlvbl0sCiAgICAgICAgICBwcm9ncmVzczogdGFza1tvcHRpb25zLnRhc2tNYXBwaW5nLnByb2dyZXNzXSwKICAgICAgICAgIHR5cGU6IHRhc2tbb3B0aW9ucy50YXNrTWFwcGluZy50eXBlXSwKICAgICAgICAgIHN0eWxlOiB0YXNrW29wdGlvbnMudGFza01hcHBpbmcuc3R5bGVdLAogICAgICAgICAgY29sbGFwc2VkOiB0YXNrW29wdGlvbnMudGFza01hcHBpbmcuY29sbGFwc2VkXQogICAgICAgIH07CiAgICAgIH0KCiAgICAgIHJldHVybiB0YXNrczsKICAgIH0sCgogICAgLyoqCiAgICAgKiBJbml0aWFsaXplIGNvbXBvbmVudAogICAgICovCiAgICBpbml0aWFsaXplKGl0c1VwZGF0ZSA9ICcnKSB7CiAgICAgIGxldCBvcHRpb25zID0gbWVyZ2VEZWVwKHt9LCB0aGlzLnN0YXRlLm9wdGlvbnMsIGdldE9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy5vcHRpb25zKTsKICAgICAgbGV0IHRhc2tzID0gdGhpcy5tYXBUYXNrcyh0aGlzLnRhc2tzLCBvcHRpb25zKTsKCiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnN0YXRlLmR5bmFtaWNTdHlsZSkubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhpcy5pbml0aWFsaXplU3R5bGUoKTsKICAgICAgfQoKICAgICAgZGF5anMubG9jYWxlKG9wdGlvbnMubG9jYWxlLCBudWxsLCB0cnVlKTsKICAgICAgZGF5anMubG9jYWxlKG9wdGlvbnMubG9jYWxlLm5hbWUpOwoKICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRhc2tMaXN0ID09PSAndW5kZWZpbmVkJykgewogICAgICAgIG9wdGlvbnMudGFza0xpc3QgPSB7fTsKICAgICAgfQoKICAgICAgb3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zID0gb3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gewogICAgICAgIGNvbHVtbi50aHJlc2hvbGRQZXJjZW50ID0gMTAwOwogICAgICAgIGNvbHVtbi53aWR0aEZyb21QZXJjZW50YWdlID0gMDsKICAgICAgICBjb2x1bW4uZmluYWxXaWR0aCA9IDA7CgogICAgICAgIGlmICh0eXBlb2YgY29sdW1uLmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIGNvbHVtbi5oZWlnaHQgPSAwOwogICAgICAgIH0KCiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4uc3R5bGUgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICBjb2x1bW4uc3R5bGUgPSB7fTsKICAgICAgICB9CgogICAgICAgIGNvbHVtbi5faWQgPSBgJHtpbmRleH0tJHtjb2x1bW4ubGFiZWx9YDsKICAgICAgICByZXR1cm4gY29sdW1uOwogICAgICB9KTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zID0gb3B0aW9uczsKICAgICAgdGFza3MgPSB0aGlzLmZpbGxUYXNrcyh0YXNrcyk7CiAgICAgIHRoaXMuc3RhdGUudGFza3NCeUlkID0gdGhpcy5yZXNldFRhc2tUcmVlKHRhc2tzKTsKICAgICAgdGhpcy5zdGF0ZS50YXNrVHJlZSA9IHRoaXMubWFrZVRhc2tUcmVlKHRoaXMuc3RhdGUucm9vdFRhc2ssIHRhc2tzKTsKICAgICAgdGhpcy5zdGF0ZS50YXNrcyA9IHRoaXMuc3RhdGUudGFza1RyZWUuYWxsQ2hpbGRyZW4ubWFwKGNoaWxkSWQgPT4gdGhpcy5nZXRUYXNrKGNoaWxkSWQpKTsKICAgICAgdGhpcy5jYWxjdWxhdGVUYXNrTGlzdENvbHVtbnNEaW1lbnNpb25zKCk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGxCYXJIZWlnaHQgPSB0aGlzLmdldFNjcm9sbEJhckhlaWdodCgpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMub3V0ZXJIZWlnaHQgPSB0aGlzLnN0YXRlLm9wdGlvbnMuaGVpZ2h0ICsgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbEJhckhlaWdodDsKICAgICAgdGhpcy5nbG9iYWxPblJlc2l6ZSgpOwogICAgfSwKCiAgICAvKioKICAgICAqIEluaXRpYWxpemUgc3R5bGUKICAgICAqLwogICAgaW5pdGlhbGl6ZVN0eWxlKCkgewogICAgICB0aGlzLnN0YXRlLmR5bmFtaWNTdHlsZSA9IG1lcmdlRGVlcCh7fSwgcHJlcGFyZVN0eWxlKHRoaXMuZHluYW1pY1N0eWxlKSwgdGhpcy5keW5hbWljU3R5bGUpOwogICAgfSwKCiAgICAvKioKICAgICAqIEdldCBjYWxlbmRhciByb3dzIG91dGVyIGhlaWdodAogICAgICoKICAgICAqIEByZXR1cm5zIHtpbnR9CiAgICAgKi8KICAgIGdldENhbGVuZGFySGVpZ2h0KCkgewogICAgICByZXR1cm4gdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhlaWdodCArIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5zdHJva2VXaWR0aDsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgbWF4aW1hbCBsZXZlbCBvZiBuZXN0ZWQgdGFzayBjaGlsZHJlbgogICAgICoKICAgICAqIEByZXR1cm5zIHtpbnR9CiAgICAgKi8KICAgIGdldE1heGltYWxMZXZlbCgpIHsKICAgICAgbGV0IG1heGltYWxMZXZlbCA9IDA7CiAgICAgIHRoaXMuc3RhdGUudGFza3MuZm9yRWFjaCh0YXNrID0+IHsKICAgICAgICBpZiAodGFzay5wYXJlbnRzLmxlbmd0aCA+IG1heGltYWxMZXZlbCkgewogICAgICAgICAgbWF4aW1hbExldmVsID0gdGFzay5wYXJlbnRzLmxlbmd0aDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gbWF4aW1hbExldmVsIC0gMTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgbWF4aW1hbCBleHBhbmRlciB3aWR0aCAtIHRvIGNhbGN1bGF0ZSBzdHJhaWdodCB0YXNrIGxpc3QgdGV4dAogICAgICoKICAgICAqIEByZXR1cm5zIHtpbnR9CiAgICAgKi8KICAgIGdldE1heGltYWxFeHBhbmRlcldpZHRoKCkgewogICAgICByZXR1cm4gdGhpcy5nZXRNYXhpbWFsTGV2ZWwoKSAqIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC5leHBhbmRlci5wYWRkaW5nICsgdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LmV4cGFuZGVyLm1hcmdpbjsKICAgIH0sCgogICAgLyoqCiAgICAgKiBTeW5jaHJvbml6ZSBzY3JvbGxUb3AgcHJvcGVydHkgd2hlbiByb3cgaGVpZ2h0IGlzIGNoYW5nZWQKICAgICAqLwogICAgc3luY1Njcm9sbFRvcCgpIHsKICAgICAgaWYgKHRoaXMuc3RhdGUucmVmcy50YXNrTGlzdEl0ZW1zICYmIHRoaXMuc3RhdGUucmVmcy5jaGFydEdyYXBoLnNjcm9sbFRvcCAhPT0gdGhpcy5zdGF0ZS5yZWZzLnRhc2tMaXN0SXRlbXMuc2Nyb2xsVG9wKSB7CiAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC50b3AgPSB0aGlzLnN0YXRlLnJlZnMudGFza0xpc3RJdGVtcy5zY3JvbGxUb3AgPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJWZXJ0aWNhbC5zY3JvbGxUb3AgPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRHcmFwaC5zY3JvbGxUb3A7CiAgICAgIH0KICAgIH0sCgogICAgLyoqCiAgICAgKiBDYWxjdWxhdGUgdGFzayBsaXN0IGNvbHVtbnMgZGltZW5zaW9ucwogICAgICovCiAgICBjYWxjdWxhdGVUYXNrTGlzdENvbHVtbnNEaW1lbnNpb25zKCkgewogICAgICBsZXQgZmluYWwgPSAwOwogICAgICBsZXQgcGVyY2VudGFnZSA9IDA7CgogICAgICBmb3IgKGxldCBjb2x1bW4gb2YgdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LmNvbHVtbnMpIHsKICAgICAgICBpZiAoY29sdW1uLmV4cGFuZGVyKSB7CiAgICAgICAgICBjb2x1bW4ud2lkdGhGcm9tUGVyY2VudGFnZSA9ICh0aGlzLmdldE1heGltYWxFeHBhbmRlcldpZHRoKCkgKyBjb2x1bW4ud2lkdGgpIC8gMTAwICogdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LnBlcmNlbnQ7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbHVtbi53aWR0aEZyb21QZXJjZW50YWdlID0gY29sdW1uLndpZHRoIC8gMTAwICogdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LnBlcmNlbnQ7CiAgICAgICAgfQoKICAgICAgICBwZXJjZW50YWdlICs9IGNvbHVtbi53aWR0aEZyb21QZXJjZW50YWdlOwogICAgICAgIGNvbHVtbi5maW5hbFdpZHRoID0gY29sdW1uLnRocmVzaG9sZFBlcmNlbnQgKiBjb2x1bW4ud2lkdGhGcm9tUGVyY2VudGFnZSAvIDEwMDsKICAgICAgICBmaW5hbCArPSBjb2x1bW4uZmluYWxXaWR0aDsKICAgICAgICBjb2x1bW4uaGVpZ2h0ID0gdGhpcy5nZXRUYXNrSGVpZ2h0KCkgLSB0aGlzLnN0eWxlWydncmlkLWxpbmUtaG9yaXpvbnRhbCddWydzdHJva2Utd2lkdGgnXTsKICAgICAgfQoKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LndpZHRoRnJvbVBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3QuZmluYWxXaWR0aCA9IGZpbmFsOwogICAgfSwKCiAgICAvKioKICAgICAqIFJlc2V0IHRhc2sgdHJlZSAtIHdoaWNoIGlzIHVzZWQgdG8gY3JlYXRlIHRyZWUgbGlrZSBzdHJ1Y3R1cmUgaW5zaWRlIHRhc2sgbGlzdAogICAgICovCiAgICByZXNldFRhc2tUcmVlKHRhc2tzKSB7CiAgICAgIHRoaXMuJHNldCh0aGlzLnN0YXRlLCAncm9vdFRhc2snLCB7CiAgICAgICAgaWQ6IG51bGwsCiAgICAgICAgbGFiZWw6ICdyb290JywKICAgICAgICBjaGlsZHJlbjogW10sCiAgICAgICAgYWxsQ2hpbGRyZW46IFtdLAogICAgICAgIHBhcmVudHM6IFtdLAogICAgICAgIHBhcmVudDogbnVsbCwKICAgICAgICBfX3Jvb3Q6IHRydWUKICAgICAgfSk7CiAgICAgIGNvbnN0IHRhc2tzQnlJZCA9IHt9OwoKICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRhc2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXNrc1tpXTsKICAgICAgICBjdXJyZW50LmNoaWxkcmVuID0gW107CiAgICAgICAgY3VycmVudC5hbGxDaGlsZHJlbiA9IFtdOwogICAgICAgIGN1cnJlbnQucGFyZW50ID0gbnVsbDsKICAgICAgICBjdXJyZW50LnBhcmVudHMgPSBbXTsKICAgICAgICB0YXNrc0J5SWRbY3VycmVudC5pZF0gPSBjdXJyZW50OwogICAgICB9CgogICAgICByZXR1cm4gdGFza3NCeUlkOwogICAgfSwKCiAgICAvKioKICAgICAqIE1ha2UgdGFzayB0cmVlLCBhZnRlciByZXNldCAtIGxvb2sgYWJvdmUKICAgICAqCiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFzawogICAgICogQHJldHVybnMge29iamVjdH0gdGFza3Mgd2l0aCBjaGlsZHJlbiBhbmQgcGFyZW50cwogICAgICovCiAgICBtYWtlVGFza1RyZWUodGFzaywgdGFza3MpIHsKICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRhc2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXNrc1tpXTsKCiAgICAgICAgaWYgKGN1cnJlbnQucGFyZW50SWQgPT09IHRhc2suaWQpIHsKICAgICAgICAgIGlmICh0YXNrLnBhcmVudHMubGVuZ3RoKSB7CiAgICAgICAgICAgIHRhc2sucGFyZW50cy5mb3JFYWNoKHBhcmVudCA9PiBjdXJyZW50LnBhcmVudHMucHVzaChwYXJlbnQpKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIXRhc2sucHJvcGVydHlJc0VudW1lcmFibGUoJ19fcm9vdCcpKSB7CiAgICAgICAgICAgIGN1cnJlbnQucGFyZW50cy5wdXNoKHRhc2suaWQpOwogICAgICAgICAgICBjdXJyZW50LnBhcmVudCA9IHRhc2suaWQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjdXJyZW50LnBhcmVudHMgPSBbXTsKICAgICAgICAgICAgY3VycmVudC5wYXJlbnQgPSBudWxsOwogICAgICAgICAgfQoKICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLm1ha2VUYXNrVHJlZShjdXJyZW50LCB0YXNrcyk7CiAgICAgICAgICB0YXNrLmFsbENoaWxkcmVuLnB1c2goY3VycmVudC5pZCk7CiAgICAgICAgICB0YXNrLmNoaWxkcmVuLnB1c2goY3VycmVudC5pZCk7CiAgICAgICAgICBjdXJyZW50LmFsbENoaWxkcmVuLmZvckVhY2goY2hpbGRJZCA9PiB0YXNrLmFsbENoaWxkcmVuLnB1c2goY2hpbGRJZCkpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRhc2s7CiAgICB9LAoKICAgIC8qKgogICAgICogR2V0IHRhc2sgYnkgaWQKICAgICAqCiAgICAgKiBAcGFyYW0ge2FueX0gdGFza0lkCiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9IHRhc2sKICAgICAqLwogICAgZ2V0VGFzayh0YXNrSWQpIHsKICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0YXRlLnRhc2tzQnlJZFt0YXNrSWRdICE9PSAndW5kZWZpbmVkJykgewogICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnRhc2tzQnlJZFt0YXNrSWRdOwogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgY2hpbGRyZW4gdGFza3MgZm9yIHNwZWNpZmllZCB0YXNrSWQKICAgICAqCiAgICAgKiBAcGFyYW0ge2FueX0gdGFza0lkCiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IGNoaWxkcmVuCiAgICAgKi8KICAgIGdldENoaWxkcmVuKHRhc2tJZCkgewogICAgICByZXR1cm4gdGhpcy5zdGF0ZS50YXNrcy5maWx0ZXIodGFzayA9PiB0YXNrLnBhcmVudCA9PT0gdGFza0lkKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBJcyB0YXNrIHZpc2libGUKICAgICAqCiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8VGFza30gdGFzawogICAgICovCiAgICBpc1Rhc2tWaXNpYmxlKHRhc2spIHsKICAgICAgaWYgKHR5cGVvZiB0YXNrID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdGFzayA9PT0gJ3N0cmluZycpIHsKICAgICAgICB0YXNrID0gdGhpcy5nZXRUYXNrKHRhc2spOwogICAgICB9CgogICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGFzay5wYXJlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgaWYgKHRoaXMuZ2V0VGFzayh0YXNrLnBhcmVudHNbaV0pLmNvbGxhcHNlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9LAoKICAgIC8qKgogICAgICogR2V0IHN2ZwogICAgICoKICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGh0bWwgc3ZnIGltYWdlIG9mIGdhbnR0CiAgICAgKi8KICAgIGdldFNWRygpIHsKICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3B0aW9ucy5tYWluVmlldy5vdXRlckhUTUw7CiAgICB9LAoKICAgIC8qKgogICAgICogR2V0IGltYWdlCiAgICAgKgogICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgaW1hZ2UgZm9ybWF0CiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gd2hlbiByZXNvbHZlZCByZXR1cm5zIGJhc2U2NCBpbWFnZSBzdHJpbmcgb2YgZ2FudHQKICAgICAqLwogICAgZ2V0SW1hZ2UodHlwZSA9ICdpbWFnZS9wbmcnKSB7CiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHsKICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTsKCiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHsKICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOwogICAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5zdGF0ZS5vcHRpb25zLm1haW5WaWV3LmNsaWVudFdpZHRoOwogICAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc3RhdGUub3B0aW9ucy5yb3dzSGVpZ2h0OwogICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltZywgMCwgMCk7CiAgICAgICAgICByZXNvbHZlKGNhbnZhcy50b0RhdGFVUkwodHlwZSkpOwogICAgICAgIH07CgogICAgICAgIGltZy5zcmMgPSAnZGF0YTppbWFnZS9zdmcreG1sLCcgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5nZXRTVkcoKSk7CiAgICAgIH0pOwogICAgfSwKCiAgICAvKioKICAgICAqIEdldCBnYW50dCB0b3RhbCBoZWlnaHQKICAgICAqCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfQogICAgICovCiAgICBnZXRIZWlnaHQodmlzaWJsZVRhc2tzLCBvdXRlciA9IGZhbHNlKSB7CiAgICAgIGxldCBoZWlnaHQgPSB2aXNpYmxlVGFza3MubGVuZ3RoICogKHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0ICsgdGhpcy5zdGF0ZS5vcHRpb25zLmNoYXJ0LmdyaWQuaG9yaXpvbnRhbC5nYXAgKiAyKSArIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5oZWlnaHQgKyB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuc3Ryb2tlV2lkdGggKyB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZ2FwOwoKICAgICAgaWYgKG91dGVyKSB7CiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGxCYXJIZWlnaHQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBoZWlnaHQ7CiAgICB9LAoKICAgIC8qKgogICAgICogR2V0IG9uZSB0YXNrIGhlaWdodAogICAgICoKICAgICAqIEByZXR1cm5zIHtudW1iZXJ9CiAgICAgKi8KICAgIGdldFRhc2tIZWlnaHQod2l0aFN0cm9rZSA9IGZhbHNlKSB7CiAgICAgIGlmICh3aXRoU3Ryb2tlKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0ICsgdGhpcy5zdGF0ZS5vcHRpb25zLmNoYXJ0LmdyaWQuaG9yaXpvbnRhbC5nYXAgKiAyICsgdGhpcy5zdHlsZVsnZ3JpZC1saW5lLWhvcml6b250YWwnXVsnc3Ryb2tlLXdpZHRoJ107CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLnN0YXRlLm9wdGlvbnMucm93LmhlaWdodCArIHRoaXMuc3RhdGUub3B0aW9ucy5jaGFydC5ncmlkLmhvcml6b250YWwuZ2FwICogMjsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgc3BlY2lmaWVkIHRhc2tzIGhlaWdodAogICAgICoKICAgICAqIEByZXR1cm5zIHtudW1iZXJ9CiAgICAgKi8KICAgIGdldFRhc2tzSGVpZ2h0KHZpc2libGVUYXNrcykgewogICAgICByZXR1cm4gdmlzaWJsZVRhc2tzLmxlbmd0aCAqIHRoaXMuZ2V0VGFza0hlaWdodCgpOwogICAgfSwKCiAgICAvKioKICAgICAqIENvbnZlcnQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0byBwaXhlbCBvZmZzZXQgaW5zaWRlIGNoYXJ0CiAgICAgKgogICAgICogQHBhcmFtIHtpbnR9IG1zCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfQogICAgICovCiAgICB0aW1lVG9QaXhlbE9mZnNldFgobXMpIHsKICAgICAgbGV0IHggPSBtcyAtIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRpbWU7CgogICAgICBpZiAoeCkgewogICAgICAgIHggPSB4IC8gdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRpbWVQZXJQaXhlbDsKICAgICAgfQoKICAgICAgcmV0dXJuIHg7CiAgICB9LAoKICAgIC8qKgogICAgICogQ29udmVydCBwaXhlbCBvZmZzZXQgaW5zaWRlIGNoYXJ0IHRvIGNvcnJlc3BvbmRpbmcgdGltZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzCiAgICAgKgogICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsT2Zmc2V0WAogICAgICogQHJldHVybnMge2ludH0gbWlsbGlzZWNvbmRzCiAgICAgKi8KICAgIHBpeGVsT2Zmc2V0WFRvVGltZShwaXhlbE9mZnNldFgpIHsKICAgICAgbGV0IG9mZnNldCA9IHBpeGVsT2Zmc2V0WCArIHRoaXMuc3R5bGVbJ2dyaWQtbGluZS12ZXJ0aWNhbCddWydzdHJva2Utd2lkdGgnXSAvIDI7CiAgICAgIHJldHVybiBvZmZzZXQgKiB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVBlclBpeGVsICsgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBEZXRlcm1pbmUgaWYgZWxlbWVudCBpcyBpbnNpZGUgY3VycmVudCB2aWV3IHBvcnQKICAgICAqCiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIGVsZW1lbnQgcGxhY2VtZW50CiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBlbGVtZW50IHdpZHRoCiAgICAgKiBAcGFyYW0ge2ludH0gYnVmZmVyIC0gb3IgdGhyZXNob2xkLCBpZiBlbGVtZW50IGlzIG91dHNpZGUgdmlld3BvcnQgYnV0IG9mZnNldCBmcm9tIHZpZXcgcG9ydCBpcyBiZWxvdyB0aGlzIHZhbHVlIHJldHVybiB0cnVlCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0KICAgICAqLwogICAgaXNJbnNpZGVWaWV3UG9ydCh4LCB3aWR0aCwgYnVmZmVyID0gNTAwMCkgewogICAgICByZXR1cm4geCArIHdpZHRoICsgYnVmZmVyID49IHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQubGVmdCAmJiB4IC0gYnVmZmVyIDw9IHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQucmlnaHQgfHwgeCAtIGJ1ZmZlciA8PSB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LmxlZnQgJiYgeCArIHdpZHRoICsgYnVmZmVyID49IHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQucmlnaHQ7CiAgICB9LAoKICAgIC8qKgogICAgICogQ2hhcnQgc2Nyb2xsIGV2ZW50IGhhbmRsZXIKICAgICAqCiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldgogICAgICovCiAgICBvblNjcm9sbENoYXJ0KGV2KSB7CiAgICAgIHRoaXMuX29uU2Nyb2xsQ2hhcnQodGhpcy5zdGF0ZS5yZWZzLmNoYXJ0U2Nyb2xsQ29udGFpbmVySG9yaXpvbnRhbC5zY3JvbGxMZWZ0LCB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJWZXJ0aWNhbC5zY3JvbGxUb3ApOwogICAgfSwKCiAgICAvKioKICAgICAqIEFmdGVyIHNhbWUgYXMgYWJvdmUgYnV0IHdpdGggZGlmZmVyZW50IGFyZ3VtZW50cyAtIG5vcm1hbGl6ZWQKICAgICAqCiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdAogICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcAogICAgICovCiAgICBfb25TY3JvbGxDaGFydChsZWZ0LCB0b3ApIHsKICAgICAgaWYgKHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQubGVmdCA9PT0gbGVmdCAmJiB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LnRvcCA9PT0gdG9wKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBjaGFydENvbnRhaW5lcldpZHRoID0gdGhpcy5zdGF0ZS5yZWZzLmNoYXJ0Q29udGFpbmVyLmNsaWVudFdpZHRoOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LmxlZnQgPSBsZWZ0OwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LnJpZ2h0ID0gbGVmdCArIGNoYXJ0Q29udGFpbmVyV2lkdGg7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQucGVyY2VudCA9IGxlZnQgLyB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudG90YWxWaWV3RHVyYXRpb25QeCAqIDEwMDsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC50b3AgPSB0b3A7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQudGltZSA9IHRoaXMucGl4ZWxPZmZzZXRYVG9UaW1lKGxlZnQpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LnRpbWVDZW50ZXIgPSB0aGlzLnBpeGVsT2Zmc2V0WFRvVGltZShsZWZ0ICsgY2hhcnRDb250YWluZXJXaWR0aCAvIDIpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LmRhdGVUaW1lLmxlZnQgPSBkYXlqcyh0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LnRpbWUpLnZhbHVlT2YoKTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5kYXRlVGltZS5yaWdodCA9IGRheWpzKHRoaXMucGl4ZWxPZmZzZXRYVG9UaW1lKGxlZnQgKyB0aGlzLnN0YXRlLnJlZnMuY2hhcnQuY2xpZW50V2lkdGgpKS52YWx1ZU9mKCk7CiAgICAgIHRoaXMuc2Nyb2xsVG8obGVmdCwgdG9wKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBTY3JvbGwgY3VycmVudCBjaGFydCB0byBzcGVjaWZpZWQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKQogICAgICoKICAgICAqIEBwYXJhbSB7aW50fSB0aW1lCiAgICAgKi8KICAgIHNjcm9sbFRvVGltZSh0aW1lKSB7CiAgICAgIGxldCBwb3MgPSB0aGlzLnRpbWVUb1BpeGVsT2Zmc2V0WCh0aW1lKTsKICAgICAgY29uc3QgY2hhcnRDb250YWluZXJXaWR0aCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydENvbnRhaW5lci5jbGllbnRXaWR0aDsKICAgICAgcG9zID0gcG9zIC0gY2hhcnRDb250YWluZXJXaWR0aCAvIDI7CgogICAgICBpZiAocG9zID4gdGhpcy5zdGF0ZS5vcHRpb25zLndpZHRoKSB7CiAgICAgICAgcG9zID0gdGhpcy5zdGF0ZS5vcHRpb25zLndpZHRoIC0gY2hhcnRDb250YWluZXJXaWR0aDsKICAgICAgfQoKICAgICAgdGhpcy5zY3JvbGxUbyhwb3MpOwogICAgfSwKCiAgICAvKioKICAgICAqIFNjcm9sbCBjaGFydCBvciB0YXNrIGxpc3QgdG8gc3BlY2lmaWVkIHBpeGVsIHZhbHVlcwogICAgICoKICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IGxlZnQKICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IHRvcAogICAgICovCiAgICBzY3JvbGxUbyhsZWZ0ID0gbnVsbCwgdG9wID0gbnVsbCkgewogICAgICBpZiAobGVmdCAhPT0gbnVsbCkgewogICAgICAgIHRoaXMuc3RhdGUucmVmcy5jaGFydENhbGVuZGFyQ29udGFpbmVyLnNjcm9sbExlZnQgPSBsZWZ0OwogICAgICAgIHRoaXMuc3RhdGUucmVmcy5jaGFydEdyYXBoQ29udGFpbmVyLnNjcm9sbExlZnQgPSBsZWZ0OwogICAgICAgIHRoaXMuc3RhdGUucmVmcy5jaGFydFNjcm9sbENvbnRhaW5lckhvcml6b250YWwuc2Nyb2xsTGVmdCA9IGxlZnQ7CiAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5sZWZ0ID0gbGVmdDsKICAgICAgfQoKICAgICAgaWYgKHRvcCAhPT0gbnVsbCkgewogICAgICAgIHRoaXMuc3RhdGUucmVmcy5jaGFydFNjcm9sbENvbnRhaW5lclZlcnRpY2FsLnNjcm9sbFRvcCA9IHRvcDsKICAgICAgICB0aGlzLnN0YXRlLnJlZnMuY2hhcnRHcmFwaC5zY3JvbGxUb3AgPSB0b3A7CiAgICAgICAgdGhpcy5zdGF0ZS5yZWZzLnRhc2tMaXN0SXRlbXMuc2Nyb2xsVG9wID0gdG9wOwogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwudG9wID0gdG9wOwogICAgICAgIHRoaXMuc3luY1Njcm9sbFRvcCgpOwogICAgICB9CiAgICB9LAoKICAgIC8qKgogICAgICogQWZ0ZXIgc29tZSBhY3Rpb25zIGxpa2UgdGltZSB6b29tIGNoYW5nZSB3ZSBuZWVkIHRvIHJlY29tcGVuc2F0ZSBzY3JvbGwgcG9zaXRpb24KICAgICAqIHNvIGFzIGEgcmVzdWx0IGV2ZXJ5dGhpbmcgd2lsbCBiZSBpbiBzYW1lIHBsYWNlCiAgICAgKi8KICAgIGZpeFNjcm9sbFBvcygpIHsKICAgICAgdGhpcy5zY3JvbGxUb1RpbWUodGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC50aW1lQ2VudGVyKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBNb3VzZSB3aGVlbCBldmVudCBoYW5kbGVyCiAgICAgKi8KICAgIG9uV2hlZWxDaGFydChldikgewogICAgICBpZiAoIWV2LnNoaWZ0S2V5ICYmIGV2LmRlbHRhWCA9PT0gMCkgewogICAgICAgIGxldCB0b3AgPSB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLnRvcCArIGV2LmRlbHRhWTsKICAgICAgICBjb25zdCBjaGFydENsaWVudEhlaWdodCA9IHRoaXMuc3RhdGUub3B0aW9ucy5yb3dzSGVpZ2h0OwogICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydEdyYXBoLnNjcm9sbEhlaWdodCAtIGNoYXJ0Q2xpZW50SGVpZ2h0OwoKICAgICAgICBpZiAodG9wIDwgMCkgewogICAgICAgICAgdG9wID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHRvcCA+IHNjcm9sbEhlaWdodCkgewogICAgICAgICAgdG9wID0gc2Nyb2xsSGVpZ2h0OwogICAgICAgIH0KCiAgICAgICAgdGhpcy5zY3JvbGxUbyhudWxsLCB0b3ApOwogICAgICB9IGVsc2UgaWYgKGV2LnNoaWZ0S2V5ICYmIGV2LmRlbHRhWCA9PT0gMCkgewogICAgICAgIGxldCBsZWZ0ID0gdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5sZWZ0ICsgZXYuZGVsdGFZOwogICAgICAgIGNvbnN0IGNoYXJ0Q2xpZW50V2lkdGggPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJIb3Jpem9udGFsLmNsaWVudFdpZHRoOwogICAgICAgIGNvbnN0IHNjcm9sbFdpZHRoID0gdGhpcy5zdGF0ZS5yZWZzLmNoYXJ0U2Nyb2xsQ29udGFpbmVySG9yaXpvbnRhbC5zY3JvbGxXaWR0aCAtIGNoYXJ0Q2xpZW50V2lkdGg7CgogICAgICAgIGlmIChsZWZ0IDwgMCkgewogICAgICAgICAgbGVmdCA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChsZWZ0ID4gc2Nyb2xsV2lkdGgpIHsKICAgICAgICAgIGxlZnQgPSBzY3JvbGxXaWR0aDsKICAgICAgICB9CgogICAgICAgIHRoaXMuc2Nyb2xsVG8obGVmdCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmxlZnQgKyBldi5kZWx0YVg7CiAgICAgICAgY29uc3QgY2hhcnRDbGllbnRXaWR0aCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydFNjcm9sbENvbnRhaW5lckhvcml6b250YWwuY2xpZW50V2lkdGg7CiAgICAgICAgY29uc3Qgc2Nyb2xsV2lkdGggPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJIb3Jpem9udGFsLnNjcm9sbFdpZHRoIC0gY2hhcnRDbGllbnRXaWR0aDsKCiAgICAgICAgaWYgKGxlZnQgPCAwKSB7CiAgICAgICAgICBsZWZ0ID0gMDsKICAgICAgICB9IGVsc2UgaWYgKGxlZnQgPiBzY3JvbGxXaWR0aCkgewogICAgICAgICAgbGVmdCA9IHNjcm9sbFdpZHRoOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5zY3JvbGxUbyhsZWZ0KTsKICAgICAgfQogICAgfSwKCiAgICAvKioKICAgICAqIFRpbWUgem9vbSBjaGFuZ2UgZXZlbnQgaGFuZGxlcgogICAgICovCiAgICBvblRpbWVab29tQ2hhbmdlKHRpbWVab29tKSB7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lWm9vbSA9IHRpbWVab29tOwogICAgICB0aGlzLnJlY2FsY3VsYXRlVGltZXMoKTsKICAgICAgdGhpcy5jYWxjdWxhdGVTdGVwcygpOwogICAgICB0aGlzLmZpeFNjcm9sbFBvcygpOwogICAgfSwKCiAgICAvKioKICAgICAqIFJvdyBoZWlnaHQgY2hhbmdlIGV2ZW50IGhhbmRsZXIKICAgICAqLwogICAgb25Sb3dIZWlnaHRDaGFuZ2UoaGVpZ2h0KSB7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0ID0gaGVpZ2h0OwogICAgICB0aGlzLmNhbGN1bGF0ZVRhc2tMaXN0Q29sdW1uc0RpbWVuc2lvbnMoKTsKICAgICAgdGhpcy5zeW5jU2Nyb2xsVG9wKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogU2NvcGUgY2hhbmdlIGV2ZW50IGhhbmRsZXIKICAgICAqLwogICAgb25TY29wZUNoYW5nZSh2YWx1ZSkgewogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2NvcGUuYmVmb3JlID0gdmFsdWU7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5zY29wZS5hZnRlciA9IHZhbHVlOwogICAgICB0aGlzLmluaXRUaW1lcygpOwogICAgICB0aGlzLmNhbGN1bGF0ZVN0ZXBzKCk7CiAgICAgIHRoaXMuY29tcHV0ZUNhbGVuZGFyV2lkdGhzKCk7CiAgICAgIHRoaXMuZml4U2Nyb2xsUG9zKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogVGFzayBsaXN0IHdpZHRoIGNoYW5nZSBldmVudCBoYW5kbGVyCiAgICAgKi8KICAgIG9uVGFza0xpc3RXaWR0aENoYW5nZSh2YWx1ZSkgewogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3QucGVyY2VudCA9IHZhbHVlOwogICAgICB0aGlzLmNhbGN1bGF0ZVRhc2tMaXN0Q29sdW1uc0RpbWVuc2lvbnMoKTsKICAgICAgdGhpcy5maXhTY3JvbGxQb3MoKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBUYXNrIGxpc3QgY29sdW1uIHdpZHRoIGNoYW5nZSBldmVudCBoYW5kbGVyCiAgICAgKi8KICAgIG9uVGFza0xpc3RDb2x1bW5XaWR0aENoYW5nZSgpIHsKICAgICAgdGhpcy5jYWxjdWxhdGVUYXNrTGlzdENvbHVtbnNEaW1lbnNpb25zKCk7CiAgICAgIHRoaXMuZml4U2Nyb2xsUG9zKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogTGlzdGVuIHRvIHNwZWNpZmllZCBldmVudCBuYW1lcwogICAgICovCiAgICBpbml0aWFsaXplRXZlbnRzKCkgewogICAgICB0aGlzLiRvbignY2hhcnQtc2Nyb2xsLWhvcml6b250YWwnLCB0aGlzLm9uU2Nyb2xsQ2hhcnQpOwogICAgICB0aGlzLiRvbignY2hhcnQtc2Nyb2xsLXZlcnRpY2FsJywgdGhpcy5vblNjcm9sbENoYXJ0KTsKICAgICAgdGhpcy4kb24oJ2NoYXJ0LXdoZWVsJywgdGhpcy5vbldoZWVsQ2hhcnQpOwogICAgICB0aGlzLiRvbigndGltZXMtdGltZVpvb20tY2hhbmdlJywgdGhpcy5vblRpbWVab29tQ2hhbmdlKTsKICAgICAgdGhpcy4kb24oJ3Jvdy1oZWlnaHQtY2hhbmdlJywgdGhpcy5vblJvd0hlaWdodENoYW5nZSk7CiAgICAgIHRoaXMuJG9uKCdzY29wZS1jaGFuZ2UnLCB0aGlzLm9uU2NvcGVDaGFuZ2UpOwogICAgICB0aGlzLiRvbigndGFza0xpc3Qtd2lkdGgtY2hhbmdlJywgdGhpcy5vblRhc2tMaXN0V2lkdGhDaGFuZ2UpOwogICAgICB0aGlzLiRvbigndGFza0xpc3QtY29sdW1uLXdpZHRoLWNoYW5nZScsIHRoaXMub25UYXNrTGlzdENvbHVtbldpZHRoQ2hhbmdlKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBXaGVuIHNvbWUgYWN0aW9uIHdhcyBwZXJmb3JtZWQgKHNjYWxlIGNoYW5nZSBmb3IgZXhhbXBsZSkgLSByZWNhbGN1bGF0ZSB0aW1lIHZhcmlhYmxlcwogICAgICovCiAgICByZWNhbGN1bGF0ZVRpbWVzKCkgewogICAgICBsZXQgbWF4ID0gdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRpbWVTY2FsZSAqIDYwOwogICAgICBsZXQgbWluID0gdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRpbWVTY2FsZTsKICAgICAgbGV0IHN0ZXBzID0gbWF4IC8gbWluOwogICAgICBsZXQgcGVyY2VudCA9IHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lWm9vbSAvIDEwMDsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRpbWVQZXJQaXhlbCA9IHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lU2NhbGUgKiBzdGVwcyAqIHBlcmNlbnQgKyBNYXRoLnBvdygyLCB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVpvb20pOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudG90YWxWaWV3RHVyYXRpb25NcyA9IGRheWpzKHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5sYXN0VGltZSkuZGlmZih0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuZmlyc3RUaW1lLCAnbWlsbGlzZWNvbmRzJyk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50b3RhbFZpZXdEdXJhdGlvblB4ID0gdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRvdGFsVmlld0R1cmF0aW9uTXMgLyB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVBlclBpeGVsOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMud2lkdGggPSB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudG90YWxWaWV3RHVyYXRpb25QeCArIHRoaXMuc3R5bGVbJ2dyaWQtbGluZS12ZXJ0aWNhbCddWydzdHJva2Utd2lkdGgnXTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBJbml0aWFsaXplIHRpbWUgdmFyaWFibGVzCiAgICAgKi8KICAgIGluaXRUaW1lcygpIHsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSA9IGRheWpzKHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRhc2tUaW1lKS5sb2NhbGUodGhpcy5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lKS5zdGFydE9mKCdkYXknKS5zdWJ0cmFjdCh0aGlzLnN0YXRlLm9wdGlvbnMuc2NvcGUuYmVmb3JlLCAnZGF5cycpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lID0gZGF5anModGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUYXNrVGltZSkubG9jYWxlKHRoaXMuc3RhdGUub3B0aW9ucy5sb2NhbGUubmFtZSkuZW5kT2YoJ2RheScpLmFkZCh0aGlzLnN0YXRlLm9wdGlvbnMuc2NvcGUuYWZ0ZXIsICdkYXlzJykuZW5kT2YoJ2RheScpLnZhbHVlT2YoKTsKICAgICAgdGhpcy5yZWNhbGN1bGF0ZVRpbWVzKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogQ2FsY3VsYXRlIHN0ZXBzCiAgICAgKiBTdGVwcyBhcmUgZGF5cyBieSBkZWZhdWx0CiAgICAgKiBFYWNoIHN0ZXAgY29udGFpbiBpbmZvcm1hdGlvbiBhYm91dCB0aW1lIG9mZnNldCBhbmQgcGl4ZWwgb2Zmc2V0IG9mIHRoaXMgdGltZSBpbnNpZGUgZ2FudHQgY2hhcnQKICAgICAqLwogICAgY2FsY3VsYXRlU3RlcHMoKSB7CiAgICAgIGNvbnN0IHN0ZXBzID0gW107CiAgICAgIGNvbnN0IGxhc3RNcyA9IGRheWpzKHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5sYXN0VGltZSkudmFsdWVPZigpOwogICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IGRheWpzKHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRpbWUpOwogICAgICBzdGVwcy5wdXNoKHsKICAgICAgICB0aW1lOiBjdXJyZW50RGF0ZS52YWx1ZU9mKCksCiAgICAgICAgb2Zmc2V0OiB7CiAgICAgICAgICBtczogMCwKICAgICAgICAgIHB4OiAwCiAgICAgICAgfQogICAgICB9KTsKCiAgICAgIGZvciAobGV0IGN1cnJlbnREYXRlID0gZGF5anModGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSkuYWRkKDEsIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwRHVyYXRpb24pLnN0YXJ0T2YoJ2RheScpOyBjdXJyZW50RGF0ZS52YWx1ZU9mKCkgPD0gbGFzdE1zOyBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlLmFkZCgxLCB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcER1cmF0aW9uKS5zdGFydE9mKCdkYXknKSkgewogICAgICAgIGNvbnN0IG9mZnNldE1zID0gY3VycmVudERhdGUuZGlmZih0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuZmlyc3RUaW1lLCAnbWlsbGlzZWNvbmRzJyk7CiAgICAgICAgY29uc3Qgb2Zmc2V0UHggPSBvZmZzZXRNcyAvIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lUGVyUGl4ZWw7CiAgICAgICAgY29uc3Qgc3RlcCA9IHsKICAgICAgICAgIHRpbWU6IGN1cnJlbnREYXRlLnZhbHVlT2YoKSwKICAgICAgICAgIG9mZnNldDogewogICAgICAgICAgICBtczogb2Zmc2V0TXMsCiAgICAgICAgICAgIHB4OiBvZmZzZXRQeAogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgY29uc3QgcHJldmlvdXNTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07CiAgICAgICAgcHJldmlvdXNTdGVwLndpZHRoID0gewogICAgICAgICAgbXM6IG9mZnNldE1zIC0gcHJldmlvdXNTdGVwLm9mZnNldC5tcywKICAgICAgICAgIHB4OiBvZmZzZXRQeCAtIHByZXZpb3VzU3RlcC5vZmZzZXQucHgKICAgICAgICB9OwogICAgICAgIHN0ZXBzLnB1c2goc3RlcCk7CiAgICAgIH0KCiAgICAgIGNvbnN0IGxhc3RTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07CiAgICAgIGxhc3RTdGVwLndpZHRoID0gewogICAgICAgIG1zOiB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudG90YWxWaWV3RHVyYXRpb25NcyAtIGxhc3RTdGVwLm9mZnNldC5tcywKICAgICAgICBweDogdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRvdGFsVmlld0R1cmF0aW9uUHggLSBsYXN0U3RlcC5vZmZzZXQucHgKICAgICAgfTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBzID0gc3RlcHM7CiAgICB9LAoKICAgIC8qKgogICAgICogQ2FsY3VsYXRlIGNhbGVuZGFyIHdpZHRocyAtIHdoZW4gc2NhbGUgd2FzIGNoYW5nZWQgZm9yIGV4YW1wbGUKICAgICAqLwogICAgY29tcHV0ZUNhbGVuZGFyV2lkdGhzKCkgewogICAgICB0aGlzLmNvbXB1dGVEYXlXaWR0aHMoKTsKICAgICAgdGhpcy5jb21wdXRlSG91cldpZHRocygpOwogICAgICB0aGlzLmNvbXB1dGVNb250aFdpZHRocygpOwogICAgfSwKCiAgICAvKioKICAgICAqIENvbXB1dGUgd2lkdGggb2YgY2FsZW5kYXIgaG91cnMgY29sdW1uIHdpZHRocyBiYXNpbmcgb24gdGV4dCB3aWR0aHMKICAgICAqLwogICAgY29tcHV0ZUhvdXJXaWR0aHMoKSB7CiAgICAgIGNvbnN0IHN0eWxlID0geyAuLi50aGlzLnN0eWxlWydjYWxlbmRhci1yb3ctdGV4dCddLAogICAgICAgIC4uLnRoaXMuc3R5bGVbJ2NhbGVuZGFyLXJvdy10ZXh0LS1ob3VyJ10KICAgICAgfTsKICAgICAgdGhpcy5zdGF0ZS5jdHguZm9udCA9IHN0eWxlWydmb250LXNpemUnXSArICcgJyArIHN0eWxlWydmb250LWZhbWlseSddOwogICAgICBjb25zdCBsb2NhbGVOYW1lID0gdGhpcy5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lOwogICAgICBsZXQgY3VycmVudERhdGUgPSBkYXlqcygnMjAxOC0wMS0wMVQwMDowMDowMCcpLmxvY2FsZShsb2NhbGVOYW1lKTsgLy8gYW55IGRhdGUgd2lsbCBiZSBnb29kIGZvciBob3VycwoKICAgICAgbGV0IG1heFdpZHRocyA9IHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLm1heFdpZHRoczsKCiAgICAgIGlmIChtYXhXaWR0aHMubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBmb3IgKGxldCBmb3JtYXROYW1lIGluIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLmZvcm1hdCkgewogICAgICAgIG1heFdpZHRoc1tmb3JtYXROYW1lXSA9IDA7CiAgICAgIH0KCiAgICAgIGZvciAobGV0IGhvdXIgPSAwOyBob3VyIDwgMjQ7IGhvdXIrKykgewogICAgICAgIGxldCB3aWR0aHMgPSB7CiAgICAgICAgICBob3VyCiAgICAgICAgfTsKCiAgICAgICAgZm9yIChsZXQgZm9ybWF0TmFtZSBpbiB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5mb3JtYXQpIHsKICAgICAgICAgIGNvbnN0IGhvdXJGb3JtYXR0ZWQgPSB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5mb3JtYXRbZm9ybWF0TmFtZV0oY3VycmVudERhdGUpOwogICAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuZm9ybWF0dGVkW2Zvcm1hdE5hbWVdLnB1c2goaG91ckZvcm1hdHRlZCk7CiAgICAgICAgICB3aWR0aHNbZm9ybWF0TmFtZV0gPSB0aGlzLnN0YXRlLmN0eC5tZWFzdXJlVGV4dChob3VyRm9ybWF0dGVkKS53aWR0aDsKICAgICAgICB9CgogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLndpZHRocy5wdXNoKHdpZHRocyk7CgogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgaW4gdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuZm9ybWF0KSB7CiAgICAgICAgICBpZiAod2lkdGhzW2Zvcm1hdE5hbWVdID4gbWF4V2lkdGhzW2Zvcm1hdE5hbWVdKSB7CiAgICAgICAgICAgIG1heFdpZHRoc1tmb3JtYXROYW1lXSA9IHdpZHRoc1tmb3JtYXROYW1lXTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGUuYWRkKDEsICdob3VyJyk7CiAgICAgIH0KICAgIH0sCgogICAgLyoqCiAgICAgKiBDb21wdXRlIGNhbGVuZGFyIGRheXMgY29sdW1uIHdpZHRocyBiYXNpbmcgb24gdGV4dCB3aWR0aHMKICAgICAqLwogICAgY29tcHV0ZURheVdpZHRocygpIHsKICAgICAgY29uc3Qgc3R5bGUgPSB7IC4uLnRoaXMuc3R5bGVbJ2NhbGVuZGFyLXJvdy10ZXh0J10sCiAgICAgICAgLi4udGhpcy5zdHlsZVsnY2FsZW5kYXItcm93LXRleHQtLWRheSddCiAgICAgIH07CiAgICAgIHRoaXMuc3RhdGUuY3R4LmZvbnQgPSBzdHlsZVsnZm9udC1zaXplJ10gKyAnICcgKyBzdHlsZVsnZm9udC1mYW1pbHknXTsKICAgICAgY29uc3QgbG9jYWxlTmFtZSA9IHRoaXMuc3RhdGUub3B0aW9ucy5sb2NhbGUubmFtZTsKICAgICAgbGV0IGN1cnJlbnREYXRlID0gZGF5anModGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBzWzBdLnRpbWUpLmxvY2FsZShsb2NhbGVOYW1lKTsKICAgICAgbGV0IG1heFdpZHRocyA9IHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkubWF4V2lkdGhzOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LndpZHRocyA9IFtdOwogICAgICBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LmZvcm1hdCkuZm9yRWFjaChmb3JtYXROYW1lID0+IHsKICAgICAgICBtYXhXaWR0aHNbZm9ybWF0TmFtZV0gPSAwOwogICAgICB9KTsKCiAgICAgIGZvciAobGV0IGRheSA9IDAsIGRheXNMZW4gPSB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcHMubGVuZ3RoOyBkYXkgPCBkYXlzTGVuOyBkYXkrKykgewogICAgICAgIGNvbnN0IHdpZHRocyA9IHsKICAgICAgICAgIGRheQogICAgICAgIH07CiAgICAgICAgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5mb3JtYXQpLmZvckVhY2goZm9ybWF0TmFtZSA9PiB7CiAgICAgICAgICB3aWR0aHNbZm9ybWF0TmFtZV0gPSB0aGlzLnN0YXRlLmN0eC5tZWFzdXJlVGV4dCh0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LmZvcm1hdFtmb3JtYXROYW1lXShjdXJyZW50RGF0ZSkpLndpZHRoOwogICAgICAgIH0pOwogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkud2lkdGhzLnB1c2god2lkdGhzKTsKICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LmZvcm1hdCkuZm9yRWFjaChmb3JtYXROYW1lID0+IHsKICAgICAgICAgIGlmICh3aWR0aHNbZm9ybWF0TmFtZV0gPiBtYXhXaWR0aHNbZm9ybWF0TmFtZV0pIHsKICAgICAgICAgICAgbWF4V2lkdGhzW2Zvcm1hdE5hbWVdID0gd2lkdGhzW2Zvcm1hdE5hbWVdOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGUuYWRkKDEsICdkYXknKTsKICAgICAgfQogICAgfSwKCiAgICAvKioKICAgICAqIE1vbnRocyBjb3VudAogICAgICoKICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIG51bWJlciBvZiBkaWZmZXJlbnQgbW9udGhzIGluIHNwZWNpZmllZCB0aW1lIHJhbmdlCiAgICAgKgogICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21UaW1lIC0gZGF0ZSBpbiBtcwogICAgICogQHBhcmFtIHtudW1iZXJ9IHRvVGltZSAtIGRhdGUgaW4gbXMKICAgICAqCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBkaWZmZXJlbnQgbW9udGhzIGNvdW50CiAgICAgKi8KICAgIG1vbnRoc0NvdW50KGZyb21UaW1lLCB0b1RpbWUpIHsKICAgICAgaWYgKGZyb21UaW1lID4gdG9UaW1lKSB7CiAgICAgICAgcmV0dXJuIDA7CiAgICAgIH0KCiAgICAgIGxldCBjdXJyZW50TW9udGggPSBkYXlqcyhmcm9tVGltZSk7CiAgICAgIGxldCBwcmV2aW91c01vbnRoID0gY3VycmVudE1vbnRoLmNsb25lKCk7CiAgICAgIGxldCBtb250aHNDb3VudCA9IDE7CgogICAgICB3aGlsZSAoY3VycmVudE1vbnRoLnZhbHVlT2YoKSA8PSB0b1RpbWUpIHsKICAgICAgICBjdXJyZW50TW9udGggPSBjdXJyZW50TW9udGguYWRkKDEsICdkYXknKTsKCiAgICAgICAgaWYgKHByZXZpb3VzTW9udGgubW9udGgoKSAhPT0gY3VycmVudE1vbnRoLm1vbnRoKCkpIHsKICAgICAgICAgIG1vbnRoc0NvdW50Kys7CiAgICAgICAgfQoKICAgICAgICBwcmV2aW91c01vbnRoID0gY3VycmVudE1vbnRoLmNsb25lKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBtb250aHNDb3VudDsKICAgIH0sCgogICAgLyoqCiAgICAgKiBDb21wdXRlIG1vbnRoIGNhbGVuZGFyIGNvbHVtbnMgd2lkdGhzIGJhc2luZyBvbiB0ZXh0IHdpZHRocwogICAgICovCiAgICBjb21wdXRlTW9udGhXaWR0aHMoKSB7CiAgICAgIGNvbnN0IHN0eWxlID0geyAuLi50aGlzLnN0eWxlWydjYWxlbmRhci1yb3ctdGV4dCddLAogICAgICAgIC4uLnRoaXMuc3R5bGVbJ2NhbGVuZGFyLXJvdy10ZXh0LS1tb250aCddCiAgICAgIH07CiAgICAgIHRoaXMuc3RhdGUuY3R4LmZvbnQgPSBzdHlsZVsnZm9udC1zaXplJ10gKyAnICcgKyBzdHlsZVsnZm9udC1mYW1pbHknXTsKICAgICAgbGV0IG1heFdpZHRocyA9IHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5tYXhXaWR0aHM7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC53aWR0aHMgPSBbXTsKICAgICAgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmZvcm1hdCkuZm9yRWFjaChmb3JtYXROYW1lID0+IHsKICAgICAgICBtYXhXaWR0aHNbZm9ybWF0TmFtZV0gPSAwOwogICAgICB9KTsKICAgICAgY29uc3QgbG9jYWxlTmFtZSA9IHRoaXMuc3RhdGUub3B0aW9ucy5sb2NhbGUubmFtZTsKICAgICAgbGV0IGN1cnJlbnREYXRlID0gZGF5anModGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSkubG9jYWxlKGxvY2FsZU5hbWUpOwogICAgICBjb25zdCBtb250aHNDb3VudCA9IHRoaXMubW9udGhzQ291bnQodGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSwgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lKTsKCiAgICAgIGZvciAobGV0IG1vbnRoID0gMDsgbW9udGggPCBtb250aHNDb3VudDsgbW9udGgrKykgewogICAgICAgIGNvbnN0IHdpZHRocyA9IHsKICAgICAgICAgIG1vbnRoCiAgICAgICAgfTsKICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGguZm9ybWF0KS5mb3JFYWNoKGZvcm1hdE5hbWUgPT4gewogICAgICAgICAgd2lkdGhzW2Zvcm1hdE5hbWVdID0gdGhpcy5zdGF0ZS5jdHgubWVhc3VyZVRleHQodGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmZvcm1hdFtmb3JtYXROYW1lXShjdXJyZW50RGF0ZSkpLndpZHRoOwogICAgICAgIH0pOwogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC53aWR0aHMucHVzaCh3aWR0aHMpOwogICAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5mb3JtYXQpLmZvckVhY2goZm9ybWF0TmFtZSA9PiB7CiAgICAgICAgICBpZiAod2lkdGhzW2Zvcm1hdE5hbWVdID4gbWF4V2lkdGhzW2Zvcm1hdE5hbWVdKSB7CiAgICAgICAgICAgIG1heFdpZHRoc1tmb3JtYXROYW1lXSA9IHdpZHRoc1tmb3JtYXROYW1lXTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlLmFkZCgxLCAnbW9udGgnKTsKICAgICAgfQogICAgfSwKCiAgICAvKioKICAgICAqIFByZXBhcmUgdGltZSBhbmQgZGF0ZSB2YXJpYWJsZXMgZm9yIGdhbnR0CiAgICAgKi8KICAgIHByZXBhcmVEYXRlcygpIHsKICAgICAgbGV0IGZpcnN0VGFza1RpbWUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjsKICAgICAgbGV0IGxhc3RUYXNrVGltZSA9IDA7CgogICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbiA9IHRoaXMuc3RhdGUudGFza3MubGVuZ3RoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykgewogICAgICAgIGxldCB0YXNrID0gdGhpcy5zdGF0ZS50YXNrc1tpbmRleF07CgogICAgICAgIGlmICh0YXNrLnN0YXJ0VGltZSA8IGZpcnN0VGFza1RpbWUpIHsKICAgICAgICAgIGZpcnN0VGFza1RpbWUgPSB0YXNrLnN0YXJ0VGltZTsKICAgICAgICB9CgogICAgICAgIGlmICh0YXNrLnN0YXJ0VGltZSArIHRhc2suZHVyYXRpb24gPiBsYXN0VGFza1RpbWUpIHsKICAgICAgICAgIGxhc3RUYXNrVGltZSA9IHRhc2suc3RhcnRUaW1lICsgdGFzay5kdXJhdGlvbjsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRhc2tUaW1lID0gZmlyc3RUYXNrVGltZTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUYXNrVGltZSA9IGxhc3RUYXNrVGltZTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSA9IGRheWpzKGZpcnN0VGFza1RpbWUpLmxvY2FsZSh0aGlzLnN0YXRlLm9wdGlvbnMubG9jYWxlLm5hbWUpLnN0YXJ0T2YoJ2RheScpLnN1YnRyYWN0KHRoaXMuc3RhdGUub3B0aW9ucy5zY29wZS5iZWZvcmUsICdkYXlzJykuc3RhcnRPZignZGF5JykudmFsdWVPZigpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWUgPSBkYXlqcyhsYXN0VGFza1RpbWUpLmxvY2FsZSh0aGlzLnN0YXRlLm9wdGlvbnMubG9jYWxlLm5hbWUpLmVuZE9mKCdkYXknKS5hZGQodGhpcy5zdGF0ZS5vcHRpb25zLnNjb3BlLmFmdGVyLCAnZGF5cycpLmVuZE9mKCdkYXknKS52YWx1ZU9mKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogU2V0dXAgYW5kIGNhbGN1bGF0ZSBldmVyeXRoaW5nCiAgICAgKi8KICAgIHNldHVwKGl0c1VwZGF0ZSA9ICcnKSB7CiAgICAgIHRoaXMuaW5pdGlhbGl6ZShpdHNVcGRhdGUpOwogICAgICB0aGlzLnByZXBhcmVEYXRlcygpOwogICAgICB0aGlzLmluaXRUaW1lcygpOwogICAgICB0aGlzLmNhbGN1bGF0ZVN0ZXBzKCk7CiAgICAgIHRoaXMuY29tcHV0ZUNhbGVuZGFyV2lkdGhzKCk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC53aWR0aCA9IHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4gewogICAgICAgIHJldHVybiB7CiAgICAgICAgICB3aWR0aDogcHJldi53aWR0aCArIGN1cnJlbnQud2lkdGgKICAgICAgICB9OwogICAgICB9LCB7CiAgICAgICAgd2lkdGg6IDAKICAgICAgfSkud2lkdGg7CiAgICB9LAoKICAgIC8qKgogICAgICogR2xvYmFsIHJlc2l6ZSBldmVudCAoZnJvbSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikKICAgICAqLwogICAgZ2xvYmFsT25SZXNpemUoKSB7CiAgICAgIGlmICh0eXBlb2YgdGhpcy4kZWwgPT09ICd1bmRlZmluZWQnIHx8ICF0aGlzLiRlbCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLmNsaWVudFdpZHRoID0gdGhpcy4kZWwuY2xpZW50V2lkdGg7CgogICAgICBpZiAodGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LndpZHRoRnJvbVBlcmNlbnRhZ2UgPiB0aGlzLnN0YXRlLm9wdGlvbnMuY2xpZW50V2lkdGggLyAxMDAgKiB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3Qud2lkdGhUaHJlc2hvbGQpIHsKICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LndpZHRoRnJvbVBlcmNlbnRhZ2UgLSB0aGlzLnN0YXRlLm9wdGlvbnMuY2xpZW50V2lkdGggLyAxMDAgKiB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3Qud2lkdGhUaHJlc2hvbGQ7CiAgICAgICAgbGV0IGRpZmZQZXJjZW50ID0gMTAwIC0gZGlmZiAvIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC53aWR0aEZyb21QZXJjZW50YWdlICogMTAwOwoKICAgICAgICBpZiAoZGlmZlBlcmNlbnQgPCAwKSB7CiAgICAgICAgICBkaWZmUGVyY2VudCA9IDA7CiAgICAgICAgfQoKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3QuY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7CiAgICAgICAgICBjb2x1bW4udGhyZXNob2xkUGVyY2VudCA9IGRpZmZQZXJjZW50OwogICAgICAgIH0pOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHsKICAgICAgICAgIGNvbHVtbi50aHJlc2hvbGRQZXJjZW50ID0gMTAwOwogICAgICAgIH0pOwogICAgICB9CgogICAgICB0aGlzLmNhbGN1bGF0ZVRhc2tMaXN0Q29sdW1uc0RpbWVuc2lvbnMoKTsKICAgICAgdGhpcy4kZW1pdCgnY2FsZW5kYXItcmVjYWxjdWxhdGUnKTsKICAgICAgdGhpcy5zeW5jU2Nyb2xsVG9wKCk7CiAgICB9CgogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIC8qKgogICAgICogR2V0IHZpc2libGUgdGFza3MKICAgICAqIFZlcnkgaW1wb3J0YW50IG1ldGhvZCB3aGljaCB3aWxsIGJyaW5nIHVzIG9ubHkgdGhvc2UgdGFza3MgdGhhdCBhcmUgdmlzaWJsZSBpbnNpZGUgZ2FudHQgY2hhcnQKICAgICAqIEZvciBleGFtcGxlIHdoZW4gdGFzayBpcyBjb2xsYXBzZWQgLSBjaGlsZHJlbiBvZiB0aGlzIHRhc2sgYXJlIG5vdCB2aXNpYmxlIC0gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlbQogICAgICovCiAgICB2aXNpYmxlVGFza3MoKSB7CiAgICAgIGNvbnN0IHZpc2libGVUYXNrcyA9IHRoaXMuc3RhdGUudGFza3MuZmlsdGVyKHRhc2sgPT4gdGhpcy5pc1Rhc2tWaXNpYmxlKHRhc2spKTsKICAgICAgY29uc3QgbWF4Um93cyA9IHZpc2libGVUYXNrcy5zbGljZSgwLCB0aGlzLnN0YXRlLm9wdGlvbnMubWF4Um93cyk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5yb3dzSGVpZ2h0ID0gdGhpcy5nZXRUYXNrc0hlaWdodChtYXhSb3dzKTsKICAgICAgbGV0IGhlaWdodENvbXBlbnNhdGlvbiA9IDA7CgogICAgICBpZiAodGhpcy5zdGF0ZS5vcHRpb25zLm1heEhlaWdodCAmJiB0aGlzLnN0YXRlLm9wdGlvbnMucm93c0hlaWdodCA+IHRoaXMuc3RhdGUub3B0aW9ucy5tYXhIZWlnaHQpIHsKICAgICAgICBoZWlnaHRDb21wZW5zYXRpb24gPSB0aGlzLnN0YXRlLm9wdGlvbnMucm93c0hlaWdodCAtIHRoaXMuc3RhdGUub3B0aW9ucy5tYXhIZWlnaHQ7CiAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnJvd3NIZWlnaHQgPSB0aGlzLnN0YXRlLm9wdGlvbnMubWF4SGVpZ2h0OwogICAgICB9CgogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQobWF4Um93cykgLSBoZWlnaHRDb21wZW5zYXRpb247CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5hbGxWaXNpYmxlVGFza3NIZWlnaHQgPSB0aGlzLmdldFRhc2tzSGVpZ2h0KHZpc2libGVUYXNrcyk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5vdXRlckhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KG1heFJvd3MsIHRydWUpIC0gaGVpZ2h0Q29tcGVuc2F0aW9uOwogICAgICBsZXQgbGVuID0gdmlzaWJsZVRhc2tzLmxlbmd0aDsKCiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHsKICAgICAgICBsZXQgdGFzayA9IHZpc2libGVUYXNrc1tpbmRleF07CiAgICAgICAgdGFzay53aWR0aCA9IHRhc2suZHVyYXRpb24gLyB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVBlclBpeGVsIC0gdGhpcy5zdHlsZVsnZ3JpZC1saW5lLXZlcnRpY2FsJ11bJ3N0cm9rZS13aWR0aCddOwoKICAgICAgICBpZiAodGFzay53aWR0aCA8IDApIHsKICAgICAgICAgIHRhc2sud2lkdGggPSAwOwogICAgICAgIH0KCiAgICAgICAgdGFzay5oZWlnaHQgPSB0aGlzLnN0YXRlLm9wdGlvbnMucm93LmhlaWdodDsKICAgICAgICB0YXNrLnggPSB0aGlzLnRpbWVUb1BpeGVsT2Zmc2V0WCh0YXNrLnN0YXJ0VGltZSk7CiAgICAgICAgdGFzay55ID0gKHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0ICsgdGhpcy5zdGF0ZS5vcHRpb25zLmNoYXJ0LmdyaWQuaG9yaXpvbnRhbC5nYXAgKiAyKSAqIGluZGV4ICsgdGhpcy5zdGF0ZS5vcHRpb25zLmNoYXJ0LmdyaWQuaG9yaXpvbnRhbC5nYXA7CiAgICAgIH0KCiAgICAgIHJldHVybiB2aXNpYmxlVGFza3M7CiAgICB9LAoKICAgIC8qKgogICAgICogU3R5bGUgc2hvcnRjdXQKICAgICAqLwogICAgc3R5bGUoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmR5bmFtaWNTdHlsZTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgY29sdW1ucyBhbmQgY29tcHV0ZSBkaW1lbnNpb25zIG9uIHRoZSBmbHkKICAgICAqLwogICAgZ2V0VGFza0xpc3RDb2x1bW5zKCkgewogICAgICB0aGlzLmNhbGN1bGF0ZVRhc2tMaXN0Q29sdW1uc0RpbWVuc2lvbnMoKTsKICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zOwogICAgfSwKCiAgICAvKioKICAgICAqIFRhc2tzIHVzZWQgZm9yIGNvbW11bmljYXRlIHdpdGggcGFyZW50IGNvbXBvbmVudAogICAgICovCiAgICBvdXRwdXRUYXNrcygpIHsKICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudGFza3M7CiAgICB9LAoKICAgIC8qKgogICAgICogT3B0aW9ucyB1c2VkIHRvIGNvbW11bmljYXRlIHdpdGggcGFyZW50IGNvbXBvbmVudAogICAgICovCiAgICBvdXRwdXRPcHRpb25zKCkgewogICAgICByZXR1cm4gdGhpcy5zdGF0ZS5vcHRpb25zOwogICAgfQoKICB9LAoKICAvKioKICAgKiBXYXRjaCB0YXNrcyBhZnRlciBnYW50dCBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZWFjdCB3aGVuIHdlIGhhdmUgbmV3IGtpZHMgb24gdGhlIGJsb2NrCiAgICovCiAgY3JlYXRlZCgpIHsKICAgIHRoaXMuaW5pdGlhbGl6ZUV2ZW50cygpOwogICAgdGhpcy5zZXR1cCgpOwogICAgdGhpcy5zdGF0ZS51bndhdGNoVGFza3MgPSB0aGlzLiR3YXRjaCgndGFza3MnLCB0YXNrcyA9PiB7CiAgICAgIGNvbnN0IG5vdEVxdWFsID0gbm90RXF1YWxEZWVwKHRhc2tzLCB0aGlzLm91dHB1dFRhc2tzKTsKCiAgICAgIGlmIChub3RFcXVhbCkgewogICAgICAgIHRoaXMuc2V0dXAoJ3Rhc2tzJyk7CiAgICAgIH0KICAgIH0sIHsKICAgICAgZGVlcDogdHJ1ZQogICAgfSk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hPcHRpb25zID0gdGhpcy4kd2F0Y2goJ29wdGlvbnMnLCBvcHRzID0+IHsKICAgICAgY29uc3Qgbm90RXF1YWwgPSBub3RFcXVhbERlZXAob3B0cywgdGhpcy5vdXRwdXRPcHRpb25zKTsKCiAgICAgIGlmIChub3RFcXVhbCkgewogICAgICAgIHRoaXMuc2V0dXAoJ29wdGlvbnMnKTsKICAgICAgfQogICAgfSwgewogICAgICBkZWVwOiB0cnVlCiAgICB9KTsKICAgIHRoaXMuc3RhdGUudW53YXRjaFN0eWxlID0gdGhpcy4kd2F0Y2goJ2R5bmFtaWNTdHlsZScsIHN0eWxlID0+IHsKICAgICAgY29uc3Qgbm90RXF1YWwgPSBub3RFcXVhbERlZXAoc3R5bGUsIHRoaXMuZHluYW1pY1N0eWxlKTsKCiAgICAgIGlmIChub3RFcXVhbCkgewogICAgICAgIHRoaXMuaW5pdGlhbGl6ZVN0eWxlKCk7CiAgICAgIH0KICAgIH0sIHsKICAgICAgZGVlcDogdHJ1ZSwKICAgICAgaW1tZWRpYXRlOiB0cnVlCiAgICB9KTsKICAgIHRoaXMuc3RhdGUudW53YXRjaE91dHB1dFRhc2tzID0gdGhpcy4kd2F0Y2goJ291dHB1dFRhc2tzJywgdGFza3MgPT4gewogICAgICB0aGlzLiRlbWl0KCd0YXNrcy1jaGFuZ2VkJywgdGFza3MubWFwKHRhc2sgPT4gdGFzaykpOwogICAgfSwgewogICAgICBkZWVwOiB0cnVlCiAgICB9KTsKICAgIHRoaXMuc3RhdGUudW53YXRjaE91dHB1dE9wdGlvbnMgPSB0aGlzLiR3YXRjaCgnb3V0cHV0T3B0aW9ucycsIG9wdGlvbnMgPT4gewogICAgICB0aGlzLiRlbWl0KCdvcHRpb25zLWNoYW5nZWQnLCBtZXJnZURlZXAoe30sIG9wdGlvbnMpKTsKICAgIH0sIHsKICAgICAgZGVlcDogdHJ1ZQogICAgfSk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hPdXRwdXRTdHlsZSA9IHRoaXMuJHdhdGNoKCdzdHlsZScsIHN0eWxlID0+IHsKICAgICAgdGhpcy4kZW1pdCgnZHluYW1pYy1zdHlsZS1jaGFuZ2VkJywgbWVyZ2VEZWVwKHt9LCBzdHlsZSkpOwogICAgfSwgewogICAgICBkZWVwOiB0cnVlCiAgICB9KTsKICAgIHRoaXMuJHJvb3QuJGVtaXQoJ2dhbnR0LWVsYXN0aWMtY3JlYXRlZCcsIHRoaXMpOwogICAgdGhpcy4kZW1pdCgnY3JlYXRlZCcsIHRoaXMpOwogIH0sCgogIC8qKgogICAqIEVtaXQgYmVmb3JlLW1vdW50IGV2ZW50CiAgICovCiAgYmVmb3JlTW91bnQoKSB7CiAgICB0aGlzLiRlbWl0KCdiZWZvcmUtbW91bnQnLCB0aGlzKTsKICB9LAoKICAvKioKICAgKiBFbWl0IHJlYWR5L21vdW50ZWQgZXZlbnRzIGFuZCBkZWxpdmVyIHRoaXMgZ2FudHQgaW5zdGFuY2UgdG8gb3V0c2lkZSB3b3JsZCB3aGVuIG5lZWRlZAogICAqLwogIG1vdW50ZWQoKSB7CiAgICB0aGlzLnN0YXRlLm9wdGlvbnMuY2xpZW50V2lkdGggPSB0aGlzLiRlbC5jbGllbnRXaWR0aDsKICAgIHRoaXMuc3RhdGUucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7CiAgICAgIHRoaXMuZ2xvYmFsT25SZXNpemUoKTsKICAgIH0pOwogICAgdGhpcy5zdGF0ZS5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsLnBhcmVudE5vZGUpOwogICAgdGhpcy5nbG9iYWxPblJlc2l6ZSgpOwogICAgdGhpcy4kZW1pdCgncmVhZHknLCB0aGlzKTsKICAgIHRoaXMuJHJvb3QuJGVtaXQoJ2dhbnR0LWVsYXN0aWMtbW91bnRlZCcsIHRoaXMpOwogICAgdGhpcy4kZW1pdCgnbW91bnRlZCcsIHRoaXMpOwogICAgdGhpcy4kcm9vdC4kZW1pdCgnZ2FudHQtZWxhc3RpYy1yZWFkeScsIHRoaXMpOwogIH0sCgogIC8qKgogICAqIEVtaXQgZXZlbnQgd2hlbiBkYXRhIHdhcyBjaGFuZ2VkIGFuZCBiZWZvcmUgdXBkYXRlICh5b3UgY2FuIGNsZWFudXAgZG9tIGV2ZW50cyBoZXJlIGZvciBleGFtcGxlKQogICAqLwogIGJlZm9yZVVwZGF0ZSgpIHsKICAgIHRoaXMuJGVtaXQoJ2JlZm9yZS11cGRhdGUnKTsKICB9LAoKICAvKioKICAgKiBFbWl0IGV2ZW50IHdoZW4gZ2FudHQtZWxhc3RpYyB2aWV3IHdhcyB1cGRhdGVkCiAgICovCiAgdXBkYXRlZCgpIHsKICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgdGhpcy4kZW1pdCgndXBkYXRlZCcpOwogICAgfSk7CiAgfSwKCiAgLyoqCiAgICogQmVmb3JlIGRlc3Ryb3kgZXZlbnQgLSBjbGVhbiB1cAogICAqLwogIGJlZm9yZURlc3Ryb3koKSB7CiAgICB0aGlzLnN0YXRlLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLiRlbC5wYXJlbnROb2RlKTsKICAgIHRoaXMuc3RhdGUudW53YXRjaFRhc2tzKCk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hPcHRpb25zKCk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hTdHlsZSgpOwogICAgdGhpcy5zdGF0ZS51bndhdGNoT3V0cHV0VGFza3MoKTsKICAgIHRoaXMuc3RhdGUudW53YXRjaE91dHB1dE9wdGlvbnMoKTsKICAgIHRoaXMuc3RhdGUudW53YXRjaE91dHB1dFN0eWxlKCk7CiAgICB0aGlzLiRlbWl0KCdiZWZvcmUtZGVzdHJveScpOwogIH0sCgogIC8qKgogICAqIEVtaXQgZXZlbnQgYWZ0ZXIgZ2FudHQtZWxhc3RpYyB3YXMgZGVzdHJveWVkCiAgICovCiAgZGVzdHJveWVkKCkgewogICAgdGhpcy4kZW1pdCgnZGVzdHJveWVkJyk7CiAgfQoKfTsKZXhwb3J0IGRlZmF1bHQgR2FudHRFbGFzdGljOw=="},{"version":3,"mappings":";AAiBA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;EACA;IACAA;EACA;AACA;;AACAC;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;EACA;;EACA;IACAC;EACA;;EACA;IACAC;MACAC;IADA,CADA;IAIAC;MACA;MACAC,QAFA;MAGAC,cAHA;MAIAC,cAJA;MAKAC,oBALA;MAMAC,oBANA;MAOAC,YAPA;MAQAC,cARA;MASAC;IATA,CAJA;IAeAC,QAfA;IAgBAC,SAhBA;IAiBAC,cAjBA;IAkBAC,cAlBA;IAmBAC,aAnBA;IAoBAC,wBApBA;IAqBAC;MACAC,gBADA;MAEAC,sBAFA;MAEA;MACAC,sBAHA;MAGA;MACAC,MAJA;MAKAC;QACAC,OADA;QAEAC,QAFA;QAGAH,MAHA;QAIAI;MAJA,CALA;MAWAC;QACAH,OADA;QAEAC,QAFA;QAGAG,UAHA;QAIAC,cAJA;QAKAP,MALA;QAMAI,SANA;QAOAI,OAPA;QAQAC,aARA;QASAC;UACAR,QADA;UAEAC;QAFA;MATA;IAXA,CArBA;IA+CAQ;MACA;MACAC,SAFA;MAGAC;IAHA,CA/CA;IAoDAC;MACAC,oBADA;MAEAC,YAFA;MAEA;MACAC,eAHA;MAIAC,eAJA;MAKAC,cALA;MAMAC,gBANA;MAOAC,eAPA;MAQAC,sBARA;MASAC,sBATA;MAUAC,mBAVA;MAWAC;IAXA,CApDA;IAiEAC;MACAnC,UADA,CACA;;IADA,CAjEA;IAoEAoC,WApEA;IAoEA;IACAC,YArEA;IAqEA;IACAvB;MACAwB;QACAC;UACAC,MADA,CACA;;QADA;MADA,CADA;MAMA7C;QACAI,SADA;QACA;QACAC,SAFA;QAEA;QACAyC,aAHA;QAIAC;MAJA,CANA;MAYAC;QACAC,SADA;QACA;QACAC,YAFA;QAEA;QACAC,aAHA,CAGA;;MAHA,CAZA;MAiBAC;QACAnD,aADA;QAEAkD,cAFA;QAEA;QACAE,6BAHA;QAGA;QACAJ,SAJA;QAIA;QACAK;MALA;IAjBA,CAtEA;IA+FAvC;MACAoC,aADA;MACA;MACAI,0BAFA;MAEA;MACAC,kBAHA;MAGA;MACAC,UACA;MACA;QACA7D,KADA;QAEAE,WAFA;QAGA4D,WAHA;QAIAtD;MAJA,CAFA,CAJA;MAaAgB,YAbA;MAaA;MACAhB,QAdA;MAeAuD,aAfA;MAgBAC,sBAhBA;MAiBAC,YAjBA;MAkBAT;QACAnD,iBADA;QAEAqD,QAFA;QAGAQ,eAHA;QAIAC,WAJA;QAKAC,UALA;QAMAC;MANA;IAlBA,CA/FA;IA0HAC;MACAC,4BADA;MACA;MACAtB,MAFA;MAEA;MACAxC,SAHA;MAIA+D,cAJA;MAKAC;QACAhE,UADA;QACA;QACA8C,aAFA;QAEA;QACAmB,UAHA;QAIAC;UAAAC;UAAAC;UAAAC;QAAA,CAJA;QAKAC;UACAD,QADA;UAEAD,UAFA;UAGAD;QAHA,CALA;QAUAI;UACA;UACAF;YACA;UACA,CAJA;;UAKAD;YACA;UACA,CAPA;;UAQAD;YACA;UACA;;QAVA;MAVA,CALA;MA4BAK;QACAxE,UADA;QACA;QACA8C,aAFA;QAEA;QACAmB,UAHA;QAIAC;UAAAC;UAAAC;UAAAC;QAAA,CAJA;QAKAE;UACAF;YACA;UACA,CAHA;;UAIAD;YACA;UACA,CANA;;UAOAD;YACA;UACA;;QATA;MALA,CA5BA;MA6CAM;QACAzE,UADA;QACA;QACA8C,aAFA;QAEA;QACAmB,UAHA;QAIAC;UAAAC;UAAAC;UAAAC;QAAA,CAJA;QAKAE;UACA;UACAJ;YACA;UACA,CAJA;;UAKAC;YACA;UACA,CAPA;;UAQAC;YACA;UACA;;QAVA;MALA;IA7CA,CA1HA;IA0LAK;MACA;MACAC,UAFA;MAGAC,+EAHA;MAIAC,uDAJA;MAKAC,8CALA;MAMAC,0GANA;MAOAC,yEAPA;MAQAC,YARA;MASAC;QACAC,eADA;QAEAC,cAFA;QAGAC,kBAHA;QAIAC,aAJA;QAKAC,gBALA;QAMAC,YANA;QAOAC,cAPA;QAQAC,UARA;QASAC,aATA;QAUAC,YAVA;QAWAC,eAXA;QAYAC,WAZA;QAaAC;MAbA,CATA;MAwBAC;QACAC,WADA;QAEAC,eAFA;QAGAC,eAHA;QAIAC,iBAJA;QAKAC,wBALA;QAMAC;MANA,CAxBA;MAgCAC;QACA;QACA;QACA;MACA;IApCA;EA1LA;AAiOA;AAEA;AACA;AACA;AACA;AACA;;;AACA;EACA;EACA,wBACAC,gBADA,CACAC,aADA,EAEAC,gBAFA,CAEA,aAFA,EAGAC,QAHA;;EAIA;IACA;MACAC;IACA;;IACA;MACAC;IACA;EACA;;EACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;EACA,OACAC,QACA,wBADA,IAEA,oBAFA,IAGA,8BAHA,IAIA,2CAJA,IAKA,0BANA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;EACA;IACA;EACA;;EACA;;EACA;IACA;MACA;QACA;UACAC;QACA;;QACAA;MACA,CALA,MAKA;QACAA;;QACA;UACA;YACAA;YACA;UACA;;UACAA;QACA;MACA,CATA,MASA;QACAA;MACA;IACA;EACA;;EACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;EACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;EACA;IACA;EACA;;EACA;;EACA;IACA;MACA;QACA;UACAC;QACA;;QACAC;MACA,CALA,MAKA;QACAD;MACA,CAFA,MAEA;QACA;UACAD;QACA;MACA,CAJA,MAIA;QACAC;MACA;IACA;EACA;;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;EACA;IACA;MAAArG;MAAAC;MAAAsG;IAAA;EACA,CAFA,MAEA;IACA;MAAAvG;MAAAC;MAAAsG;IAAA;EACA,CAFA,MAEA;IACA;MAAAvG;MAAAC;MAAAsG;IAAA;EACA,CAFA,MAEA;IACA;MACA;QAAAvG;QAAAC;QAAAsG;MAAA;IACA;;IACA;;IACA;MACA;QACA;MACA;IACA;EACA,CAVA,MAUA;IACA;MAAAvG;MAAAC;MAAAsG;IAAA;EACA,CAFA,MAEA;IACA;MAAAvG;MAAAC;MAAAsG;IAAA;EACA,CAFA,MAEA;IACA;MACA;QACA;MACA;;MACA;QACA;UAAAvG;UAAAC;UAAAsG;QAAA;MACA;;MACA;;MACA;QACA;MACA;IACA;EACA,CAbA,MAaA;IACA;MAAAvG;MAAAC;MAAAsG;IAAA;EACA;;EACA;AACA;AAEA;AACA;AACA;AACA;;AACA;EACAvC,oBADA;EAEAwC;IACAC;EADA,CAFA;EAKAC,2CALA;;EAMAC;IACA;IACA;IACAC;MACAC,gBADA;MAEAC;IAFA;IAIA;EACA,CAdA;;EAeAC;IACA;MACAC;QACAC,SADA;QAEAC;UACAC,kBADA;UAEA1H,wBAFA;UAGAF,cAHA;UAIAG;YACAM,OADA;YAEAF;UAFA;QAJA,CAFA;QAWAsH,gBAXA;QAYAC,QAZA;QAaAC,aAbA;QAcAC,YAdA;QAeAC,GAfA;QAgBAC,sBAhBA;QAgBA;QACAC,wBAjBA;QAiBA;QACAC,oBAlBA;QAmBAC,kBAnBA;QAoBAC,oBApBA;QAqBAC,kBArBA;QAsBAC,wBAtBA;QAuBAC,0BAvBA;QAwBAC;MAxBA;IADA;EA4BA,CA5CA;;EA6CAC;IACAC,SADA;IAEA7B,iBAFA;;IAIA;AACA;AACA;AACA;AACA;IACA8B;MACA;MACAC;MACAA;MACAA;MACAvC;MACA;MACAuC;MACA;MACAC;MACAD;MACA;MACAA;MACA;MACA;MACA;IACA,CAzBA;;IA2BA;AACA;AACA;AACA;AACA;IACAE;MACA;QACA;UACAC;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACA;UACAA;QACA,CAFA,MAEA;UACAA;QACA;;QACA;UACAA;QACA;MACA;;MACA;IACA,CAtFA;;IAwFA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;QACAxB,iBACA,OADA;UAEArI,gCAFA;UAGAC,sCAHA;UAIAC,sCAJA;UAKAC,4CALA;UAMAC,4CANA;UAOAC,oCAPA;UAQAC,sCARA;UASAC;QATA;MAWA;;MACA;IACA,CA7GA;;IA+GA;AACA;AACA;IACAuJ;MACA;MACA;;MACA;QACA;MACA;;MACAC;MACAA;;MACA;QACAzB;MACA;;MACAA;QACA0B;QACAA;QACAA;;QACA;UACAA;QACA;;QACA;UACAA;QACA;;QACAA;QACA;MACA,CAZA;MAaA;MACA3B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA,CAnJA;;IAqJA;AACA;AACA;IACA4B;MACA;IACA,CA1JA;;IA4JA;AACA;AACA;AACA;AACA;IACAC;MACA;IACA,CAnKA;;IAqKA;AACA;AACA;AACA;AACA;IACAC;MACA;MACA;QACA;UACAC;QACA;MACA,CAJA;MAKA;IACA,CAlLA;;IAoLA;AACA;AACA;AACA;AACA;IACAC;MACA,OACA,wEACA,2CAFA;IAIA,CA9LA;;IAgMA;AACA;AACA;IACAC;MACA,IACA,iCACA,gFAFA,EAGA;QACA;MACA;IACA,CA1MA;;IA4MA;AACA;AACA;IACAC;MACA;MACA;;MACA;QACA;UACAP,6BACA,2FADA;QAEA,CAHA,MAGA;UACAA;QACA;;QACAQ;QACAR;QACAS;QACAT;MACA;;MACA;MACA;IACA,CAhOA;;IAkOA;AACA;AACA;IACAU;MACA;QACA1K,QADA;QAEAE,aAFA;QAGAyK,YAHA;QAIAC,eAJA;QAKAC,WALA;QAMAC,YANA;QAOAC;MAPA;MASA;;MACA;QACA;QACAC;QACAA;QACAA;QACAA;QACAtC;MACA;;MACA;IACA,CAzPA;;IA2PA;AACA;AACA;AACA;AACA;AACA;IACAuC;MACA;QACA;;QACA;UACA;YACArB;UACA;;UACA;YACAoB;YACAA;UACA,CAHA,MAGA;YACAA;YACAA;UACA;;UACAA;UACApB;UACAA;UACAoB;QACA;MACA;;MACA;IACA,CAtRA;;IAwRA;AACA;AACA;AACA;AACA;AACA;IACAE;MACA;QACA;MACA;;MACA;IACA,CAnSA;;IAqSA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;IACA,CA7SA;;IA+SA;AACA;AACA;AACA;AACA;IACAC;MACA;QACAxB;MACA;;MACA;QACA;UACA;QACA;MACA;;MACA;IACA,CA9TA;;IAgUA;AACA;AACA;AACA;AACA;IACAyB;MACA;IACA,CAvUA;;IAyUA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;QACA;;QACAC;UACA;UACAC;UACAA;UACAA;UACAC;QACA,CANA;;QAOAF;MACA,CAVA;IAWA,CA3VA;;IA6VA;AACA;AACA;AACA;AACA;IACAG;MACA,aACAC,2GACA,kCADA,GAEA,uCAFA,GAGA,+BAJA;;MAKA;QACAlL;MACA;;MACA;IACA,CA5WA;;IA8WA;AACA;AACA;AACA;AACA;IACAmL;MACA;QACA,OACA,gCACA,gDADA,GAEA,kDAHA;MAKA;;MACA;IACA,CA5XA;;IA8XA;AACA;AACA;AACA;AACA;IACAC;MACA;IACA,CArYA;;IAuYA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;;MACA;QACAC;MACA;;MACA;IACA,CAnZA;;IAqZA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;MACA;IACA,CA9ZA;;IAgaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA,OACAF,8DACAA,mDADA,IAEAA,sDACAA,2DAJA;IAMA,CA/aA;;IAibA;AACA;AACA;AACA;AACA;IACAG;MACA,oBACA,yDADA,EAEA,sDAFA;IAIA,CA3bA;;IA6bA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;QACA;MACA;;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,uDACA,iEADA,EAEAC,OAFA;MAGA;IACA,CAndA;;IAqdA;AACA;AACA;AACA;AACA;IACAC;MACA;MACA;MACAC;;MACA;QACAA;MACA;;MACA;IACA,CAleA;;IAoeA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;QACA;QACA;QACA;QACA;MACA;;MACA;QACA;QACA;QACA;QACA;QACA;MACA;IACA,CAxfA;;IA0fA;AACA;AACA;AACA;IACAC;MACA;IACA,CAhgBA;;IAkgBA;AACA;AACA;IACAC;MACA;QACA;QACA;QACA;;QACA;UACAvL;QACA,CAFA,MAEA;UACAA;QACA;;QACA;MACA,CAVA,MAUA;QACA;QACA;QACA;;QACA;UACAE;QACA,CAFA,MAEA;UACAA;QACA;;QACA;MACA,CAVA,MAUA;QACA;QACA;QACA;;QACA;UACAA;QACA,CAFA,MAEA;UACAA;QACA;;QACA;MACA;IACA,CAriBA;;IAuiBA;AACA;AACA;IACAsL;MACA;MACA;MACA;MACA;IACA,CA/iBA;;IAijBA;AACA;AACA;IACAC;MACA;MACA;MACA;IACA,CAxjBA;;IA0jBA;AACA;AACA;IACAC;MACA;MACA;MACA;MACA;MACA;MACA;IACA,CApkBA;;IAskBA;AACA;AACA;IACAC;MACA;MACA;MACA;IACA,CA7kBA;;IA+kBA;AACA;AACA;IACAC;MACA;MACA;IACA,CArlBA;;IAulBA;AACA;AACA;IACAC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACA,CAnmBA;;IAqmBA;AACA;AACA;IACAC;MACA;MACA;MACA;MACA;MACA,wCACA,qGADA;MAEA,6FACA,kCADA,EAEA,cAFA;MAIA,+CACA,oFADA;MAEA,2BACA,+FADA;IAEA,CAvnBA;;IAynBA;AACA;AACA;IACAC;MACA,mFACA9H,MADA,CACA,8BADA,EAEA+H,OAFA,CAEA,KAFA,EAGAC,QAHA,CAGA,+BAHA,EAGA,MAHA,EAIAD,OAJA,CAIA,KAJA,EAKAd,OALA;MAMA,iFACAjH,MADA,CACA,8BADA,EAEAiI,KAFA,CAEA,KAFA,EAGAC,GAHA,CAGA,8BAHA,EAGA,MAHA,EAIAD,KAJA,CAIA,KAJA,EAKAhB,OALA;MAMA;IACA,CA1oBA;;IA4oBA;AACA;AACA;AACA;AACA;IACAkB;MACA;MACA;MACA;MACA3K;QACAjB,2BADA;QAEA2B;UACAkK,KADA;UAEAC;QAFA;MAFA;;MAOA,KACA,4DACAH,GADA,CACA,CADA,EACA,qCADA,EAEAH,OAFA,CAEA,KAFA,CADA,EAIAO,+BAJA,EAKAA,sFALA,EAMA;QACA;QACA;QACA;UACA/L,2BADA;UAEA2B;YACAkK,YADA;YAEAC;UAFA;QAFA;QAOA;QACAE;UACAH,qCADA;UAEAC;QAFA;QAIA7K;MACA;;MACA;MACAgL;QACAJ,qEADA;QAEAC;MAFA;MAIA;IACA,CAzrBA;;IA2rBA;AACA;AACA;IACAI;MACA;MACA;MACA;IACA,CAlsBA;;IAosBA;AACA;AACA;IACAC;MACA;QAAA;MAAA;MACA;MACA;MACA,kEAJA,CAIA;;MACA;;MACA;QACA;MACA;;MACA;QACAlJ;MACA;;MACA;QACA;UAAAF;QAAA;;QACA;UACA;UACA;UACAC;QACA;;QACA;;QACA;UACA;YACAC;UACA;QACA;;QACA8I;MACA;IACA,CAluBA;;IAouBA;AACA;AACA;IACAK;MACA;QAAA;MAAA;MACA;MACA;MACA;MACA;MACA;MACA9F;QACArD;MACA,CAFA;;MAGA;QACA;UACAM;QADA;QAGA+C;UACAtD,gDACA,+DADA,EAEAlE,KAFA;QAGA,CAJA;QAKA;QACAwH;UACA;YACArD;UACA;QACA,CAJA;QAKA8I;MACA;IACA,CAlwBA;;IAowBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACAM;MACA;QACA;MACA;;MACA;MACA;MACA;;MACA;QACAC;;QACA;UACAD;QACA;;QACAE;MACA;;MACA;IACA,CA7xBA;;IA+xBA;AACA;AACA;IACAC;MACA;QAAA;MAAA;MACA;MACA;MACA;MACAlG;QACArD;MACA,CAFA;MAGA;MACA;MACA;;MACA;QACA;UACAO;QADA;QAGA8C;UACAtD,gDACA,iEADA,EAEAlE,KAFA;QAGA,CAJA;QAKA;QACAwH;UACA;YACArD;UACA;QACA,CAJA;QAKA8I;MACA;IACA,CA9zBA;;IAg0BA;AACA;AACA;IACAU;MACA;MACA;;MACA;QACA;;QACA;UACA7L;QACA;;QACA;UACAC;QACA;MACA;;MACA;MACA;MACA,0DACA4C,MADA,CACA,8BADA,EAEA+H,OAFA,CAEA,KAFA,EAGAC,QAHA,CAGA,+BAHA,EAGA,MAHA,EAIAD,OAJA,CAIA,KAJA,EAKAd,OALA;MAMA,wDACAjH,MADA,CACA,8BADA,EAEAiI,KAFA,CAEA,KAFA,EAGAC,GAHA,CAGA,8BAHA,EAGA,MAHA,EAIAD,KAJA,CAIA,KAJA,EAKAhB,OALA;IAMA,CA71BA;;IA+1BA;AACA;AACA;IACAgC;MACA;MACA;MACA;MACA;MACA;MACA,+EACA;QACA;UAAA5N;QAAA;MACA,CAHA,EAIA;QAAAA;MAAA,CAJA,EAKAA,KALA;IAMA,CA92BA;;IAg3BA;AACA;AACA;IACA6N;MACA;QACA;MACA;;MACA;;MACA,IACA,kDACA,iFAFA,EAGA;QACA,aACA,kDACA,iFAFA;QAGA;;QACA;UACAC;QACA;;QACA;UACAtE;QACA,CAFA;MAGA,CAdA,MAcA;QACA;UACAA;QACA,CAFA;MAGA;;MACA;MACA;MACA;IACA;;EA94BA,CA7CA;EA87BAuE;IACA;AACA;AACA;AACA;AACA;IACA5C;MACA;MACA;MACA;MACA;;MACA;QACA6C;QACA;MACA;;MACA;MACA;MACA;MACA;;MACA;QACA;QACA5E,aACAA,wGADA;;QAEA;UACAA;QACA;;QACAA;QACAA;QACAA,SACA,6FACA,4CAFA;MAGA;;MACA;IACA,CAjCA;;IAmCA;AACA;AACA;IACAtJ;MACA;IACA,CAxCA;;IA0CA;AACA;AACA;IACAmO;MACA;MACA;IACA,CAhDA;;IAkDA;AACA;AACA;IACAC;MACA;IACA,CAvDA;;IAyDA;AACA;AACA;IACAC;MACA;IACA;;EA9DA,CA97BA;;EA+/BA;AACA;AACA;EACAC;IACA;IACA;IACA,sCACA,OADA,EAEAvG;MACA;;MACA;QACA;MACA;IACA,CAPA,EAQA;MAAAwG;IAAA,CARA;IAUA,wCACA,SADA,EAEAC;MACA;;MACA;QACA;MACA;IACA,CAPA,EAQA;MAAAD;IAAA,CARA;IAUA,sCACA,cADA,EAEAvO;MACA;;MACA;QACA;MACA;IACA,CAPA,EAQA;MAAAuO;MAAAE;IAAA,CARA;IAWA,4CACA,aADA,EAEA1G;MACA;IACA,CAJA,EAKA;MAAAwG;IAAA,CALA;IAOA,8CACA,eADA,EAEAvG;MACA;IACA,CAJA,EAKA;MAAAuG;IAAA,CALA;IAOA,4CACA,OADA,EAEAvO;MACA;IACA,CAJA,EAKA;MAAAuO;IAAA,CALA;IAQA;IACA;EACA,CA5jCA;;EA8jCA;AACA;AACA;EACAG;IACA;EACA,CAnkCA;;EAqkCA;AACA;AACA;EACAC;IACA;IACA;MACA;IACA,CAFA;IAGA;IACA;IACA;IACA;IACA;IACA;EACA,CAnlCA;;EAqlCA;AACA;AACA;EACAC;IACA;EACA,CA1lCA;;EA4lCA;AACA;AACA;EACAC;IACA;MACA;IACA,CAFA;EAGA,CAnmCA;;EAqmCA;AACA;AACA;EACAC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACA,CAjnCA;;EAmnCA;AACA;AACA;EACAC;IACA;EACA;;AAxnCA;AA0nCA","names":["VueInst","initVue","localeName","slots","header","taskMapping","id","start","label","duration","progress","type","style","collapsed","width","height","clientWidth","outerHeight","rowsHeight","allVisibleTasksHeight","scroll","scrolling","dragXMoveMultiplier","dragYMoveMultiplier","top","taskList","left","right","bottom","chart","percent","timePercent","time","timeCenter","dateTime","scope","before","after","times","timeScale","timeZoom","timePerPixel","firstTime","lastTime","firstTaskTime","lastTaskTime","totalViewDurationMs","totalViewDurationPx","stepDuration","steps","row","maxRows","maxHeight","grid","horizontal","gap","pattern","bar","text","offset","xPadding","display","expander","displayIfTaskListHidden","size","resizeAfterThreshold","widthThreshold","columns","value","finalWidth","widthFromPercentage","minWidth","columnWidth","padding","margin","straight","calendar","workingDays","strokeWidth","hour","widths","maxWidths","short","medium","long","formatted","format","day","month","locale","name","weekdays","weekdaysShort","weekdaysMin","months","monthsShort","weekStart","relativeTime","future","past","s","m","mm","h","hh","d","dd","M","MM","y","yy","formats","LT","LTS","L","LL","LLL","LLLL","ordinal","getComputedStyle","document","getPropertyValue","toString","fontSize","fontFamily","item","target","component","mergeDeepReactive","what","components","MainView","props","provide","Object","enumerable","get","data","state","tasks","options","scrollBarHeight","dynamicStyle","refs","tasksById","taskTree","ctx","emitTasksChanges","emitOptionsChanges","resizeObserver","unwatchTasks","unwatchOptions","unwatchStyle","unwatchOutputTasks","unwatchOutputOptions","unwatchOutputStyle","methods","mergeDeep","getScrollBarHeight","outer","inner","fillTasks","task","mapTasks","initialize","dayjs","column","initializeStyle","getCalendarHeight","getMaximalLevel","maximalLevel","getMaximalExpanderWidth","syncScrollTop","calculateTaskListColumnsDimensions","percentage","final","resetTaskTree","children","allChildren","parents","parent","__root","current","makeTaskTree","getTask","getChildren","isTaskVisible","getSVG","getImage","img","canvas","resolve","getHeight","visibleTasks","getTaskHeight","getTasksHeight","timeToPixelOffsetX","x","pixelOffsetXToTime","isInsideViewPort","onScrollChart","_onScrollChart","valueOf","scrollToTime","pos","scrollTo","fixScrollPos","onWheelChart","onTimeZoomChange","onRowHeightChange","onScopeChange","onTaskListWidthChange","onTaskListColumnWidthChange","initializeEvents","recalculateTimes","initTimes","startOf","subtract","endOf","add","calculateSteps","ms","px","currentDate","previousStep","lastStep","computeCalendarWidths","computeHourWidths","computeDayWidths","monthsCount","currentMonth","previousMonth","computeMonthWidths","prepareDates","setup","globalOnResize","diffPercent","computed","heightCompensation","getTaskListColumns","outputTasks","outputOptions","created","deep","opts","immediate","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed"],"sourceRoot":"node_modules/_gantt-elastic@1.0.12@gantt-elastic/src","sources":["GanttElastic.vue"],"sourcesContent":["<!--\n/**\n * @fileoverview GanttElastic component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <div class=\"gantt-elastic\" style=\"width:100%\">\n    <slot name=\"header\"></slot>\n    <main-view ref=\"mainView\"></main-view>\n    <slot name=\"footer\"></slot>\n  </div>\n</template>\n\n<script>\nimport VueInstance from 'vue';\nimport dayjs from 'dayjs';\nimport MainView from './components/MainView.vue';\nimport getStyle from './style.js';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nconst ctx = document.createElement('canvas').getContext('2d');\nlet VueInst = VueInstance;\nfunction initVue() {\n  if (typeof Vue !== 'undefined' && typeof VueInst === 'undefined') {\n    VueInst = Vue;\n  }\n}\ninitVue();\n\nlet hourWidthCache = null;\n\n/**\n * Helper function to fill out empty options in user settings\n *\n * @param {object} userOptions - initial user options that will merge with those below\n * @returns {object} merged options\n */\nfunction getOptions(userOptions) {\n  let localeName = 'en';\n  if (typeof userOptions.locale !== 'undefined' && typeof userOptions.locale.name !== 'undefined') {\n    localeName = userOptions.locale.name;\n  }\n  return {\n    slots: {\n      header: {}\n    },\n    taskMapping: {\n      //*\n      id: 'id',\n      start: 'start',\n      label: 'label',\n      duration: 'duration',\n      progress: 'progress',\n      type: 'type',\n      style: 'style',\n      collapsed: 'collapsed'\n    },\n    width: 0,\n    height: 0,\n    clientWidth: 0,\n    outerHeight: 0,\n    rowsHeight: 0,\n    allVisibleTasksHeight: 0,\n    scroll: {\n      scrolling: false,\n      dragXMoveMultiplier: 3, //*\n      dragYMoveMultiplier: 2, //*\n      top: 0,\n      taskList: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      chart: {\n        left: 0,\n        right: 0,\n        percent: 0,\n        timePercent: 0,\n        top: 0,\n        bottom: 0,\n        time: 0,\n        timeCenter: 0,\n        dateTime: {\n          left: '',\n          right: ''\n        }\n      }\n    },\n    scope: {\n      //*\n      before: 1,\n      after: 1\n    },\n    times: {\n      timeScale: 60 * 1000,\n      timeZoom: 17, //*\n      timePerPixel: 0,\n      firstTime: null,\n      lastTime: null,\n      firstTaskTime: 0,\n      lastTaskTime: 0,\n      totalViewDurationMs: 0,\n      totalViewDurationPx: 0,\n      stepDuration: 'day',\n      steps: []\n    },\n    row: {\n      height: 24 //*\n    },\n    maxRows: 20, //*\n    maxHeight: 0, //*\n    chart: {\n      grid: {\n        horizontal: {\n          gap: 6 //*\n        }\n      },\n      progress: {\n        width: 20, //*\n        height: 6, //*\n        pattern: true,\n        bar: false\n      },\n      text: {\n        offset: 4, //*\n        xPadding: 10, //*\n        display: true //*\n      },\n      expander: {\n        type: 'chart',\n        display: false, //*\n        displayIfTaskListHidden: true, //*\n        offset: 4, //*\n        size: 18\n      }\n    },\n    taskList: {\n      display: true, //*\n      resizeAfterThreshold: true, //*\n      widthThreshold: 75, //*\n      columns: [\n        //*\n        {\n          id: 0,\n          label: 'ID',\n          value: 'id',\n          width: 40\n        }\n      ],\n      percent: 100, //*\n      width: 0,\n      finalWidth: 0,\n      widthFromPercentage: 0,\n      minWidth: 18,\n      expander: {\n        type: 'task-list',\n        size: 16,\n        columnWidth: 24,\n        padding: 16,\n        margin: 10,\n        straight: false\n      }\n    },\n    calendar: {\n      workingDays: [1, 2, 3, 4, 5], //*\n      gap: 6, //*\n      height: 0,\n      strokeWidth: 1,\n      hour: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        formatted: {\n          long: [],\n          medium: [],\n          short: []\n        },\n        format: {\n          //*\n          long(date) {\n            return date.format('HH:mm');\n          },\n          medium(date) {\n            return date.format('HH:mm');\n          },\n          short(date) {\n            return date.format('HH');\n          }\n        }\n      },\n      day: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        format: {\n          long(date) {\n            return date.format('DD dddd');\n          },\n          medium(date) {\n            return date.format('DD ddd');\n          },\n          short(date) {\n            return date.format('DD');\n          }\n        }\n      },\n      month: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        format: {\n          //*\n          short(date) {\n            return date.format('MM');\n          },\n          medium(date) {\n            return date.format(\"MMM 'YY\");\n          },\n          long(date) {\n            return date.format('MMMM YYYY');\n          }\n        }\n      }\n    },\n    locale: {\n      //*\n      name: 'en',\n      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n      weekStart: 1,\n      relativeTime: {\n        future: 'in %s',\n        past: '%s ago',\n        s: 'a few seconds',\n        m: 'a minute',\n        mm: '%d minutes',\n        h: 'an hour',\n        hh: '%d hours',\n        d: 'a day',\n        dd: '%d days',\n        M: 'a month',\n        MM: '%d months',\n        y: 'a year',\n        yy: '%d years'\n      },\n      formats: {\n        LT: 'HH:mm',\n        LTS: 'HH:mm:ss',\n        L: 'DD/MM/YYYY',\n        LL: 'D MMMM YYYY',\n        LLL: 'D MMMM YYYY HH:mm',\n        LLLL: 'dddd, D MMMM YYYY HH:mm'\n      },\n      ordinal: n => {\n        const s = ['th', 'st', 'nd', 'rd'];\n        const v = n % 100;\n        return `[${n}${s[(v - 20) % 10] || s[v] || s[0]}]`;\n      }\n    }\n  };\n}\n\n/**\n * Prepare style\n *\n * @returns {object}\n */\nfunction prepareStyle(userStyle) {\n  let fontSize = '12px';\n  let fontFamily = window\n    .getComputedStyle(document.body)\n    .getPropertyValue('font-family')\n    .toString();\n  if (typeof userStyle !== 'undefined') {\n    if (typeof userStyle.fontSize !== 'undefined') {\n      fontSize = userStyle.fontSize;\n    }\n    if (typeof userStyle.fontFamily !== 'undefined') {\n      fontFamily = userStyle.fontFamily;\n    }\n  }\n  return getStyle(fontSize, fontFamily);\n}\n\n/**\n * Helper function to determine if specified variable is an object\n *\n * @param {any} item\n *\n * @returns {boolean}\n */\nfunction isObject(item) {\n  return (\n    item &&\n    typeof item === 'object' &&\n    !Array.isArray(item) &&\n    !(item instanceof HTMLElement) &&\n    !(item instanceof CanvasRenderingContext2D) &&\n    typeof item !== 'function'\n  );\n}\n\n/**\n * Helper function which will merge objects recursively - creating brand new one - like clone\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\nexport function mergeDeep(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          target[key] = {};\n        }\n        target[key] = mergeDeep(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = [];\n        for (let item of source[key]) {\n          if (isObject(item)) {\n            target[key].push(mergeDeep({}, item));\n            continue;\n          }\n          target[key].push(item);\n        }\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n}\n\n/**\n * Detect if object or array is observable\n *\n * @param {object|array} obj\n *\n * @returns {boolean}\n */\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj.hasOwnProperty('__ob__');\n}\n\n/**\n * Same as above but with reactivity in mind\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\nexport function mergeDeepReactive(component, target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          component.$set(target, key, {});\n        }\n        mergeDeepReactive(component, target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        component.$set(target, key, source[key]);\n      } else if (typeof source[key] === 'function') {\n        if (source[key].toString().indexOf('[native code]') === -1) {\n          target[key] = source[key];\n        }\n      } else {\n        component.$set(target, key, source[key]);\n      }\n    }\n  }\n  return mergeDeepReactive(component, target, ...sources);\n}\n/**\n * Check if objects or arrays are equal by comparing nested values\n *\n * @param {object|array} left\n * @param {object|array} right\n *\n * @returns {boolean}\n */\nexport function notEqualDeep(left, right, cache = [], path = '') {\n  if (typeof right !== typeof left) {\n    return { left, right, what: path + '.typeof' };\n  } else if (Array.isArray(left) && !Array.isArray(right)) {\n    return { left, right, what: path + '.isArray' };\n  } else if (Array.isArray(right) && !Array.isArray(left)) {\n    return { left, right, what: path + '.isArray' };\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    if (left.length !== right.length) {\n      return { left, right, what: path + '.length' };\n    }\n    let what;\n    for (let index = 0, len = left.length; index < len; index++) {\n      if ((what = notEqualDeep(left[index], right[index], cache, path + '.' + index))) {\n        return what;\n      }\n    }\n  } else if (isObject(left) && !isObject(right)) {\n    return { left, right, what: path + '.isObject' };\n  } else if (isObject(right) && !isObject(left)) {\n    return { left, right, what: path + '.isObject' };\n  } else if (isObject(left) && isObject(right)) {\n    for (let key in left) {\n      if (!left.hasOwnProperty(key) || !left.propertyIsEnumerable(key)) {\n        continue;\n      }\n      if (!right.hasOwnProperty(key)) {\n        return { left, right, what: path + '.' + key };\n      }\n      let what;\n      if ((what = notEqualDeep(left[key], right[key], cache, path + '.' + key))) {\n        return what;\n      }\n    }\n  } else if (left !== right) {\n    return { left, right, what: path + '. !==' };\n  }\n  return false;\n}\n\n/**\n * GanttElastic\n * Main vue component\n */\nconst GanttElastic = {\n  name: 'GanttElastic',\n  components: {\n    MainView\n  },\n  props: ['tasks', 'options', 'dynamicStyle'],\n  provide() {\n    const provider = {};\n    const self = this;\n    Object.defineProperty(provider, 'root', {\n      enumerable: true,\n      get: () => self\n    });\n    return provider;\n  },\n  data() {\n    return {\n      state: {\n        tasks: [],\n        options: {\n          scrollBarHeight: 0,\n          allVisibleTasksHeight: 0,\n          outerHeight: 0,\n          scroll: {\n            left: 0,\n            top: 0\n          }\n        },\n        dynamicStyle: {},\n        refs: {},\n        tasksById: {},\n        taskTree: {},\n        ctx,\n        emitTasksChanges: true, // some operations may pause emitting changes to parent component\n        emitOptionsChanges: true, // some operations may pause emitting changes to parent component\n        resizeObserver: null,\n        unwatchTasks: null,\n        unwatchOptions: null,\n        unwatchStyle: null,\n        unwatchOutputTasks: null,\n        unwatchOutputOptions: null,\n        unwatchOutputStyle: null\n      }\n    };\n  },\n  methods: {\n    mergeDeep,\n    mergeDeepReactive,\n\n    /**\n     * Calculate height of scrollbar in current browser\n     *\n     * @returns {number}\n     */\n    getScrollBarHeight() {\n      const outer = document.createElement('div');\n      outer.style.visibility = 'hidden';\n      outer.style.height = '100px';\n      outer.style.msOverflowStyle = 'scrollbar';\n      document.body.appendChild(outer);\n      var noScroll = outer.offsetHeight;\n      outer.style.overflow = 'scroll';\n      var inner = document.createElement('div');\n      inner.style.height = '100%';\n      outer.appendChild(inner);\n      var withScroll = inner.offsetHeight;\n      outer.parentNode.removeChild(outer);\n      const height = noScroll - withScroll;\n      this.style['chart-scroll-container--vertical']['margin-left'] = `-${height}px`;\n      return (this.state.options.scrollBarHeight = height);\n    },\n\n    /**\n     * Fill out empty task properties and make it reactive\n     *\n     * @param {array} tasks\n     */\n    fillTasks(tasks) {\n      for (let task of tasks) {\n        if (typeof task.x === 'undefined') {\n          task.x = 0;\n        }\n        if (typeof task.y === 'undefined') {\n          task.y = 0;\n        }\n        if (typeof task.width === 'undefined') {\n          task.width = 0;\n        }\n        if (typeof task.height === 'undefined') {\n          task.height = 0;\n        }\n        if (typeof task.mouseOver === 'undefined') {\n          task.mouseOver = false;\n        }\n        if (typeof task.collapsed === 'undefined') {\n          task.collapsed = false;\n        }\n        if (typeof task.dependentOn === 'undefined') {\n          task.dependentOn = [];\n        }\n        if (typeof task.parentId === 'undefined') {\n          task.parentId = null;\n        }\n        if (typeof task.style === 'undefined') {\n          task.style = {};\n        }\n        if (typeof task.children === 'undefined') {\n          task.children = [];\n        }\n        if (typeof task.allChildren === 'undefined') {\n          task.allChildren = [];\n        }\n        if (typeof task.parents === 'undefined') {\n          task.parents = [];\n        }\n        if (typeof task.parent === 'undefined') {\n          task.parent = null;\n        }\n        if (typeof task.startTime === 'undefined') {\n          task.startTime = dayjs(task.start).valueOf();\n        }\n        if (typeof task.endTime === 'undefined' && task.hasOwnProperty('end')) {\n          task.endTime = dayjs(task.end).valueOf();\n        } else if (typeof task.endTime === 'undefined' && task.hasOwnProperty('duration')) {\n          task.endTime = task.startTime + task.duration;\n        }\n        if (typeof task.duration === 'undefined' && task.hasOwnProperty('endTime')) {\n          task.duration = task.endTime - task.startTime;\n        }\n      }\n      return tasks;\n    },\n\n    /**\n     * Map tasks\n     *\n     * @param {Array} tasks\n     * @param {Object} options\n     */\n    mapTasks(tasks, options) {\n      for (let [index, task] of tasks.entries()) {\n        tasks[index] = {\n          ...task,\n          id: task[options.taskMapping.id],\n          start: task[options.taskMapping.start],\n          label: task[options.taskMapping.label],\n          duration: task[options.taskMapping.duration],\n          progress: task[options.taskMapping.progress],\n          type: task[options.taskMapping.type],\n          style: task[options.taskMapping.style],\n          collapsed: task[options.taskMapping.collapsed]\n        };\n      }\n      return tasks;\n    },\n\n    /**\n     * Initialize component\n     */\n    initialize(itsUpdate = '') {\n      let options = mergeDeep({}, this.state.options, getOptions(this.options), this.options);\n      let tasks = this.mapTasks(this.tasks, options);\n      if (Object.keys(this.state.dynamicStyle).length === 0) {\n        this.initializeStyle();\n      }\n      dayjs.locale(options.locale, null, true);\n      dayjs.locale(options.locale.name);\n      if (typeof options.taskList === 'undefined') {\n        options.taskList = {};\n      }\n      options.taskList.columns = options.taskList.columns.map((column, index) => {\n        column.thresholdPercent = 100;\n        column.widthFromPercentage = 0;\n        column.finalWidth = 0;\n        if (typeof column.height === 'undefined') {\n          column.height = 0;\n        }\n        if (typeof column.style === 'undefined') {\n          column.style = {};\n        }\n        column._id = `${index}-${column.label}`;\n        return column;\n      });\n      this.state.options = options;\n      tasks = this.fillTasks(tasks);\n      this.state.tasksById = this.resetTaskTree(tasks);\n      this.state.taskTree = this.makeTaskTree(this.state.rootTask, tasks);\n      this.state.tasks = this.state.taskTree.allChildren.map(childId => this.getTask(childId));\n      this.calculateTaskListColumnsDimensions();\n      this.state.options.scrollBarHeight = this.getScrollBarHeight();\n      this.state.options.outerHeight = this.state.options.height + this.state.options.scrollBarHeight;\n      this.globalOnResize();\n    },\n\n    /**\n     * Initialize style\n     */\n    initializeStyle() {\n      this.state.dynamicStyle = mergeDeep({}, prepareStyle(this.dynamicStyle), this.dynamicStyle);\n    },\n\n    /**\n     * Get calendar rows outer height\n     *\n     * @returns {int}\n     */\n    getCalendarHeight() {\n      return this.state.options.calendar.height + this.state.options.calendar.strokeWidth;\n    },\n\n    /**\n     * Get maximal level of nested task children\n     *\n     * @returns {int}\n     */\n    getMaximalLevel() {\n      let maximalLevel = 0;\n      this.state.tasks.forEach(task => {\n        if (task.parents.length > maximalLevel) {\n          maximalLevel = task.parents.length;\n        }\n      });\n      return maximalLevel - 1;\n    },\n\n    /**\n     * Get maximal expander width - to calculate straight task list text\n     *\n     * @returns {int}\n     */\n    getMaximalExpanderWidth() {\n      return (\n        this.getMaximalLevel() * this.state.options.taskList.expander.padding +\n        this.state.options.taskList.expander.margin\n      );\n    },\n\n    /**\n     * Synchronize scrollTop property when row height is changed\n     */\n    syncScrollTop() {\n      if (\n        this.state.refs.taskListItems &&\n        this.state.refs.chartGraph.scrollTop !== this.state.refs.taskListItems.scrollTop\n      ) {\n        this.state.options.scroll.top = this.state.refs.taskListItems.scrollTop = this.state.refs.chartScrollContainerVertical.scrollTop = this.state.refs.chartGraph.scrollTop;\n      }\n    },\n\n    /**\n     * Calculate task list columns dimensions\n     */\n    calculateTaskListColumnsDimensions() {\n      let final = 0;\n      let percentage = 0;\n      for (let column of this.state.options.taskList.columns) {\n        if (column.expander) {\n          column.widthFromPercentage =\n            ((this.getMaximalExpanderWidth() + column.width) / 100) * this.state.options.taskList.percent;\n        } else {\n          column.widthFromPercentage = (column.width / 100) * this.state.options.taskList.percent;\n        }\n        percentage += column.widthFromPercentage;\n        column.finalWidth = (column.thresholdPercent * column.widthFromPercentage) / 100;\n        final += column.finalWidth;\n        column.height = this.getTaskHeight() - this.style['grid-line-horizontal']['stroke-width'];\n      }\n      this.state.options.taskList.widthFromPercentage = percentage;\n      this.state.options.taskList.finalWidth = final;\n    },\n\n    /**\n     * Reset task tree - which is used to create tree like structure inside task list\n     */\n    resetTaskTree(tasks) {\n      this.$set(this.state, 'rootTask', {\n        id: null,\n        label: 'root',\n        children: [],\n        allChildren: [],\n        parents: [],\n        parent: null,\n        __root: true\n      });\n      const tasksById = {};\n      for (let i = 0, len = tasks.length; i < len; i++) {\n        let current = tasks[i];\n        current.children = [];\n        current.allChildren = [];\n        current.parent = null;\n        current.parents = [];\n        tasksById[current.id] = current;\n      }\n      return tasksById;\n    },\n\n    /**\n     * Make task tree, after reset - look above\n     *\n     * @param {object} task\n     * @returns {object} tasks with children and parents\n     */\n    makeTaskTree(task, tasks) {\n      for (let i = 0, len = tasks.length; i < len; i++) {\n        let current = tasks[i];\n        if (current.parentId === task.id) {\n          if (task.parents.length) {\n            task.parents.forEach(parent => current.parents.push(parent));\n          }\n          if (!task.propertyIsEnumerable('__root')) {\n            current.parents.push(task.id);\n            current.parent = task.id;\n          } else {\n            current.parents = [];\n            current.parent = null;\n          }\n          current = this.makeTaskTree(current, tasks);\n          task.allChildren.push(current.id);\n          task.children.push(current.id);\n          current.allChildren.forEach(childId => task.allChildren.push(childId));\n        }\n      }\n      return task;\n    },\n\n    /**\n     * Get task by id\n     *\n     * @param {any} taskId\n     * @returns {object|null} task\n     */\n    getTask(taskId) {\n      if (typeof this.state.tasksById[taskId] !== 'undefined') {\n        return this.state.tasksById[taskId];\n      }\n      return null;\n    },\n\n    /**\n     * Get children tasks for specified taskId\n     *\n     * @param {any} taskId\n     * @returns {array} children\n     */\n    getChildren(taskId) {\n      return this.state.tasks.filter(task => task.parent === taskId);\n    },\n\n    /**\n     * Is task visible\n     *\n     * @param {Number|String|Task} task\n     */\n    isTaskVisible(task) {\n      if (typeof task === 'number' || typeof task === 'string') {\n        task = this.getTask(task);\n      }\n      for (let i = 0, len = task.parents.length; i < len; i++) {\n        if (this.getTask(task.parents[i]).collapsed) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Get svg\n     *\n     * @returns {string} html svg image of gantt\n     */\n    getSVG() {\n      return this.state.options.mainView.outerHTML;\n    },\n\n    /**\n     * Get image\n     *\n     * @param {string} type image format\n     * @returns {Promise} when resolved returns base64 image string of gantt\n     */\n    getImage(type = 'image/png') {\n      return new Promise(resolve => {\n        const img = new Image();\n        img.onload = () => {\n          const canvas = document.createElement('canvas');\n          canvas.width = this.state.options.mainView.clientWidth;\n          canvas.height = this.state.options.rowsHeight;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          resolve(canvas.toDataURL(type));\n        };\n        img.src = 'data:image/svg+xml,' + encodeURIComponent(this.getSVG());\n      });\n    },\n\n    /**\n     * Get gantt total height\n     *\n     * @returns {number}\n     */\n    getHeight(visibleTasks, outer = false) {\n      let height =\n        visibleTasks.length * (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) +\n        this.state.options.calendar.height +\n        this.state.options.calendar.strokeWidth +\n        this.state.options.calendar.gap;\n      if (outer) {\n        height += this.state.options.scrollBarHeight;\n      }\n      return height;\n    },\n\n    /**\n     * Get one task height\n     *\n     * @returns {number}\n     */\n    getTaskHeight(withStroke = false) {\n      if (withStroke) {\n        return (\n          this.state.options.row.height +\n          this.state.options.chart.grid.horizontal.gap * 2 +\n          this.style['grid-line-horizontal']['stroke-width']\n        );\n      }\n      return this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2;\n    },\n\n    /**\n     * Get specified tasks height\n     *\n     * @returns {number}\n     */\n    getTasksHeight(visibleTasks) {\n      return visibleTasks.length * this.getTaskHeight();\n    },\n\n    /**\n     * Convert time (in milliseconds) to pixel offset inside chart\n     *\n     * @param {int} ms\n     * @returns {number}\n     */\n    timeToPixelOffsetX(ms) {\n      let x = ms - this.state.options.times.firstTime;\n      if (x) {\n        x = x / this.state.options.times.timePerPixel;\n      }\n      return x;\n    },\n\n    /**\n     * Convert pixel offset inside chart to corresponding time offset in milliseconds\n     *\n     * @param {number} pixelOffsetX\n     * @returns {int} milliseconds\n     */\n    pixelOffsetXToTime(pixelOffsetX) {\n      let offset = pixelOffsetX + this.style['grid-line-vertical']['stroke-width'] / 2;\n      return offset * this.state.options.times.timePerPixel + this.state.options.times.firstTime;\n    },\n\n    /**\n     * Determine if element is inside current view port\n     *\n     * @param {number} x - element placement\n     * @param {number} width - element width\n     * @param {int} buffer - or threshold, if element is outside viewport but offset from view port is below this value return true\n     * @returns {boolean}\n     */\n    isInsideViewPort(x, width, buffer = 5000) {\n      return (\n        (x + width + buffer >= this.state.options.scroll.chart.left &&\n          x - buffer <= this.state.options.scroll.chart.right) ||\n        (x - buffer <= this.state.options.scroll.chart.left &&\n          x + width + buffer >= this.state.options.scroll.chart.right)\n      );\n    },\n\n    /**\n     * Chart scroll event handler\n     *\n     * @param {event} ev\n     */\n    onScrollChart(ev) {\n      this._onScrollChart(\n        this.state.refs.chartScrollContainerHorizontal.scrollLeft,\n        this.state.refs.chartScrollContainerVertical.scrollTop\n      );\n    },\n\n    /**\n     * After same as above but with different arguments - normalized\n     *\n     * @param {number} left\n     * @param {number} top\n     */\n    _onScrollChart(left, top) {\n      if (this.state.options.scroll.chart.left === left && this.state.options.scroll.chart.top === top) {\n        return;\n      }\n      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      this.state.options.scroll.chart.left = left;\n      this.state.options.scroll.chart.right = left + chartContainerWidth;\n      this.state.options.scroll.chart.percent = (left / this.state.options.times.totalViewDurationPx) * 100;\n      this.state.options.scroll.chart.top = top;\n      this.state.options.scroll.chart.time = this.pixelOffsetXToTime(left);\n      this.state.options.scroll.chart.timeCenter = this.pixelOffsetXToTime(left + chartContainerWidth / 2);\n      this.state.options.scroll.chart.dateTime.left = dayjs(this.state.options.scroll.chart.time).valueOf();\n      this.state.options.scroll.chart.dateTime.right = dayjs(\n        this.pixelOffsetXToTime(left + this.state.refs.chart.clientWidth)\n      ).valueOf();\n      this.scrollTo(left, top);\n    },\n\n    /**\n     * Scroll current chart to specified time (in milliseconds)\n     *\n     * @param {int} time\n     */\n    scrollToTime(time) {\n      let pos = this.timeToPixelOffsetX(time);\n      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      pos = pos - chartContainerWidth / 2;\n      if (pos > this.state.options.width) {\n        pos = this.state.options.width - chartContainerWidth;\n      }\n      this.scrollTo(pos);\n    },\n\n    /**\n     * Scroll chart or task list to specified pixel values\n     *\n     * @param {number|null} left\n     * @param {number|null} top\n     */\n    scrollTo(left = null, top = null) {\n      if (left !== null) {\n        this.state.refs.chartCalendarContainer.scrollLeft = left;\n        this.state.refs.chartGraphContainer.scrollLeft = left;\n        this.state.refs.chartScrollContainerHorizontal.scrollLeft = left;\n        this.state.options.scroll.left = left;\n      }\n      if (top !== null) {\n        this.state.refs.chartScrollContainerVertical.scrollTop = top;\n        this.state.refs.chartGraph.scrollTop = top;\n        this.state.refs.taskListItems.scrollTop = top;\n        this.state.options.scroll.top = top;\n        this.syncScrollTop();\n      }\n    },\n\n    /**\n     * After some actions like time zoom change we need to recompensate scroll position\n     * so as a result everything will be in same place\n     */\n    fixScrollPos() {\n      this.scrollToTime(this.state.options.scroll.chart.timeCenter);\n    },\n\n    /**\n     * Mouse wheel event handler\n     */\n    onWheelChart(ev) {\n      if (!ev.shiftKey && ev.deltaX === 0) {\n        let top = this.state.options.scroll.top + ev.deltaY;\n        const chartClientHeight = this.state.options.rowsHeight;\n        const scrollHeight = this.state.refs.chartGraph.scrollHeight - chartClientHeight;\n        if (top < 0) {\n          top = 0;\n        } else if (top > scrollHeight) {\n          top = scrollHeight;\n        }\n        this.scrollTo(null, top);\n      } else if (ev.shiftKey && ev.deltaX === 0) {\n        let left = this.state.options.scroll.left + ev.deltaY;\n        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;\n        if (left < 0) {\n          left = 0;\n        } else if (left > scrollWidth) {\n          left = scrollWidth;\n        }\n        this.scrollTo(left);\n      } else {\n        let left = this.state.options.scroll.left + ev.deltaX;\n        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;\n        if (left < 0) {\n          left = 0;\n        } else if (left > scrollWidth) {\n          left = scrollWidth;\n        }\n        this.scrollTo(left);\n      }\n    },\n\n    /**\n     * Time zoom change event handler\n     */\n    onTimeZoomChange(timeZoom) {\n      this.state.options.times.timeZoom = timeZoom;\n      this.recalculateTimes();\n      this.calculateSteps();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Row height change event handler\n     */\n    onRowHeightChange(height) {\n      this.state.options.row.height = height;\n      this.calculateTaskListColumnsDimensions();\n      this.syncScrollTop();\n    },\n\n    /**\n     * Scope change event handler\n     */\n    onScopeChange(value) {\n      this.state.options.scope.before = value;\n      this.state.options.scope.after = value;\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list width change event handler\n     */\n    onTaskListWidthChange(value) {\n      this.state.options.taskList.percent = value;\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list column width change event handler\n     */\n    onTaskListColumnWidthChange() {\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Listen to specified event names\n     */\n    initializeEvents() {\n      this.$on('chart-scroll-horizontal', this.onScrollChart);\n      this.$on('chart-scroll-vertical', this.onScrollChart);\n      this.$on('chart-wheel', this.onWheelChart);\n      this.$on('times-timeZoom-change', this.onTimeZoomChange);\n      this.$on('row-height-change', this.onRowHeightChange);\n      this.$on('scope-change', this.onScopeChange);\n      this.$on('taskList-width-change', this.onTaskListWidthChange);\n      this.$on('taskList-column-width-change', this.onTaskListColumnWidthChange);\n    },\n\n    /**\n     * When some action was performed (scale change for example) - recalculate time variables\n     */\n    recalculateTimes() {\n      let max = this.state.options.times.timeScale * 60;\n      let min = this.state.options.times.timeScale;\n      let steps = max / min;\n      let percent = this.state.options.times.timeZoom / 100;\n      this.state.options.times.timePerPixel =\n        this.state.options.times.timeScale * steps * percent + Math.pow(2, this.state.options.times.timeZoom);\n      this.state.options.times.totalViewDurationMs = dayjs(this.state.options.times.lastTime).diff(\n        this.state.options.times.firstTime,\n        'milliseconds'\n      );\n      this.state.options.times.totalViewDurationPx =\n        this.state.options.times.totalViewDurationMs / this.state.options.times.timePerPixel;\n      this.state.options.width =\n        this.state.options.times.totalViewDurationPx + this.style['grid-line-vertical']['stroke-width'];\n    },\n\n    /**\n     * Initialize time variables\n     */\n    initTimes() {\n      this.state.options.times.firstTime = dayjs(this.state.options.times.firstTaskTime)\n        .locale(this.state.options.locale.name)\n        .startOf('day')\n        .subtract(this.state.options.scope.before, 'days')\n        .startOf('day')\n        .valueOf();\n      this.state.options.times.lastTime = dayjs(this.state.options.times.lastTaskTime)\n        .locale(this.state.options.locale.name)\n        .endOf('day')\n        .add(this.state.options.scope.after, 'days')\n        .endOf('day')\n        .valueOf();\n      this.recalculateTimes();\n    },\n\n    /**\n     * Calculate steps\n     * Steps are days by default\n     * Each step contain information about time offset and pixel offset of this time inside gantt chart\n     */\n    calculateSteps() {\n      const steps = [];\n      const lastMs = dayjs(this.state.options.times.lastTime).valueOf();\n      const currentDate = dayjs(this.state.options.times.firstTime);\n      steps.push({\n        time: currentDate.valueOf(),\n        offset: {\n          ms: 0,\n          px: 0\n        }\n      });\n      for (\n        let currentDate = dayjs(this.state.options.times.firstTime)\n          .add(1, this.state.options.times.stepDuration)\n          .startOf('day');\n        currentDate.valueOf() <= lastMs;\n        currentDate = currentDate.add(1, this.state.options.times.stepDuration).startOf('day')\n      ) {\n        const offsetMs = currentDate.diff(this.state.options.times.firstTime, 'milliseconds');\n        const offsetPx = offsetMs / this.state.options.times.timePerPixel;\n        const step = {\n          time: currentDate.valueOf(),\n          offset: {\n            ms: offsetMs,\n            px: offsetPx\n          }\n        };\n        const previousStep = steps[steps.length - 1];\n        previousStep.width = {\n          ms: offsetMs - previousStep.offset.ms,\n          px: offsetPx - previousStep.offset.px\n        };\n        steps.push(step);\n      }\n      const lastStep = steps[steps.length - 1];\n      lastStep.width = {\n        ms: this.state.options.times.totalViewDurationMs - lastStep.offset.ms,\n        px: this.state.options.times.totalViewDurationPx - lastStep.offset.px\n      };\n      this.state.options.times.steps = steps;\n    },\n\n    /**\n     * Calculate calendar widths - when scale was changed for example\n     */\n    computeCalendarWidths() {\n      this.computeDayWidths();\n      this.computeHourWidths();\n      this.computeMonthWidths();\n    },\n\n    /**\n     * Compute width of calendar hours column widths basing on text widths\n     */\n    computeHourWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--hour'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs('2018-01-01T00:00:00').locale(localeName); // any date will be good for hours\n      let maxWidths = this.state.options.calendar.hour.maxWidths;\n      if (maxWidths.length) {\n        return;\n      }\n      for (let formatName in this.state.options.calendar.hour.format) {\n        maxWidths[formatName] = 0;\n      }\n      for (let hour = 0; hour < 24; hour++) {\n        let widths = { hour };\n        for (let formatName in this.state.options.calendar.hour.format) {\n          const hourFormatted = this.state.options.calendar.hour.format[formatName](currentDate);\n          this.state.options.calendar.hour.formatted[formatName].push(hourFormatted);\n          widths[formatName] = this.state.ctx.measureText(hourFormatted).width;\n        }\n        this.state.options.calendar.hour.widths.push(widths);\n        for (let formatName in this.state.options.calendar.hour.format) {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        }\n        currentDate = currentDate.add(1, 'hour');\n      }\n    },\n\n    /**\n     * Compute calendar days column widths basing on text widths\n     */\n    computeDayWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--day'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs(this.state.options.times.steps[0].time).locale(localeName);\n      let maxWidths = this.state.options.calendar.day.maxWidths;\n      this.state.options.calendar.day.widths = [];\n      Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n        maxWidths[formatName] = 0;\n      });\n      for (let day = 0, daysLen = this.state.options.times.steps.length; day < daysLen; day++) {\n        const widths = {\n          day\n        };\n        Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n          widths[formatName] = this.state.ctx.measureText(\n            this.state.options.calendar.day.format[formatName](currentDate)\n          ).width;\n        });\n        this.state.options.calendar.day.widths.push(widths);\n        Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'day');\n      }\n    },\n\n    /**\n     * Months count\n     *\n     * @description Returns number of different months in specified time range\n     *\n     * @param {number} fromTime - date in ms\n     * @param {number} toTime - date in ms\n     *\n     * @returns {number} different months count\n     */\n    monthsCount(fromTime, toTime) {\n      if (fromTime > toTime) {\n        return 0;\n      }\n      let currentMonth = dayjs(fromTime);\n      let previousMonth = currentMonth.clone();\n      let monthsCount = 1;\n      while (currentMonth.valueOf() <= toTime) {\n        currentMonth = currentMonth.add(1, 'day');\n        if (previousMonth.month() !== currentMonth.month()) {\n          monthsCount++;\n        }\n        previousMonth = currentMonth.clone();\n      }\n      return monthsCount;\n    },\n\n    /**\n     * Compute month calendar columns widths basing on text widths\n     */\n    computeMonthWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--month'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      let maxWidths = this.state.options.calendar.month.maxWidths;\n      this.state.options.calendar.month.widths = [];\n      Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n        maxWidths[formatName] = 0;\n      });\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs(this.state.options.times.firstTime).locale(localeName);\n      const monthsCount = this.monthsCount(this.state.options.times.firstTime, this.state.options.times.lastTime);\n      for (let month = 0; month < monthsCount; month++) {\n        const widths = {\n          month\n        };\n        Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n          widths[formatName] = this.state.ctx.measureText(\n            this.state.options.calendar.month.format[formatName](currentDate)\n          ).width;\n        });\n        this.state.options.calendar.month.widths.push(widths);\n        Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'month');\n      }\n    },\n\n    /**\n     * Prepare time and date variables for gantt\n     */\n    prepareDates() {\n      let firstTaskTime = Number.MAX_SAFE_INTEGER;\n      let lastTaskTime = 0;\n      for (let index = 0, len = this.state.tasks.length; index < len; index++) {\n        let task = this.state.tasks[index];\n        if (task.startTime < firstTaskTime) {\n          firstTaskTime = task.startTime;\n        }\n        if (task.startTime + task.duration > lastTaskTime) {\n          lastTaskTime = task.startTime + task.duration;\n        }\n      }\n      this.state.options.times.firstTaskTime = firstTaskTime;\n      this.state.options.times.lastTaskTime = lastTaskTime;\n      this.state.options.times.firstTime = dayjs(firstTaskTime)\n        .locale(this.state.options.locale.name)\n        .startOf('day')\n        .subtract(this.state.options.scope.before, 'days')\n        .startOf('day')\n        .valueOf();\n      this.state.options.times.lastTime = dayjs(lastTaskTime)\n        .locale(this.state.options.locale.name)\n        .endOf('day')\n        .add(this.state.options.scope.after, 'days')\n        .endOf('day')\n        .valueOf();\n    },\n\n    /**\n     * Setup and calculate everything\n     */\n    setup(itsUpdate = '') {\n      this.initialize(itsUpdate);\n      this.prepareDates();\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.state.options.taskList.width = this.state.options.taskList.columns.reduce(\n        (prev, current) => {\n          return { width: prev.width + current.width };\n        },\n        { width: 0 }\n      ).width;\n    },\n\n    /**\n     * Global resize event (from window.addEventListener)\n     */\n    globalOnResize() {\n      if (typeof this.$el === 'undefined' || !this.$el) {\n        return;\n      }\n      this.state.options.clientWidth = this.$el.clientWidth;\n      if (\n        this.state.options.taskList.widthFromPercentage >\n        (this.state.options.clientWidth / 100) * this.state.options.taskList.widthThreshold\n      ) {\n        const diff =\n          this.state.options.taskList.widthFromPercentage -\n          (this.state.options.clientWidth / 100) * this.state.options.taskList.widthThreshold;\n        let diffPercent = 100 - (diff / this.state.options.taskList.widthFromPercentage) * 100;\n        if (diffPercent < 0) {\n          diffPercent = 0;\n        }\n        this.state.options.taskList.columns.forEach(column => {\n          column.thresholdPercent = diffPercent;\n        });\n      } else {\n        this.state.options.taskList.columns.forEach(column => {\n          column.thresholdPercent = 100;\n        });\n      }\n      this.calculateTaskListColumnsDimensions();\n      this.$emit('calendar-recalculate');\n      this.syncScrollTop();\n    }\n  },\n\n  computed: {\n    /**\n     * Get visible tasks\n     * Very important method which will bring us only those tasks that are visible inside gantt chart\n     * For example when task is collapsed - children of this task are not visible - we should not render them\n     */\n    visibleTasks() {\n      const visibleTasks = this.state.tasks.filter(task => this.isTaskVisible(task));\n      const maxRows = visibleTasks.slice(0, this.state.options.maxRows);\n      this.state.options.rowsHeight = this.getTasksHeight(maxRows);\n      let heightCompensation = 0;\n      if (this.state.options.maxHeight && this.state.options.rowsHeight > this.state.options.maxHeight) {\n        heightCompensation = this.state.options.rowsHeight - this.state.options.maxHeight;\n        this.state.options.rowsHeight = this.state.options.maxHeight;\n      }\n      this.state.options.height = this.getHeight(maxRows) - heightCompensation;\n      this.state.options.allVisibleTasksHeight = this.getTasksHeight(visibleTasks);\n      this.state.options.outerHeight = this.getHeight(maxRows, true) - heightCompensation;\n      let len = visibleTasks.length;\n      for (let index = 0; index < len; index++) {\n        let task = visibleTasks[index];\n        task.width =\n          task.duration / this.state.options.times.timePerPixel - this.style['grid-line-vertical']['stroke-width'];\n        if (task.width < 0) {\n          task.width = 0;\n        }\n        task.height = this.state.options.row.height;\n        task.x = this.timeToPixelOffsetX(task.startTime);\n        task.y =\n          (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) * index +\n          this.state.options.chart.grid.horizontal.gap;\n      }\n      return visibleTasks;\n    },\n\n    /**\n     * Style shortcut\n     */\n    style() {\n      return this.state.dynamicStyle;\n    },\n\n    /**\n     * Get columns and compute dimensions on the fly\n     */\n    getTaskListColumns() {\n      this.calculateTaskListColumnsDimensions();\n      return this.state.options.taskList.columns;\n    },\n\n    /**\n     * Tasks used for communicate with parent component\n     */\n    outputTasks() {\n      return this.state.tasks;\n    },\n\n    /**\n     * Options used to communicate with parent component\n     */\n    outputOptions() {\n      return this.state.options;\n    }\n  },\n\n  /**\n   * Watch tasks after gantt instance is created and react when we have new kids on the block\n   */\n  created() {\n    this.initializeEvents();\n    this.setup();\n    this.state.unwatchTasks = this.$watch(\n      'tasks',\n      tasks => {\n        const notEqual = notEqualDeep(tasks, this.outputTasks);\n        if (notEqual) {\n          this.setup('tasks');\n        }\n      },\n      { deep: true }\n    );\n    this.state.unwatchOptions = this.$watch(\n      'options',\n      opts => {\n        const notEqual = notEqualDeep(opts, this.outputOptions);\n        if (notEqual) {\n          this.setup('options');\n        }\n      },\n      { deep: true }\n    );\n    this.state.unwatchStyle = this.$watch(\n      'dynamicStyle',\n      style => {\n        const notEqual = notEqualDeep(style, this.dynamicStyle);\n        if (notEqual) {\n          this.initializeStyle();\n        }\n      },\n      { deep: true, immediate: true }\n    );\n\n    this.state.unwatchOutputTasks = this.$watch(\n      'outputTasks',\n      tasks => {\n        this.$emit('tasks-changed', tasks.map(task => task));\n      },\n      { deep: true }\n    );\n    this.state.unwatchOutputOptions = this.$watch(\n      'outputOptions',\n      options => {\n        this.$emit('options-changed', mergeDeep({}, options));\n      },\n      { deep: true }\n    );\n    this.state.unwatchOutputStyle = this.$watch(\n      'style',\n      style => {\n        this.$emit('dynamic-style-changed', mergeDeep({}, style));\n      },\n      { deep: true }\n    );\n\n    this.$root.$emit('gantt-elastic-created', this);\n    this.$emit('created', this);\n  },\n\n  /**\n   * Emit before-mount event\n   */\n  beforeMount() {\n    this.$emit('before-mount', this);\n  },\n\n  /**\n   * Emit ready/mounted events and deliver this gantt instance to outside world when needed\n   */\n  mounted() {\n    this.state.options.clientWidth = this.$el.clientWidth;\n    this.state.resizeObserver = new ResizeObserver((entries, observer) => {\n      this.globalOnResize();\n    });\n    this.state.resizeObserver.observe(this.$el.parentNode);\n    this.globalOnResize();\n    this.$emit('ready', this);\n    this.$root.$emit('gantt-elastic-mounted', this);\n    this.$emit('mounted', this);\n    this.$root.$emit('gantt-elastic-ready', this);\n  },\n\n  /**\n   * Emit event when data was changed and before update (you can cleanup dom events here for example)\n   */\n  beforeUpdate() {\n    this.$emit('before-update');\n  },\n\n  /**\n   * Emit event when gantt-elastic view was updated\n   */\n  updated() {\n    this.$nextTick(() => {\n      this.$emit('updated');\n    });\n  },\n\n  /**\n   * Before destroy event - clean up\n   */\n  beforeDestroy() {\n    this.state.resizeObserver.unobserve(this.$el.parentNode);\n    this.state.unwatchTasks();\n    this.state.unwatchOptions();\n    this.state.unwatchStyle();\n    this.state.unwatchOutputTasks();\n    this.state.unwatchOutputOptions();\n    this.state.unwatchOutputStyle();\n    this.$emit('before-destroy');\n  },\n\n  /**\n   * Emit event after gantt-elastic was destroyed\n   */\n  destroyed() {\n    this.$emit('destroyed');\n  }\n};\nexport default GanttElastic;\n</script>\n\n<style>\n[class^='gantt-elastic'],\n[class*=' gantt-elastic'] {\n  box-sizing: border-box;\n}\n.gantt-elastic__main-view svg {\n  display: block;\n}\n.gantt-elastic__grid-horizontal-line,\n.gantt-elastic__grid-vertical-line {\n  stroke: #a0a0a0;\n  stroke-width: 1;\n}\nforeignObject > * {\n  margin: 0px;\n}\n.gantt-elastic .p-2 {\n  padding: 10rem;\n}\n.gantt-elastic__main-view-main-container,\n.gantt-elastic__main-view-container {\n  overflow: hidden;\n  max-width: 100%;\n}\n.gantt-elastic__task-list-header-column:last-of-type {\n  border-right: 1px solid #00000050;\n}\n.gantt-elastic__task-list-item:last-of-type {\n  border-bottom: 1px solid #00000050;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover {\n  overflow: visible !important;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover > .gantt-elastic__task-list-item-value-container {\n  position: relative;\n  overflow: visible !important;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover > .gantt-elastic__task-list-item-value {\n  position: absolute;\n}\n</style>\n"]}]}