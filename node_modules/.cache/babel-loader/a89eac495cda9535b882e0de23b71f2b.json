{"remainingRequest":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_babel-loader@8.2.5@babel-loader/lib/index.js!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--1-0!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js??vue-loader-options!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/components/Calendar/Calendar.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/components/Calendar/Calendar.vue","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/babel.config.js","mtime":1658370777000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_babel-loader@8.2.5@babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js","mtime":1655715099000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IGRheWpzIGZyb20gJ2RheWpzJzsKaW1wb3J0IENhbGVuZGFyUm93IGZyb20gJy4vQ2FsZW5kYXJSb3cudnVlJzsKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdDYWxlbmRhcicsCiAgY29tcG9uZW50czogewogICAgQ2FsZW5kYXJSb3cKICB9LAogIGluamVjdDogWydyb290J10sCgogIGRhdGEoKSB7CiAgICByZXR1cm4ge307CiAgfSwKCiAgbWV0aG9kczogewogICAgLyoqCiAgICAgKiBIb3cgbWFueSBob3VycyB3aWxsIGZpdD8KICAgICAqCiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fQogICAgICovCiAgICBob3dNYW55SG91cnNGaXQoZGF5SW5kZXgpIHsKICAgICAgY29uc3Qgc3Ryb2tlID0gMTsKICAgICAgY29uc3QgYWRkaXRpb25hbFNwYWNlID0gc3Ryb2tlICsgMjsKICAgICAgbGV0IGZ1bGxDZWxsV2lkdGggPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwc1tkYXlJbmRleF0ud2lkdGgucHg7CiAgICAgIGxldCBmb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuZm9ybWF0KTsKCiAgICAgIGZvciAobGV0IGhvdXJzID0gMjQ7IGhvdXJzID4gMTsgaG91cnMgPSBNYXRoLmNlaWwoaG91cnMgLyAyKSkgewogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgb2YgZm9ybWF0TmFtZXMpIHsKICAgICAgICAgIGlmICgodGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5tYXhXaWR0aHNbZm9ybWF0TmFtZV0gKyBhZGRpdGlvbmFsU3BhY2UpICogaG91cnMgPD0gZnVsbENlbGxXaWR0aCAmJiBob3VycyA+IDEpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBjb3VudDogaG91cnMsCiAgICAgICAgICAgICAgdHlwZTogZm9ybWF0TmFtZQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBjb3VudDogMCwKICAgICAgICB0eXBlOiAnJwogICAgICB9OwogICAgfSwKCiAgICAvKioKICAgICAqIEhvdyBtYW55IGRheXMgd2lsbCBmaXQ/CiAgICAgKgogICAgICogQHJldHVybnMge29iamVjdH0KICAgICAqLwogICAgaG93TWFueURheXNGaXQoKSB7CiAgICAgIGNvbnN0IHN0cm9rZSA9IDE7CiAgICAgIGNvbnN0IGFkZGl0aW9uYWxTcGFjZSA9IHN0cm9rZSArIDI7CiAgICAgIGxldCBmdWxsV2lkdGggPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy53aWR0aDsKICAgICAgbGV0IGZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LmZvcm1hdCk7CgogICAgICBmb3IgKGxldCBkYXlzID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcHMubGVuZ3RoOyBkYXlzID4gMTsgZGF5cyA9IE1hdGguY2VpbChkYXlzIC8gMikpIHsKICAgICAgICBmb3IgKGxldCBmb3JtYXROYW1lIG9mIGZvcm1hdE5hbWVzKSB7CiAgICAgICAgICBpZiAoKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5tYXhXaWR0aHNbZm9ybWF0TmFtZV0gKyBhZGRpdGlvbmFsU3BhY2UpICogZGF5cyA8PSBmdWxsV2lkdGggJiYgZGF5cyA+IDEpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBjb3VudDogZGF5cywKICAgICAgICAgICAgICB0eXBlOiBmb3JtYXROYW1lCiAgICAgICAgICAgIH07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gewogICAgICAgIGNvdW50OiAwLAogICAgICAgIHR5cGU6ICcnCiAgICAgIH07CiAgICB9LAoKICAgIC8qKgogICAgICogSG93IG1hbnkgbW9udGhzIHdpbGwgZml0PwogICAgICoKICAgICAqIEByZXR1cm5zIHtvYmplY3R9CiAgICAgKi8KICAgIGhvd01hbnlNb250aHNGaXQoKSB7CiAgICAgIGNvbnN0IHN0cm9rZSA9IDE7CiAgICAgIGNvbnN0IGFkZGl0aW9uYWxTcGFjZSA9IHN0cm9rZSArIDI7CiAgICAgIGxldCBmdWxsV2lkdGggPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy53aWR0aDsKICAgICAgbGV0IGZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGguZm9ybWF0KTsKICAgICAgbGV0IGN1cnJlbnRNb250aCA9IGRheWpzKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSk7CiAgICAgIGxldCBwcmV2aW91c01vbnRoID0gY3VycmVudE1vbnRoLmNsb25lKCk7CiAgICAgIGNvbnN0IGxhc3RUaW1lID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWU7CiAgICAgIGxldCBtb250aHNDb3VudCA9IHRoaXMucm9vdC5tb250aHNDb3VudCh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRpbWUsIHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lKTsKCiAgICAgIGlmIChtb250aHNDb3VudCA9PT0gMSkgewogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgb2YgZm9ybWF0TmFtZXMpIHsKICAgICAgICAgIGlmICh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5tYXhXaWR0aHNbZm9ybWF0TmFtZV0gKyBhZGRpdGlvbmFsU3BhY2UgPD0gZnVsbFdpZHRoKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgY291bnQ6IDEsCiAgICAgICAgICAgICAgdHlwZTogZm9ybWF0TmFtZQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgZm9yIChsZXQgbW9udGhzID0gbW9udGhzQ291bnQ7IG1vbnRocyA+IDE7IG1vbnRocyA9IE1hdGguY2VpbChtb250aHMgLyAyKSkgewogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgb2YgZm9ybWF0TmFtZXMpIHsKICAgICAgICAgIGlmICgodGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGgubWF4V2lkdGhzW2Zvcm1hdE5hbWVdICsgYWRkaXRpb25hbFNwYWNlKSAqIG1vbnRocyA8PSBmdWxsV2lkdGggJiYgbW9udGhzID4gMSkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgIGNvdW50OiBtb250aHMsCiAgICAgICAgICAgICAgdHlwZTogZm9ybWF0TmFtZQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBjb3VudDogMCwKICAgICAgICB0eXBlOiBmb3JtYXROYW1lc1swXQogICAgICB9OwogICAgfSwKCiAgICAvKioKICAgICAqIEdlbmVyYXRlIGhvdXJzCiAgICAgKgogICAgICogQHJldHVybnMge2FycmF5fQogICAgICovCiAgICBnZW5lcmF0ZUhvdXJzKCkgewogICAgICBsZXQgYWxsSG91cnMgPSBbXTsKCiAgICAgIGlmICghdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5kaXNwbGF5KSB7CiAgICAgICAgcmV0dXJuIGFsbEhvdXJzOwogICAgICB9CgogICAgICBjb25zdCBzdGVwcyA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBzOwogICAgICBjb25zdCBsb2NhbGVOYW1lID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMubG9jYWxlLm5hbWU7CgogICAgICBmb3IgKGxldCBob3VySW5kZXggPSAwLCBsZW4gPSBzdGVwcy5sZW5ndGg7IGhvdXJJbmRleCA8IGxlbjsgaG91ckluZGV4KyspIHsKICAgICAgICBjb25zdCBob3Vyc0NvdW50ID0gdGhpcy5ob3dNYW55SG91cnNGaXQoaG91ckluZGV4KTsKCiAgICAgICAgaWYgKGhvdXJzQ291bnQuY291bnQgPT09IDApIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KCiAgICAgICAgY29uc3QgaG91cnMgPSB7CiAgICAgICAgICBrZXk6IGhvdXJJbmRleCArICdzdGVwJywKICAgICAgICAgIGNoaWxkcmVuOiBbXQogICAgICAgIH07CiAgICAgICAgY29uc3QgaG91clN0ZXAgPSAyNCAvIGhvdXJzQ291bnQuY291bnQ7CiAgICAgICAgY29uc3QgaG91cldpZHRoUHggPSBzdGVwc1tob3VySW5kZXhdLndpZHRoLnB4IC8gaG91cnNDb3VudC5jb3VudDsKCiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhvdXJzQ291bnQuY291bnQ7IGkgPCBsZW47IGkrKykgewogICAgICAgICAgY29uc3QgaG91ciA9IGkgKiBob3VyU3RlcDsKICAgICAgICAgIGxldCBpbmRleCA9IGhvdXJJbmRleDsKCiAgICAgICAgICBpZiAoaG91ckluZGV4ID4gMCkgewogICAgICAgICAgICBpbmRleCA9IGhvdXJJbmRleCAtIE1hdGguZmxvb3IoaG91ckluZGV4IC8gMjQpICogMjQ7CiAgICAgICAgICB9CgogICAgICAgICAgbGV0IHRleHRXaWR0aCA9IDA7CgogICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLndpZHRoc1tpbmRleF0gIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIud2lkdGhzW2luZGV4XVtob3Vyc0NvdW50LnR5cGVdOwogICAgICAgICAgfQoKICAgICAgICAgIGxldCB4ID0gc3RlcHNbaG91ckluZGV4XS5vZmZzZXQucHggKyBob3VyV2lkdGhQeCAqIGk7CiAgICAgICAgICBob3Vycy5jaGlsZHJlbi5wdXNoKHsKICAgICAgICAgICAgaW5kZXg6IGhvdXJJbmRleCwKICAgICAgICAgICAga2V5OiAnaCcgKyBpLAogICAgICAgICAgICB4LAogICAgICAgICAgICB5OiB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuaGVpZ2h0ICsgdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGguaGVpZ2h0LAogICAgICAgICAgICB3aWR0aDogaG91cldpZHRoUHgsCiAgICAgICAgICAgIHRleHRXaWR0aCwKICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLmhlaWdodCwKICAgICAgICAgICAgbGFiZWw6IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuZm9ybWF0dGVkW2hvdXJzQ291bnQudHlwZV1baG91cl0KICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgYWxsSG91cnMucHVzaChob3Vycyk7CiAgICAgIH0KCiAgICAgIHJldHVybiBhbGxIb3VyczsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZW5lcmF0ZSBkYXlzCiAgICAgKgogICAgICogQHJldHVybnMge2FycmF5fQogICAgICovCiAgICBnZW5lcmF0ZURheXMoKSB7CiAgICAgIGxldCBkYXlzID0gW107CgogICAgICBpZiAoIXRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5kaXNwbGF5KSB7CiAgICAgICAgcmV0dXJuIGRheXM7CiAgICAgIH0KCiAgICAgIGNvbnN0IGRheXNDb3VudCA9IHRoaXMuaG93TWFueURheXNGaXQoKTsKCiAgICAgIGlmIChkYXlzQ291bnQuY291bnQgPT09IDApIHsKICAgICAgICByZXR1cm4gZGF5czsKICAgICAgfQoKICAgICAgY29uc3Qgc3RlcHMgPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwczsKICAgICAgY29uc3QgbG9jYWxlTmFtZSA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lOwogICAgICBjb25zdCBkYXlTdGVwID0gTWF0aC5jZWlsKHN0ZXBzLmxlbmd0aCAvIGRheXNDb3VudC5jb3VudCk7CgogICAgICBmb3IgKGxldCBkYXlJbmRleCA9IDAsIGxlbiA9IHN0ZXBzLmxlbmd0aDsgZGF5SW5kZXggPCBsZW47IGRheUluZGV4ICs9IGRheVN0ZXApIHsKICAgICAgICBsZXQgZGF5V2lkdGhQeCA9IDA7IC8vIGRheSBjb3VsZCBiZSBzaG9ydGVyIChkYXlsaWdodCBzYXZpbmcgdGltZSkgc28gam9pbiB3aWR0aHMgYW5kIGRpdmlkZQoKICAgICAgICBmb3IgKGxldCBjdXJyZW50U3RlcCA9IDA7IGN1cnJlbnRTdGVwIDwgZGF5U3RlcDsgY3VycmVudFN0ZXArKykgewogICAgICAgICAgaWYgKHR5cGVvZiBzdGVwc1tkYXlJbmRleCArIGN1cnJlbnRTdGVwXSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgZGF5V2lkdGhQeCArPSBzdGVwc1tkYXlJbmRleCArIGN1cnJlbnRTdGVwXS53aWR0aC5weDsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGNvbnN0IGRhdGUgPSBkYXlqcyhzdGVwc1tkYXlJbmRleF0udGltZSk7CiAgICAgICAgbGV0IHRleHRXaWR0aCA9IDA7CgogICAgICAgIGlmICh0eXBlb2YgdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LndpZHRoc1tkYXlJbmRleF0gIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkud2lkdGhzW2RheUluZGV4XVtkYXlzQ291bnQudHlwZV07CiAgICAgICAgfQoKICAgICAgICBsZXQgeCA9IHN0ZXBzW2RheUluZGV4XS5vZmZzZXQucHg7CiAgICAgICAgZGF5cy5wdXNoKHsKICAgICAgICAgIGluZGV4OiBkYXlJbmRleCwKICAgICAgICAgIGtleTogc3RlcHNbZGF5SW5kZXhdLnRpbWUgKyAnZCcsCiAgICAgICAgICB4LAogICAgICAgICAgeTogdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGguaGVpZ2h0LAogICAgICAgICAgd2lkdGg6IGRheVdpZHRoUHgsCiAgICAgICAgICB0ZXh0V2lkdGgsCiAgICAgICAgICBoZWlnaHQ6IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5oZWlnaHQsCiAgICAgICAgICBsYWJlbDogdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LmZvcm1hdFtkYXlzQ291bnQudHlwZV0oZGF0ZS5sb2NhbGUobG9jYWxlTmFtZSkpCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBkYXlzLm1hcChpdGVtID0+ICh7CiAgICAgICAga2V5OiBpdGVtLmtleSwKICAgICAgICBjaGlsZHJlbjogW2l0ZW1dCiAgICAgIH0pKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZW5lcmF0ZSBtb250aHMKICAgICAqCiAgICAgKiBAcmV0dXJucyB7YXJyYXl9CiAgICAgKi8KICAgIGdlbmVyYXRlTW9udGhzKCkgewogICAgICBsZXQgbW9udGhzID0gW107CgogICAgICBpZiAoIXRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmRpc3BsYXkpIHsKICAgICAgICByZXR1cm4gbW9udGhzOwogICAgICB9CgogICAgICBjb25zdCBtb250aHNDb3VudCA9IHRoaXMuaG93TWFueU1vbnRoc0ZpdCgpOwoKICAgICAgaWYgKG1vbnRoc0NvdW50LmNvdW50ID09PSAwKSB7CiAgICAgICAgcmV0dXJuIG1vbnRoczsKICAgICAgfQoKICAgICAgY29uc3Qgc3RlcHMgPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwczsKICAgICAgY29uc3QgbG9jYWxlTmFtZSA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lOwogICAgICBsZXQgZm9ybWF0TmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5mb3JtYXQpOwogICAgICBsZXQgY3VycmVudERhdGUgPSBkYXlqcyh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRpbWUpOwoKICAgICAgZm9yIChsZXQgbW9udGhJbmRleCA9IDA7IG1vbnRoSW5kZXggPCBtb250aHNDb3VudC5jb3VudDsgbW9udGhJbmRleCsrKSB7CiAgICAgICAgbGV0IG1vbnRoV2lkdGggPSAwOwogICAgICAgIGxldCBtb250aE9mZnNldCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOwogICAgICAgIGxldCBmaW5hbERhdGUgPSBkYXlqcyhjdXJyZW50RGF0ZSkuYWRkKDEsICdtb250aCcpLnN0YXJ0T2YoJ21vbnRoJyk7CgogICAgICAgIGlmIChmaW5hbERhdGUudmFsdWVPZigpID4gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWUpIHsKICAgICAgICAgIGZpbmFsRGF0ZSA9IGRheWpzKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lKTsKICAgICAgICB9IC8vIHdlIG11c3QgZmluZCBmaXJzdCBhbmQgbGFzdCBzdGVwIHRvIGdldCB0aGUgb2Zmc2V0cyAvIHdpZHRocwoKCiAgICAgICAgZm9yIChsZXQgc3RlcCA9IDAsIGxlbiA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBzLmxlbmd0aDsgc3RlcCA8IGxlbjsgc3RlcCsrKSB7CiAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwc1tzdGVwXTsKCiAgICAgICAgICBpZiAoY3VycmVudFN0ZXAudGltZSA+PSBjdXJyZW50RGF0ZS52YWx1ZU9mKCkgJiYgY3VycmVudFN0ZXAudGltZSA8IGZpbmFsRGF0ZS52YWx1ZU9mKCkpIHsKICAgICAgICAgICAgbW9udGhXaWR0aCArPSBjdXJyZW50U3RlcC53aWR0aC5weDsKCiAgICAgICAgICAgIGlmIChjdXJyZW50U3RlcC5vZmZzZXQucHggPCBtb250aE9mZnNldCkgewogICAgICAgICAgICAgIG1vbnRoT2Zmc2V0ID0gY3VycmVudFN0ZXAub2Zmc2V0LnB4OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBsZXQgbGFiZWwgPSAnJzsKICAgICAgICBsZXQgY2hvb3NlbkZvcm1hdE5hbWU7CgogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgb2YgZm9ybWF0TmFtZXMpIHsKICAgICAgICAgIGlmICh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5tYXhXaWR0aHNbZm9ybWF0TmFtZV0gKyAyIDw9IG1vbnRoV2lkdGgpIHsKICAgICAgICAgICAgbGFiZWwgPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5mb3JtYXRbZm9ybWF0TmFtZV0oY3VycmVudERhdGUubG9jYWxlKGxvY2FsZU5hbWUpKTsKICAgICAgICAgICAgY2hvb3NlbkZvcm1hdE5hbWUgPSBmb3JtYXROYW1lOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgbGV0IHRleHRXaWR0aCA9IDA7CgogICAgICAgIGlmICh0eXBlb2YgdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGgud2lkdGhzW21vbnRoSW5kZXhdICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGgud2lkdGhzW21vbnRoSW5kZXhdW2Nob29zZW5Gb3JtYXROYW1lXTsKICAgICAgICB9CgogICAgICAgIGxldCB4ID0gbW9udGhPZmZzZXQ7CiAgICAgICAgbW9udGhzLnB1c2goewogICAgICAgICAgaW5kZXg6IG1vbnRoSW5kZXgsCiAgICAgICAgICBrZXk6IG1vbnRoSW5kZXggKyAnbScsCiAgICAgICAgICB4LAogICAgICAgICAgeTogMCwKICAgICAgICAgIHdpZHRoOiBtb250aFdpZHRoLAogICAgICAgICAgdGV4dFdpZHRoLAogICAgICAgICAgY2hvb3NlbkZvcm1hdE5hbWUsCiAgICAgICAgICBoZWlnaHQ6IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmhlaWdodCwKICAgICAgICAgIGxhYmVsCiAgICAgICAgfSk7CiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZS5hZGQoMSwgJ21vbnRoJykuc3RhcnRPZignbW9udGgnKTsKCiAgICAgICAgaWYgKGN1cnJlbnREYXRlLnZhbHVlT2YoKSA+IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lKSB7CiAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRheWpzKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBtb250aHMubWFwKGl0ZW0gPT4gKHsKICAgICAgICBrZXk6IGl0ZW0ua2V5LAogICAgICAgIGNoaWxkcmVuOiBbaXRlbV0KICAgICAgfSkpOwogICAgfSwKCiAgICAvKioKICAgICAqIFN1bSBhbGwgY2FsZW5kYXIgcm93cyBoZWlnaHQgYW5kIHJldHVybiByZXN1bHQKICAgICAqCiAgICAgKiBAcmV0dXJucyB7aW50fQogICAgICovCiAgICBjYWxjdWxhdGVDYWxlbmRhckRpbWVuc2lvbnMoewogICAgICBob3VycywKICAgICAgZGF5cywKICAgICAgbW9udGhzCiAgICB9KSB7CiAgICAgIGxldCBoZWlnaHQgPSAwOwoKICAgICAgaWYgKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuZGlzcGxheSAmJiBob3Vycy5sZW5ndGggPiAwKSB7CiAgICAgICAgaGVpZ2h0ICs9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuaGVpZ2h0OwogICAgICB9CgogICAgICBpZiAodGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LmRpc3BsYXkgJiYgZGF5cy5sZW5ndGggPiAwKSB7CiAgICAgICAgaGVpZ2h0ICs9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5oZWlnaHQ7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5kaXNwbGF5ICYmIG1vbnRocy5sZW5ndGggPiAwKSB7CiAgICAgICAgaGVpZ2h0ICs9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmhlaWdodDsKICAgICAgfQoKICAgICAgdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaGVpZ2h0ID0gaGVpZ2h0OwogICAgfQoKICB9LAogIGNvbXB1dGVkOiB7CiAgICBkYXRlcygpIHsKICAgICAgY29uc3QgaG91cnMgPSB0aGlzLmdlbmVyYXRlSG91cnMoKTsKICAgICAgY29uc3QgZGF5cyA9IHRoaXMuZ2VuZXJhdGVEYXlzKCk7CiAgICAgIGNvbnN0IG1vbnRocyA9IHRoaXMuZ2VuZXJhdGVNb250aHMoKTsKICAgICAgY29uc3QgYWxsRGF0ZXMgPSB7CiAgICAgICAgaG91cnMsCiAgICAgICAgZGF5cywKICAgICAgICBtb250aHMKICAgICAgfTsKICAgICAgdGhpcy5jYWxjdWxhdGVDYWxlbmRhckRpbWVuc2lvbnMoYWxsRGF0ZXMpOwogICAgICByZXR1cm4gYWxsRGF0ZXM7CiAgICB9CgogIH0KfTs="},{"version":3,"mappings":"AAsBA;AACA;AAEA;EACAA,gBADA;EAEAC;IACAC;EADA,CAFA;EAKAC,gBALA;;EAMAC;IACA;EACA,CARA;;EAUAC;IACA;AACA;AACA;AACA;AACA;IACAC;MACA;MACA;MACA;MACA;;MACA;QACA;UACA,IACA,4GACAC,SAFA,EAGA;YACA;cACAC,YADA;cAEAC;YAFA;UAIA;QACA;MACA;;MACA;QACAD,QADA;QAEAC;MAFA;IAIA,CA5BA;;IA8BA;AACA;AACA;AACA;AACA;IACAC;MACA;MACA;MACA;MACA;;MACA;QACA;UACA,IACA,sGACAC,QAFA,EAGA;YACA;cACAH,WADA;cAEAC;YAFA;UAIA;QACA;MACA;;MACA;QACAD,QADA;QAEAC;MAFA;IAIA,CAzDA;;IA2DA;AACA;AACA;AACA;AACA;IACAG;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,wCACA,uCADA,EAEA,sCAFA;;MAIA;QACA;UACA;YACA;cACAJ,QADA;cAEAC;YAFA;UAIA;QACA;MACA;;MACA;QACA;UACA,IACA,0GACAI,UAFA,EAGA;YACA;cACAL,aADA;cAEAC;YAFA;UAIA;QACA;MACA;;MACA;QACAD,QADA;QAEAC;MAFA;IAIA,CAvGA;;IAyGA;AACA;AACA;AACA;AACA;IACAK;MACA;;MACA;QACA;MACA;;MACA;MACA;;MACA;QACA;;QACA;UACA;QACA;;QACA;UAAAC;UAAAC;QAAA;QACA;QACA;;QACA;UACA;UACA;;UACA;YACAC;UACA;;UACA;;UACA;YACAC;UACA;;UACA;UACAX;YACAU,gBADA;YAEAF,YAFA;YAGAI,CAHA;YAIAC,8FAJA;YAKAC,kBALA;YAMAH,SANA;YAOAI,oDAPA;YAQAC;UARA;QAUA;;QACAC;MACA;;MACA;IACA,CAtJA;;IAwJA;AACA;AACA;AACA;AACA;IACAC;MACA;;MACA;QACA;MACA;;MACA;;MACA;QACA;MACA;;MACA;MACA;MACA;;MACA;QACA,mBADA,CAEA;;QACA;UACA;YACAC;UACA;QACA;;QACA;QACA;;QACA;UACAR;QACA;;QACA;QACAP;UACAM,eADA;UAEAF,+BAFA;UAGAI,CAHA;UAIAC,gDAJA;UAKAC,iBALA;UAMAH,SANA;UAOAI,mDAPA;UAQAC;QARA;MAUA;;MACA;QACAR,aADA;QAEAC;MAFA;IAIA,CAtMA;;IAwMA;AACA;AACA;AACA;AACA;IACAW;MACA;;MACA;QACA;MACA;;MACA;;MACA;QACA;MACA;;MACA;MACA;MACA;MACA;;MACA;QACA;QACA;QACA,mCACAC,GADA,CACA,CADA,EACA,OADA,EAEAC,OAFA,CAEA,OAFA;;QAGA;UACAC;QACA,CARA,CASA;;;QACA;UACA;;UACA;YACAC;;YACA;cACAC;YACA;UACA;QACA;;QACA;QACA;;QACA;UACA;YACAT;YACAU;UACA;QACA;;QACA;;QACA;UACAf;QACA;;QACA;QACAL;UACAI,iBADA;UAEAF,qBAFA;UAGAI,CAHA;UAIAC,IAJA;UAKAC,iBALA;UAMAH,SANA;UAOAe,iBAPA;UAQAX,qDARA;UASAC;QATA;QAWAW;;QACA;UACAA;QACA;MACA;;MACA;QACAnB,aADA;QAEAC;MAFA;IAIA,CA9QA;;IAgRA;AACA;AACA;AACA;AACA;IACAmB;MAAA5B;MAAAI;MAAAE;IAAA;MACA;;MACA;QACAS;MACA;;MACA;QACAA;MACA;;MACA;QACAA;MACA;;MACA;IACA;;EAjSA,CAVA;EA8SAc;IACAC;MACA;MACA;MACA;MACA;QAAA9B;QAAAI;QAAAE;MAAA;MACA;MACA;IACA;;EARA;AA9SA","names":["name","components","CalendarRow","inject","data","methods","howManyHoursFit","hours","count","type","howManyDaysFit","days","howManyMonthsFit","months","generateHours","key","children","index","textWidth","x","y","width","height","label","allHours","generateDays","dayWidthPx","generateMonths","add","startOf","finalDate","monthWidth","monthOffset","choosenFormatName","currentDate","calculateCalendarDimensions","computed","dates"],"sourceRoot":"node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/components/Calendar","sources":["Calendar.vue"],"sourcesContent":["<!--\n/**\n * @fileoverview Calendar component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <div\n    class=\"gantt-elastic__calendar-wrapper\"\n    :style=\"{ ...root.style['calendar-wrapper'], width: root.state.options.width + 'px' }\"\n  >\n    <div class=\"gantt-elastic__calendar\" :style=\"{ ...root.style['calendar'], width: root.state.options.width + 'px' }\">\n      <calendar-row :items=\"dates.months\" which=\"month\" v-if=\"root.state.options.calendar.month.display\"></calendar-row>\n      <calendar-row :items=\"dates.days\" which=\"day\" v-if=\"root.state.options.calendar.day.display\"></calendar-row>\n      <calendar-row :items=\"dates.hours\" which=\"hour\" v-if=\"root.state.options.calendar.hour.display\"></calendar-row>\n    </div>\n  </div>\n</template>\n\n<script>\nimport dayjs from 'dayjs';\nimport CalendarRow from './CalendarRow.vue';\n\nexport default {\n  name: 'Calendar',\n  components: {\n    CalendarRow\n  },\n  inject: ['root'],\n  data() {\n    return {};\n  },\n\n  methods: {\n    /**\n     * How many hours will fit?\n     *\n     * @returns {object}\n     */\n    howManyHoursFit(dayIndex) {\n      const stroke = 1;\n      const additionalSpace = stroke + 2;\n      let fullCellWidth = this.root.state.options.times.steps[dayIndex].width.px;\n      let formatNames = Object.keys(this.root.state.options.calendar.hour.format);\n      for (let hours = 24; hours > 1; hours = Math.ceil(hours / 2)) {\n        for (let formatName of formatNames) {\n          if (\n            (this.root.state.options.calendar.hour.maxWidths[formatName] + additionalSpace) * hours <= fullCellWidth &&\n            hours > 1\n          ) {\n            return {\n              count: hours,\n              type: formatName\n            };\n          }\n        }\n      }\n      return {\n        count: 0,\n        type: ''\n      };\n    },\n\n    /**\n     * How many days will fit?\n     *\n     * @returns {object}\n     */\n    howManyDaysFit() {\n      const stroke = 1;\n      const additionalSpace = stroke + 2;\n      let fullWidth = this.root.state.options.width;\n      let formatNames = Object.keys(this.root.state.options.calendar.day.format);\n      for (let days = this.root.state.options.times.steps.length; days > 1; days = Math.ceil(days / 2)) {\n        for (let formatName of formatNames) {\n          if (\n            (this.root.state.options.calendar.day.maxWidths[formatName] + additionalSpace) * days <= fullWidth &&\n            days > 1\n          ) {\n            return {\n              count: days,\n              type: formatName\n            };\n          }\n        }\n      }\n      return {\n        count: 0,\n        type: ''\n      };\n    },\n\n    /**\n     * How many months will fit?\n     *\n     * @returns {object}\n     */\n    howManyMonthsFit() {\n      const stroke = 1;\n      const additionalSpace = stroke + 2;\n      let fullWidth = this.root.state.options.width;\n      let formatNames = Object.keys(this.root.state.options.calendar.month.format);\n      let currentMonth = dayjs(this.root.state.options.times.firstTime);\n      let previousMonth = currentMonth.clone();\n      const lastTime = this.root.state.options.times.lastTime;\n      let monthsCount = this.root.monthsCount(\n        this.root.state.options.times.firstTime,\n        this.root.state.options.times.lastTime\n      );\n      if (monthsCount === 1) {\n        for (let formatName of formatNames) {\n          if (this.root.state.options.calendar.month.maxWidths[formatName] + additionalSpace <= fullWidth) {\n            return {\n              count: 1,\n              type: formatName\n            };\n          }\n        }\n      }\n      for (let months = monthsCount; months > 1; months = Math.ceil(months / 2)) {\n        for (let formatName of formatNames) {\n          if (\n            (this.root.state.options.calendar.month.maxWidths[formatName] + additionalSpace) * months <= fullWidth &&\n            months > 1\n          ) {\n            return {\n              count: months,\n              type: formatName\n            };\n          }\n        }\n      }\n      return {\n        count: 0,\n        type: formatNames[0]\n      };\n    },\n\n    /**\n     * Generate hours\n     *\n     * @returns {array}\n     */\n    generateHours() {\n      let allHours = [];\n      if (!this.root.state.options.calendar.hour.display) {\n        return allHours;\n      }\n      const steps = this.root.state.options.times.steps;\n      const localeName = this.root.state.options.locale.name;\n      for (let hourIndex = 0, len = steps.length; hourIndex < len; hourIndex++) {\n        const hoursCount = this.howManyHoursFit(hourIndex);\n        if (hoursCount.count === 0) {\n          continue;\n        }\n        const hours = { key: hourIndex + 'step', children: [] };\n        const hourStep = 24 / hoursCount.count;\n        const hourWidthPx = steps[hourIndex].width.px / hoursCount.count;\n        for (let i = 0, len = hoursCount.count; i < len; i++) {\n          const hour = i * hourStep;\n          let index = hourIndex;\n          if (hourIndex > 0) {\n            index = hourIndex - Math.floor(hourIndex / 24) * 24;\n          }\n          let textWidth = 0;\n          if (typeof this.root.state.options.calendar.hour.widths[index] !== 'undefined') {\n            textWidth = this.root.state.options.calendar.hour.widths[index][hoursCount.type];\n          }\n          let x = steps[hourIndex].offset.px + hourWidthPx * i;\n          hours.children.push({\n            index: hourIndex,\n            key: 'h' + i,\n            x,\n            y: this.root.state.options.calendar.day.height + this.root.state.options.calendar.month.height,\n            width: hourWidthPx,\n            textWidth,\n            height: this.root.state.options.calendar.hour.height,\n            label: this.root.state.options.calendar.hour.formatted[hoursCount.type][hour]\n          });\n        }\n        allHours.push(hours);\n      }\n      return allHours;\n    },\n\n    /**\n     * Generate days\n     *\n     * @returns {array}\n     */\n    generateDays() {\n      let days = [];\n      if (!this.root.state.options.calendar.day.display) {\n        return days;\n      }\n      const daysCount = this.howManyDaysFit();\n      if (daysCount.count === 0) {\n        return days;\n      }\n      const steps = this.root.state.options.times.steps;\n      const localeName = this.root.state.options.locale.name;\n      const dayStep = Math.ceil(steps.length / daysCount.count);\n      for (let dayIndex = 0, len = steps.length; dayIndex < len; dayIndex += dayStep) {\n        let dayWidthPx = 0;\n        // day could be shorter (daylight saving time) so join widths and divide\n        for (let currentStep = 0; currentStep < dayStep; currentStep++) {\n          if (typeof steps[dayIndex + currentStep] !== 'undefined') {\n            dayWidthPx += steps[dayIndex + currentStep].width.px;\n          }\n        }\n        const date = dayjs(steps[dayIndex].time);\n        let textWidth = 0;\n        if (typeof this.root.state.options.calendar.day.widths[dayIndex] !== 'undefined') {\n          textWidth = this.root.state.options.calendar.day.widths[dayIndex][daysCount.type];\n        }\n        let x = steps[dayIndex].offset.px;\n        days.push({\n          index: dayIndex,\n          key: steps[dayIndex].time + 'd',\n          x,\n          y: this.root.state.options.calendar.month.height,\n          width: dayWidthPx,\n          textWidth,\n          height: this.root.state.options.calendar.day.height,\n          label: this.root.state.options.calendar.day.format[daysCount.type](date.locale(localeName))\n        });\n      }\n      return days.map(item => ({\n        key: item.key,\n        children: [item]\n      }));\n    },\n\n    /**\n     * Generate months\n     *\n     * @returns {array}\n     */\n    generateMonths() {\n      let months = [];\n      if (!this.root.state.options.calendar.month.display) {\n        return months;\n      }\n      const monthsCount = this.howManyMonthsFit();\n      if (monthsCount.count === 0) {\n        return months;\n      }\n      const steps = this.root.state.options.times.steps;\n      const localeName = this.root.state.options.locale.name;\n      let formatNames = Object.keys(this.root.state.options.calendar.month.format);\n      let currentDate = dayjs(this.root.state.options.times.firstTime);\n      for (let monthIndex = 0; monthIndex < monthsCount.count; monthIndex++) {\n        let monthWidth = 0;\n        let monthOffset = Number.MAX_SAFE_INTEGER;\n        let finalDate = dayjs(currentDate)\n          .add(1, 'month')\n          .startOf('month');\n        if (finalDate.valueOf() > this.root.state.options.times.lastTime) {\n          finalDate = dayjs(this.root.state.options.times.lastTime);\n        }\n        // we must find first and last step to get the offsets / widths\n        for (let step = 0, len = this.root.state.options.times.steps.length; step < len; step++) {\n          let currentStep = this.root.state.options.times.steps[step];\n          if (currentStep.time >= currentDate.valueOf() && currentStep.time < finalDate.valueOf()) {\n            monthWidth += currentStep.width.px;\n            if (currentStep.offset.px < monthOffset) {\n              monthOffset = currentStep.offset.px;\n            }\n          }\n        }\n        let label = '';\n        let choosenFormatName;\n        for (let formatName of formatNames) {\n          if (this.root.state.options.calendar.month.maxWidths[formatName] + 2 <= monthWidth) {\n            label = this.root.state.options.calendar.month.format[formatName](currentDate.locale(localeName));\n            choosenFormatName = formatName;\n          }\n        }\n        let textWidth = 0;\n        if (typeof this.root.state.options.calendar.month.widths[monthIndex] !== 'undefined') {\n          textWidth = this.root.state.options.calendar.month.widths[monthIndex][choosenFormatName];\n        }\n        let x = monthOffset;\n        months.push({\n          index: monthIndex,\n          key: monthIndex + 'm',\n          x,\n          y: 0,\n          width: monthWidth,\n          textWidth,\n          choosenFormatName,\n          height: this.root.state.options.calendar.month.height,\n          label\n        });\n        currentDate = currentDate.add(1, 'month').startOf('month');\n        if (currentDate.valueOf() > this.root.state.options.times.lastTime) {\n          currentDate = dayjs(this.root.state.options.times.lastTime);\n        }\n      }\n      return months.map(item => ({\n        key: item.key,\n        children: [item]\n      }));\n    },\n\n    /**\n     * Sum all calendar rows height and return result\n     *\n     * @returns {int}\n     */\n    calculateCalendarDimensions({ hours, days, months }) {\n      let height = 0;\n      if (this.root.state.options.calendar.hour.display && hours.length > 0) {\n        height += this.root.state.options.calendar.hour.height;\n      }\n      if (this.root.state.options.calendar.day.display && days.length > 0) {\n        height += this.root.state.options.calendar.day.height;\n      }\n      if (this.root.state.options.calendar.month.display && months.length > 0) {\n        height += this.root.state.options.calendar.month.height;\n      }\n      this.root.state.options.calendar.height = height;\n    }\n  },\n\n  computed: {\n    dates() {\n      const hours = this.generateHours();\n      const days = this.generateDays();\n      const months = this.generateMonths();\n      const allDates = { hours, days, months };\n      this.calculateCalendarDimensions(allDates);\n      return allDates;\n    }\n  }\n};\n</script>\n"]}]}