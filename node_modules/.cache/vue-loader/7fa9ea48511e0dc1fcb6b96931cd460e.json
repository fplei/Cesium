{"remainingRequest":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js??vue-loader-options!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/GanttElastic.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/GanttElastic.vue","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_babel-loader@8.2.5@babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js","mtime":1655715099000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBWdWVJbnN0YW5jZSBmcm9tICd2dWUnOwppbXBvcnQgZGF5anMgZnJvbSAnZGF5anMnOwppbXBvcnQgTWFpblZpZXcgZnJvbSAnLi9jb21wb25lbnRzL01haW5WaWV3LnZ1ZSc7CmltcG9ydCBnZXRTdHlsZSBmcm9tICcuL3N0eWxlLmpzJzsKaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCc7Cgpjb25zdCBjdHggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpOwpsZXQgVnVlSW5zdCA9IFZ1ZUluc3RhbmNlOwpmdW5jdGlvbiBpbml0VnVlKCkgewogIGlmICh0eXBlb2YgVnVlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVnVlSW5zdCA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgIFZ1ZUluc3QgPSBWdWU7CiAgfQp9CmluaXRWdWUoKTsKCmxldCBob3VyV2lkdGhDYWNoZSA9IG51bGw7CgovKioKICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpbGwgb3V0IGVtcHR5IG9wdGlvbnMgaW4gdXNlciBzZXR0aW5ncwogKgogKiBAcGFyYW0ge29iamVjdH0gdXNlck9wdGlvbnMgLSBpbml0aWFsIHVzZXIgb3B0aW9ucyB0aGF0IHdpbGwgbWVyZ2Ugd2l0aCB0aG9zZSBiZWxvdwogKiBAcmV0dXJucyB7b2JqZWN0fSBtZXJnZWQgb3B0aW9ucwogKi8KZnVuY3Rpb24gZ2V0T3B0aW9ucyh1c2VyT3B0aW9ucykgewogIGxldCBsb2NhbGVOYW1lID0gJ2VuJzsKICBpZiAodHlwZW9mIHVzZXJPcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHVzZXJPcHRpb25zLmxvY2FsZS5uYW1lICE9PSAndW5kZWZpbmVkJykgewogICAgbG9jYWxlTmFtZSA9IHVzZXJPcHRpb25zLmxvY2FsZS5uYW1lOwogIH0KICByZXR1cm4gewogICAgc2xvdHM6IHsKICAgICAgaGVhZGVyOiB7fQogICAgfSwKICAgIHRhc2tNYXBwaW5nOiB7CiAgICAgIC8vKgogICAgICBpZDogJ2lkJywKICAgICAgc3RhcnQ6ICdzdGFydCcsCiAgICAgIGxhYmVsOiAnbGFiZWwnLAogICAgICBkdXJhdGlvbjogJ2R1cmF0aW9uJywKICAgICAgcHJvZ3Jlc3M6ICdwcm9ncmVzcycsCiAgICAgIHR5cGU6ICd0eXBlJywKICAgICAgc3R5bGU6ICdzdHlsZScsCiAgICAgIGNvbGxhcHNlZDogJ2NvbGxhcHNlZCcKICAgIH0sCiAgICB3aWR0aDogMCwKICAgIGhlaWdodDogMCwKICAgIGNsaWVudFdpZHRoOiAwLAogICAgb3V0ZXJIZWlnaHQ6IDAsCiAgICByb3dzSGVpZ2h0OiAwLAogICAgYWxsVmlzaWJsZVRhc2tzSGVpZ2h0OiAwLAogICAgc2Nyb2xsOiB7CiAgICAgIHNjcm9sbGluZzogZmFsc2UsCiAgICAgIGRyYWdYTW92ZU11bHRpcGxpZXI6IDMsIC8vKgogICAgICBkcmFnWU1vdmVNdWx0aXBsaWVyOiAyLCAvLyoKICAgICAgdG9wOiAwLAogICAgICB0YXNrTGlzdDogewogICAgICAgIGxlZnQ6IDAsCiAgICAgICAgcmlnaHQ6IDAsCiAgICAgICAgdG9wOiAwLAogICAgICAgIGJvdHRvbTogMAogICAgICB9LAogICAgICBjaGFydDogewogICAgICAgIGxlZnQ6IDAsCiAgICAgICAgcmlnaHQ6IDAsCiAgICAgICAgcGVyY2VudDogMCwKICAgICAgICB0aW1lUGVyY2VudDogMCwKICAgICAgICB0b3A6IDAsCiAgICAgICAgYm90dG9tOiAwLAogICAgICAgIHRpbWU6IDAsCiAgICAgICAgdGltZUNlbnRlcjogMCwKICAgICAgICBkYXRlVGltZTogewogICAgICAgICAgbGVmdDogJycsCiAgICAgICAgICByaWdodDogJycKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBzY29wZTogewogICAgICAvLyoKICAgICAgYmVmb3JlOiAxLAogICAgICBhZnRlcjogMQogICAgfSwKICAgIHRpbWVzOiB7CiAgICAgIHRpbWVTY2FsZTogNjAgKiAxMDAwLAogICAgICB0aW1lWm9vbTogMTcsIC8vKgogICAgICB0aW1lUGVyUGl4ZWw6IDAsCiAgICAgIGZpcnN0VGltZTogbnVsbCwKICAgICAgbGFzdFRpbWU6IG51bGwsCiAgICAgIGZpcnN0VGFza1RpbWU6IDAsCiAgICAgIGxhc3RUYXNrVGltZTogMCwKICAgICAgdG90YWxWaWV3RHVyYXRpb25NczogMCwKICAgICAgdG90YWxWaWV3RHVyYXRpb25QeDogMCwKICAgICAgc3RlcER1cmF0aW9uOiAnZGF5JywKICAgICAgc3RlcHM6IFtdCiAgICB9LAogICAgcm93OiB7CiAgICAgIGhlaWdodDogMjQgLy8qCiAgICB9LAogICAgbWF4Um93czogMjAsIC8vKgogICAgbWF4SGVpZ2h0OiAwLCAvLyoKICAgIGNoYXJ0OiB7CiAgICAgIGdyaWQ6IHsKICAgICAgICBob3Jpem9udGFsOiB7CiAgICAgICAgICBnYXA6IDYgLy8qCiAgICAgICAgfQogICAgICB9LAogICAgICBwcm9ncmVzczogewogICAgICAgIHdpZHRoOiAyMCwgLy8qCiAgICAgICAgaGVpZ2h0OiA2LCAvLyoKICAgICAgICBwYXR0ZXJuOiB0cnVlLAogICAgICAgIGJhcjogZmFsc2UKICAgICAgfSwKICAgICAgdGV4dDogewogICAgICAgIG9mZnNldDogNCwgLy8qCiAgICAgICAgeFBhZGRpbmc6IDEwLCAvLyoKICAgICAgICBkaXNwbGF5OiB0cnVlIC8vKgogICAgICB9LAogICAgICBleHBhbmRlcjogewogICAgICAgIHR5cGU6ICdjaGFydCcsCiAgICAgICAgZGlzcGxheTogZmFsc2UsIC8vKgogICAgICAgIGRpc3BsYXlJZlRhc2tMaXN0SGlkZGVuOiB0cnVlLCAvLyoKICAgICAgICBvZmZzZXQ6IDQsIC8vKgogICAgICAgIHNpemU6IDE4CiAgICAgIH0KICAgIH0sCiAgICB0YXNrTGlzdDogewogICAgICBkaXNwbGF5OiB0cnVlLCAvLyoKICAgICAgcmVzaXplQWZ0ZXJUaHJlc2hvbGQ6IHRydWUsIC8vKgogICAgICB3aWR0aFRocmVzaG9sZDogNzUsIC8vKgogICAgICBjb2x1bW5zOiBbCiAgICAgICAgLy8qCiAgICAgICAgewogICAgICAgICAgaWQ6IDAsCiAgICAgICAgICBsYWJlbDogJ0lEJywKICAgICAgICAgIHZhbHVlOiAnaWQnLAogICAgICAgICAgd2lkdGg6IDQwCiAgICAgICAgfQogICAgICBdLAogICAgICBwZXJjZW50OiAxMDAsIC8vKgogICAgICB3aWR0aDogMCwKICAgICAgZmluYWxXaWR0aDogMCwKICAgICAgd2lkdGhGcm9tUGVyY2VudGFnZTogMCwKICAgICAgbWluV2lkdGg6IDE4LAogICAgICBleHBhbmRlcjogewogICAgICAgIHR5cGU6ICd0YXNrLWxpc3QnLAogICAgICAgIHNpemU6IDE2LAogICAgICAgIGNvbHVtbldpZHRoOiAyNCwKICAgICAgICBwYWRkaW5nOiAxNiwKICAgICAgICBtYXJnaW46IDEwLAogICAgICAgIHN0cmFpZ2h0OiBmYWxzZQogICAgICB9CiAgICB9LAogICAgY2FsZW5kYXI6IHsKICAgICAgd29ya2luZ0RheXM6IFsxLCAyLCAzLCA0LCA1XSwgLy8qCiAgICAgIGdhcDogNiwgLy8qCiAgICAgIGhlaWdodDogMCwKICAgICAgc3Ryb2tlV2lkdGg6IDEsCiAgICAgIGhvdXI6IHsKICAgICAgICBoZWlnaHQ6IDIwLCAvLyoKICAgICAgICBkaXNwbGF5OiB0cnVlLCAvLyoKICAgICAgICB3aWR0aHM6IFtdLAogICAgICAgIG1heFdpZHRoczogeyBzaG9ydDogMCwgbWVkaXVtOiAwLCBsb25nOiAwIH0sCiAgICAgICAgZm9ybWF0dGVkOiB7CiAgICAgICAgICBsb25nOiBbXSwKICAgICAgICAgIG1lZGl1bTogW10sCiAgICAgICAgICBzaG9ydDogW10KICAgICAgICB9LAogICAgICAgIGZvcm1hdDogewogICAgICAgICAgLy8qCiAgICAgICAgICBsb25nKGRhdGUpIHsKICAgICAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdISDptbScpOwogICAgICAgICAgfSwKICAgICAgICAgIG1lZGl1bShkYXRlKSB7CiAgICAgICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnSEg6bW0nKTsKICAgICAgICAgIH0sCiAgICAgICAgICBzaG9ydChkYXRlKSB7CiAgICAgICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgnSEgnKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIGRheTogewogICAgICAgIGhlaWdodDogMjAsIC8vKgogICAgICAgIGRpc3BsYXk6IHRydWUsIC8vKgogICAgICAgIHdpZHRoczogW10sCiAgICAgICAgbWF4V2lkdGhzOiB7IHNob3J0OiAwLCBtZWRpdW06IDAsIGxvbmc6IDAgfSwKICAgICAgICBmb3JtYXQ6IHsKICAgICAgICAgIGxvbmcoZGF0ZSkgewogICAgICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ0REIGRkZGQnKTsKICAgICAgICAgIH0sCiAgICAgICAgICBtZWRpdW0oZGF0ZSkgewogICAgICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ0REIGRkZCcpOwogICAgICAgICAgfSwKICAgICAgICAgIHNob3J0KGRhdGUpIHsKICAgICAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdERCcpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwKICAgICAgbW9udGg6IHsKICAgICAgICBoZWlnaHQ6IDIwLCAvLyoKICAgICAgICBkaXNwbGF5OiB0cnVlLCAvLyoKICAgICAgICB3aWR0aHM6IFtdLAogICAgICAgIG1heFdpZHRoczogeyBzaG9ydDogMCwgbWVkaXVtOiAwLCBsb25nOiAwIH0sCiAgICAgICAgZm9ybWF0OiB7CiAgICAgICAgICAvLyoKICAgICAgICAgIHNob3J0KGRhdGUpIHsKICAgICAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KCdNTScpOwogICAgICAgICAgfSwKICAgICAgICAgIG1lZGl1bShkYXRlKSB7CiAgICAgICAgICAgIHJldHVybiBkYXRlLmZvcm1hdCgiTU1NICdZWSIpOwogICAgICAgICAgfSwKICAgICAgICAgIGxvbmcoZGF0ZSkgewogICAgICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ01NTU0gWVlZWScpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIGxvY2FsZTogewogICAgICAvLyoKICAgICAgbmFtZTogJ2VuJywKICAgICAgd2Vla2RheXM6ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSwKICAgICAgd2Vla2RheXNTaG9ydDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSwKICAgICAgd2Vla2RheXNNaW46ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSwKICAgICAgbW9udGhzOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSwKICAgICAgbW9udGhzU2hvcnQ6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSwKICAgICAgd2Vla1N0YXJ0OiAxLAogICAgICByZWxhdGl2ZVRpbWU6IHsKICAgICAgICBmdXR1cmU6ICdpbiAlcycsCiAgICAgICAgcGFzdDogJyVzIGFnbycsCiAgICAgICAgczogJ2EgZmV3IHNlY29uZHMnLAogICAgICAgIG06ICdhIG1pbnV0ZScsCiAgICAgICAgbW06ICclZCBtaW51dGVzJywKICAgICAgICBoOiAnYW4gaG91cicsCiAgICAgICAgaGg6ICclZCBob3VycycsCiAgICAgICAgZDogJ2EgZGF5JywKICAgICAgICBkZDogJyVkIGRheXMnLAogICAgICAgIE06ICdhIG1vbnRoJywKICAgICAgICBNTTogJyVkIG1vbnRocycsCiAgICAgICAgeTogJ2EgeWVhcicsCiAgICAgICAgeXk6ICclZCB5ZWFycycKICAgICAgfSwKICAgICAgZm9ybWF0czogewogICAgICAgIExUOiAnSEg6bW0nLAogICAgICAgIExUUzogJ0hIOm1tOnNzJywKICAgICAgICBMOiAnREQvTU0vWVlZWScsCiAgICAgICAgTEw6ICdEIE1NTU0gWVlZWScsCiAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLAogICAgICAgIExMTEw6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbScKICAgICAgfSwKICAgICAgb3JkaW5hbDogbiA9PiB7CiAgICAgICAgY29uc3QgcyA9IFsndGgnLCAnc3QnLCAnbmQnLCAncmQnXTsKICAgICAgICBjb25zdCB2ID0gbiAlIDEwMDsKICAgICAgICByZXR1cm4gYFske259JHtzWyh2IC0gMjApICUgMTBdIHx8IHNbdl0gfHwgc1swXX1dYDsKICAgICAgfQogICAgfQogIH07Cn0KCi8qKgogKiBQcmVwYXJlIHN0eWxlCiAqCiAqIEByZXR1cm5zIHtvYmplY3R9CiAqLwpmdW5jdGlvbiBwcmVwYXJlU3R5bGUodXNlclN0eWxlKSB7CiAgbGV0IGZvbnRTaXplID0gJzEycHgnOwogIGxldCBmb250RmFtaWx5ID0gd2luZG93CiAgICAuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KQogICAgLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtZmFtaWx5JykKICAgIC50b1N0cmluZygpOwogIGlmICh0eXBlb2YgdXNlclN0eWxlICE9PSAndW5kZWZpbmVkJykgewogICAgaWYgKHR5cGVvZiB1c2VyU3R5bGUuZm9udFNpemUgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgIGZvbnRTaXplID0gdXNlclN0eWxlLmZvbnRTaXplOwogICAgfQogICAgaWYgKHR5cGVvZiB1c2VyU3R5bGUuZm9udEZhbWlseSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgZm9udEZhbWlseSA9IHVzZXJTdHlsZS5mb250RmFtaWx5OwogICAgfQogIH0KICByZXR1cm4gZ2V0U3R5bGUoZm9udFNpemUsIGZvbnRGYW1pbHkpOwp9CgovKioKICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBzcGVjaWZpZWQgdmFyaWFibGUgaXMgYW4gb2JqZWN0CiAqCiAqIEBwYXJhbSB7YW55fSBpdGVtCiAqCiAqIEByZXR1cm5zIHtib29sZWFufQogKi8KZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkgewogIHJldHVybiAoCiAgICBpdGVtICYmCiAgICB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYKICAgICFBcnJheS5pc0FycmF5KGl0ZW0pICYmCiAgICAhKGl0ZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgJiYKICAgICEoaXRlbSBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkgJiYKICAgIHR5cGVvZiBpdGVtICE9PSAnZnVuY3Rpb24nCiAgKTsKfQoKLyoqCiAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCB3aWxsIG1lcmdlIG9iamVjdHMgcmVjdXJzaXZlbHkgLSBjcmVhdGluZyBicmFuZCBuZXcgb25lIC0gbGlrZSBjbG9uZQogKgogKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0CiAqIEBwYXJhbXMge29iamVjdH0gc291cmNlcwogKgogKiBAcmV0dXJucyB7b2JqZWN0fQogKi8KZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpIHsKICBpZiAoIXNvdXJjZXMubGVuZ3RoKSB7CiAgICByZXR1cm4gdGFyZ2V0OwogIH0KICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkgewogICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7CiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHsKICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTsKICAgICAgICB9CiAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTsKICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSkgewogICAgICAgIHRhcmdldFtrZXldID0gW107CiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBzb3VyY2Vba2V5XSkgewogICAgICAgICAgaWYgKGlzT2JqZWN0KGl0ZW0pKSB7CiAgICAgICAgICAgIHRhcmdldFtrZXldLnB1c2gobWVyZ2VEZWVwKHt9LCBpdGVtKSk7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgICAgdGFyZ2V0W2tleV0ucHVzaChpdGVtKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsKICAgICAgfQogICAgfQogIH0KICByZXR1cm4gbWVyZ2VEZWVwKHRhcmdldCwgLi4uc291cmNlcyk7Cn0KCi8qKgogKiBEZXRlY3QgaWYgb2JqZWN0IG9yIGFycmF5IGlzIG9ic2VydmFibGUKICoKICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IG9iagogKgogKiBAcmV0dXJucyB7Ym9vbGVhbn0KICovCmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZShvYmopIHsKICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmhhc093blByb3BlcnR5KCdfX29iX18nKTsKfQoKLyoqCiAqIFNhbWUgYXMgYWJvdmUgYnV0IHdpdGggcmVhY3Rpdml0eSBpbiBtaW5kCiAqCiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQKICogQHBhcmFtcyB7b2JqZWN0fSBzb3VyY2VzCiAqCiAqIEByZXR1cm5zIHtvYmplY3R9CiAqLwpleHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWVwUmVhY3RpdmUoY29tcG9uZW50LCB0YXJnZXQsIC4uLnNvdXJjZXMpIHsKICBpZiAoIXNvdXJjZXMubGVuZ3RoKSB7CiAgICByZXR1cm4gdGFyZ2V0OwogIH0KICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7CiAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkgewogICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7CiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHsKICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtrZXldID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgY29tcG9uZW50LiRzZXQodGFyZ2V0LCBrZXksIHt9KTsKICAgICAgICB9CiAgICAgICAgbWVyZ2VEZWVwUmVhY3RpdmUoY29tcG9uZW50LCB0YXJnZXRba2V5XSwgc291cmNlW2tleV0pOwogICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlW2tleV0pKSB7CiAgICAgICAgY29tcG9uZW50LiRzZXQodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsKICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09ICdmdW5jdGlvbicpIHsKICAgICAgICBpZiAoc291cmNlW2tleV0udG9TdHJpbmcoKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPT09IC0xKSB7CiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBjb21wb25lbnQuJHNldCh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOwogICAgICB9CiAgICB9CiAgfQogIHJldHVybiBtZXJnZURlZXBSZWFjdGl2ZShjb21wb25lbnQsIHRhcmdldCwgLi4uc291cmNlcyk7Cn0KLyoqCiAqIENoZWNrIGlmIG9iamVjdHMgb3IgYXJyYXlzIGFyZSBlcXVhbCBieSBjb21wYXJpbmcgbmVzdGVkIHZhbHVlcwogKgogKiBAcGFyYW0ge29iamVjdHxhcnJheX0gbGVmdAogKiBAcGFyYW0ge29iamVjdHxhcnJheX0gcmlnaHQKICoKICogQHJldHVybnMge2Jvb2xlYW59CiAqLwpleHBvcnQgZnVuY3Rpb24gbm90RXF1YWxEZWVwKGxlZnQsIHJpZ2h0LCBjYWNoZSA9IFtdLCBwYXRoID0gJycpIHsKICBpZiAodHlwZW9mIHJpZ2h0ICE9PSB0eXBlb2YgbGVmdCkgewogICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHdoYXQ6IHBhdGggKyAnLnR5cGVvZicgfTsKICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgJiYgIUFycmF5LmlzQXJyYXkocmlnaHQpKSB7CiAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgd2hhdDogcGF0aCArICcuaXNBcnJheScgfTsKICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmlnaHQpICYmICFBcnJheS5pc0FycmF5KGxlZnQpKSB7CiAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgd2hhdDogcGF0aCArICcuaXNBcnJheScgfTsKICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHsKICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7CiAgICAgIHJldHVybiB7IGxlZnQsIHJpZ2h0LCB3aGF0OiBwYXRoICsgJy5sZW5ndGgnIH07CiAgICB9CiAgICBsZXQgd2hhdDsKICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuID0gbGVmdC5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7CiAgICAgIGlmICgod2hhdCA9IG5vdEVxdWFsRGVlcChsZWZ0W2luZGV4XSwgcmlnaHRbaW5kZXhdLCBjYWNoZSwgcGF0aCArICcuJyArIGluZGV4KSkpIHsKICAgICAgICByZXR1cm4gd2hhdDsKICAgICAgfQogICAgfQogIH0gZWxzZSBpZiAoaXNPYmplY3QobGVmdCkgJiYgIWlzT2JqZWN0KHJpZ2h0KSkgewogICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHdoYXQ6IHBhdGggKyAnLmlzT2JqZWN0JyB9OwogIH0gZWxzZSBpZiAoaXNPYmplY3QocmlnaHQpICYmICFpc09iamVjdChsZWZ0KSkgewogICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHdoYXQ6IHBhdGggKyAnLmlzT2JqZWN0JyB9OwogIH0gZWxzZSBpZiAoaXNPYmplY3QobGVmdCkgJiYgaXNPYmplY3QocmlnaHQpKSB7CiAgICBmb3IgKGxldCBrZXkgaW4gbGVmdCkgewogICAgICBpZiAoIWxlZnQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAhbGVmdC5wcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgaWYgKCFyaWdodC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHdoYXQ6IHBhdGggKyAnLicgKyBrZXkgfTsKICAgICAgfQogICAgICBsZXQgd2hhdDsKICAgICAgaWYgKCh3aGF0ID0gbm90RXF1YWxEZWVwKGxlZnRba2V5XSwgcmlnaHRba2V5XSwgY2FjaGUsIHBhdGggKyAnLicgKyBrZXkpKSkgewogICAgICAgIHJldHVybiB3aGF0OwogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmIChsZWZ0ICE9PSByaWdodCkgewogICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHdoYXQ6IHBhdGggKyAnLiAhPT0nIH07CiAgfQogIHJldHVybiBmYWxzZTsKfQoKLyoqCiAqIEdhbnR0RWxhc3RpYwogKiBNYWluIHZ1ZSBjb21wb25lbnQKICovCmNvbnN0IEdhbnR0RWxhc3RpYyA9IHsKICBuYW1lOiAnR2FudHRFbGFzdGljJywKICBjb21wb25lbnRzOiB7CiAgICBNYWluVmlldwogIH0sCiAgcHJvcHM6IFsndGFza3MnLCAnb3B0aW9ucycsICdkeW5hbWljU3R5bGUnXSwKICBwcm92aWRlKCkgewogICAgY29uc3QgcHJvdmlkZXIgPSB7fTsKICAgIGNvbnN0IHNlbGYgPSB0aGlzOwogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3ZpZGVyLCAncm9vdCcsIHsKICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgZ2V0OiAoKSA9PiBzZWxmCiAgICB9KTsKICAgIHJldHVybiBwcm92aWRlcjsKICB9LAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBzdGF0ZTogewogICAgICAgIHRhc2tzOiBbXSwKICAgICAgICBvcHRpb25zOiB7CiAgICAgICAgICBzY3JvbGxCYXJIZWlnaHQ6IDAsCiAgICAgICAgICBhbGxWaXNpYmxlVGFza3NIZWlnaHQ6IDAsCiAgICAgICAgICBvdXRlckhlaWdodDogMCwKICAgICAgICAgIHNjcm9sbDogewogICAgICAgICAgICBsZWZ0OiAwLAogICAgICAgICAgICB0b3A6IDAKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGR5bmFtaWNTdHlsZToge30sCiAgICAgICAgcmVmczoge30sCiAgICAgICAgdGFza3NCeUlkOiB7fSwKICAgICAgICB0YXNrVHJlZToge30sCiAgICAgICAgY3R4LAogICAgICAgIGVtaXRUYXNrc0NoYW5nZXM6IHRydWUsIC8vIHNvbWUgb3BlcmF0aW9ucyBtYXkgcGF1c2UgZW1pdHRpbmcgY2hhbmdlcyB0byBwYXJlbnQgY29tcG9uZW50CiAgICAgICAgZW1pdE9wdGlvbnNDaGFuZ2VzOiB0cnVlLCAvLyBzb21lIG9wZXJhdGlvbnMgbWF5IHBhdXNlIGVtaXR0aW5nIGNoYW5nZXMgdG8gcGFyZW50IGNvbXBvbmVudAogICAgICAgIHJlc2l6ZU9ic2VydmVyOiBudWxsLAogICAgICAgIHVud2F0Y2hUYXNrczogbnVsbCwKICAgICAgICB1bndhdGNoT3B0aW9uczogbnVsbCwKICAgICAgICB1bndhdGNoU3R5bGU6IG51bGwsCiAgICAgICAgdW53YXRjaE91dHB1dFRhc2tzOiBudWxsLAogICAgICAgIHVud2F0Y2hPdXRwdXRPcHRpb25zOiBudWxsLAogICAgICAgIHVud2F0Y2hPdXRwdXRTdHlsZTogbnVsbAogICAgICB9CiAgICB9OwogIH0sCiAgbWV0aG9kczogewogICAgbWVyZ2VEZWVwLAogICAgbWVyZ2VEZWVwUmVhY3RpdmUsCgogICAgLyoqCiAgICAgKiBDYWxjdWxhdGUgaGVpZ2h0IG9mIHNjcm9sbGJhciBpbiBjdXJyZW50IGJyb3dzZXIKICAgICAqCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfQogICAgICovCiAgICBnZXRTY3JvbGxCYXJIZWlnaHQoKSB7CiAgICAgIGNvbnN0IG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgICAgIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJzsKICAgICAgb3V0ZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JzsKICAgICAgb3V0ZXIuc3R5bGUubXNPdmVyZmxvd1N0eWxlID0gJ3Njcm9sbGJhcic7CiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpOwogICAgICB2YXIgbm9TY3JvbGwgPSBvdXRlci5vZmZzZXRIZWlnaHQ7CiAgICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7CiAgICAgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOwogICAgICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7CiAgICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTsKICAgICAgdmFyIHdpdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRIZWlnaHQ7CiAgICAgIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpOwogICAgICBjb25zdCBoZWlnaHQgPSBub1Njcm9sbCAtIHdpdGhTY3JvbGw7CiAgICAgIHRoaXMuc3R5bGVbJ2NoYXJ0LXNjcm9sbC1jb250YWluZXItLXZlcnRpY2FsJ11bJ21hcmdpbi1sZWZ0J10gPSBgLSR7aGVpZ2h0fXB4YDsKICAgICAgcmV0dXJuICh0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsQmFySGVpZ2h0ID0gaGVpZ2h0KTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBGaWxsIG91dCBlbXB0eSB0YXNrIHByb3BlcnRpZXMgYW5kIG1ha2UgaXQgcmVhY3RpdmUKICAgICAqCiAgICAgKiBAcGFyYW0ge2FycmF5fSB0YXNrcwogICAgICovCiAgICBmaWxsVGFza3ModGFza3MpIHsKICAgICAgZm9yIChsZXQgdGFzayBvZiB0YXNrcykgewogICAgICAgIGlmICh0eXBlb2YgdGFzay54ID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFzay54ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLnkgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLnkgPSAwOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHRhc2sud2lkdGggPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLndpZHRoID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2suaGVpZ2h0ID0gMDsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLm1vdXNlT3ZlciA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2subW91c2VPdmVyID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdGFzay5jb2xsYXBzZWQgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLmNvbGxhcHNlZCA9IGZhbHNlOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHRhc2suZGVwZW5kZW50T24gPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLmRlcGVuZGVudE9uID0gW107CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdGFzay5wYXJlbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2sucGFyZW50SWQgPSBudWxsOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHRhc2suc3R5bGUgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB0YXNrLnN0eWxlID0ge307CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdGFzay5jaGlsZHJlbiA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2suY2hpbGRyZW4gPSBbXTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLmFsbENoaWxkcmVuID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFzay5hbGxDaGlsZHJlbiA9IFtdOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHRhc2sucGFyZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRhc2sucGFyZW50cyA9IFtdOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHRhc2sucGFyZW50ID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFzay5wYXJlbnQgPSBudWxsOwogICAgICAgIH0KICAgICAgICBpZiAodHlwZW9mIHRhc2suc3RhcnRUaW1lID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGFzay5zdGFydFRpbWUgPSBkYXlqcyh0YXNrLnN0YXJ0KS52YWx1ZU9mKCk7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgdGFzay5lbmRUaW1lID09PSAndW5kZWZpbmVkJyAmJiB0YXNrLmhhc093blByb3BlcnR5KCdlbmQnKSkgewogICAgICAgICAgdGFzay5lbmRUaW1lID0gZGF5anModGFzay5lbmQpLnZhbHVlT2YoKTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXNrLmVuZFRpbWUgPT09ICd1bmRlZmluZWQnICYmIHRhc2suaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykpIHsKICAgICAgICAgIHRhc2suZW5kVGltZSA9IHRhc2suc3RhcnRUaW1lICsgdGFzay5kdXJhdGlvbjsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiB0YXNrLmR1cmF0aW9uID09PSAndW5kZWZpbmVkJyAmJiB0YXNrLmhhc093blByb3BlcnR5KCdlbmRUaW1lJykpIHsKICAgICAgICAgIHRhc2suZHVyYXRpb24gPSB0YXNrLmVuZFRpbWUgLSB0YXNrLnN0YXJ0VGltZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHRhc2tzOwogICAgfSwKCiAgICAvKioKICAgICAqIE1hcCB0YXNrcwogICAgICoKICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhc2tzCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogICAgICovCiAgICBtYXBUYXNrcyh0YXNrcywgb3B0aW9ucykgewogICAgICBmb3IgKGxldCBbaW5kZXgsIHRhc2tdIG9mIHRhc2tzLmVudHJpZXMoKSkgewogICAgICAgIHRhc2tzW2luZGV4XSA9IHsKICAgICAgICAgIC4uLnRhc2ssCiAgICAgICAgICBpZDogdGFza1tvcHRpb25zLnRhc2tNYXBwaW5nLmlkXSwKICAgICAgICAgIHN0YXJ0OiB0YXNrW29wdGlvbnMudGFza01hcHBpbmcuc3RhcnRdLAogICAgICAgICAgbGFiZWw6IHRhc2tbb3B0aW9ucy50YXNrTWFwcGluZy5sYWJlbF0sCiAgICAgICAgICBkdXJhdGlvbjogdGFza1tvcHRpb25zLnRhc2tNYXBwaW5nLmR1cmF0aW9uXSwKICAgICAgICAgIHByb2dyZXNzOiB0YXNrW29wdGlvbnMudGFza01hcHBpbmcucHJvZ3Jlc3NdLAogICAgICAgICAgdHlwZTogdGFza1tvcHRpb25zLnRhc2tNYXBwaW5nLnR5cGVdLAogICAgICAgICAgc3R5bGU6IHRhc2tbb3B0aW9ucy50YXNrTWFwcGluZy5zdHlsZV0sCiAgICAgICAgICBjb2xsYXBzZWQ6IHRhc2tbb3B0aW9ucy50YXNrTWFwcGluZy5jb2xsYXBzZWRdCiAgICAgICAgfTsKICAgICAgfQogICAgICByZXR1cm4gdGFza3M7CiAgICB9LAoKICAgIC8qKgogICAgICogSW5pdGlhbGl6ZSBjb21wb25lbnQKICAgICAqLwogICAgaW5pdGlhbGl6ZShpdHNVcGRhdGUgPSAnJykgewogICAgICBsZXQgb3B0aW9ucyA9IG1lcmdlRGVlcCh7fSwgdGhpcy5zdGF0ZS5vcHRpb25zLCBnZXRPcHRpb25zKHRoaXMub3B0aW9ucyksIHRoaXMub3B0aW9ucyk7CiAgICAgIGxldCB0YXNrcyA9IHRoaXMubWFwVGFza3ModGhpcy50YXNrcywgb3B0aW9ucyk7CiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnN0YXRlLmR5bmFtaWNTdHlsZSkubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhpcy5pbml0aWFsaXplU3R5bGUoKTsKICAgICAgfQogICAgICBkYXlqcy5sb2NhbGUob3B0aW9ucy5sb2NhbGUsIG51bGwsIHRydWUpOwogICAgICBkYXlqcy5sb2NhbGUob3B0aW9ucy5sb2NhbGUubmFtZSk7CiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50YXNrTGlzdCA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICBvcHRpb25zLnRhc2tMaXN0ID0ge307CiAgICAgIH0KICAgICAgb3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zID0gb3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gewogICAgICAgIGNvbHVtbi50aHJlc2hvbGRQZXJjZW50ID0gMTAwOwogICAgICAgIGNvbHVtbi53aWR0aEZyb21QZXJjZW50YWdlID0gMDsKICAgICAgICBjb2x1bW4uZmluYWxXaWR0aCA9IDA7CiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4uaGVpZ2h0ID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgY29sdW1uLmhlaWdodCA9IDA7CiAgICAgICAgfQogICAgICAgIGlmICh0eXBlb2YgY29sdW1uLnN0eWxlID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgY29sdW1uLnN0eWxlID0ge307CiAgICAgICAgfQogICAgICAgIGNvbHVtbi5faWQgPSBgJHtpbmRleH0tJHtjb2x1bW4ubGFiZWx9YDsKICAgICAgICByZXR1cm4gY29sdW1uOwogICAgICB9KTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zID0gb3B0aW9uczsKICAgICAgdGFza3MgPSB0aGlzLmZpbGxUYXNrcyh0YXNrcyk7CiAgICAgIHRoaXMuc3RhdGUudGFza3NCeUlkID0gdGhpcy5yZXNldFRhc2tUcmVlKHRhc2tzKTsKICAgICAgdGhpcy5zdGF0ZS50YXNrVHJlZSA9IHRoaXMubWFrZVRhc2tUcmVlKHRoaXMuc3RhdGUucm9vdFRhc2ssIHRhc2tzKTsKICAgICAgdGhpcy5zdGF0ZS50YXNrcyA9IHRoaXMuc3RhdGUudGFza1RyZWUuYWxsQ2hpbGRyZW4ubWFwKGNoaWxkSWQgPT4gdGhpcy5nZXRUYXNrKGNoaWxkSWQpKTsKICAgICAgdGhpcy5jYWxjdWxhdGVUYXNrTGlzdENvbHVtbnNEaW1lbnNpb25zKCk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGxCYXJIZWlnaHQgPSB0aGlzLmdldFNjcm9sbEJhckhlaWdodCgpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMub3V0ZXJIZWlnaHQgPSB0aGlzLnN0YXRlLm9wdGlvbnMuaGVpZ2h0ICsgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbEJhckhlaWdodDsKICAgICAgdGhpcy5nbG9iYWxPblJlc2l6ZSgpOwogICAgfSwKCiAgICAvKioKICAgICAqIEluaXRpYWxpemUgc3R5bGUKICAgICAqLwogICAgaW5pdGlhbGl6ZVN0eWxlKCkgewogICAgICB0aGlzLnN0YXRlLmR5bmFtaWNTdHlsZSA9IG1lcmdlRGVlcCh7fSwgcHJlcGFyZVN0eWxlKHRoaXMuZHluYW1pY1N0eWxlKSwgdGhpcy5keW5hbWljU3R5bGUpOwogICAgfSwKCiAgICAvKioKICAgICAqIEdldCBjYWxlbmRhciByb3dzIG91dGVyIGhlaWdodAogICAgICoKICAgICAqIEByZXR1cm5zIHtpbnR9CiAgICAgKi8KICAgIGdldENhbGVuZGFySGVpZ2h0KCkgewogICAgICByZXR1cm4gdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhlaWdodCArIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5zdHJva2VXaWR0aDsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgbWF4aW1hbCBsZXZlbCBvZiBuZXN0ZWQgdGFzayBjaGlsZHJlbgogICAgICoKICAgICAqIEByZXR1cm5zIHtpbnR9CiAgICAgKi8KICAgIGdldE1heGltYWxMZXZlbCgpIHsKICAgICAgbGV0IG1heGltYWxMZXZlbCA9IDA7CiAgICAgIHRoaXMuc3RhdGUudGFza3MuZm9yRWFjaCh0YXNrID0+IHsKICAgICAgICBpZiAodGFzay5wYXJlbnRzLmxlbmd0aCA+IG1heGltYWxMZXZlbCkgewogICAgICAgICAgbWF4aW1hbExldmVsID0gdGFzay5wYXJlbnRzLmxlbmd0aDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gbWF4aW1hbExldmVsIC0gMTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgbWF4aW1hbCBleHBhbmRlciB3aWR0aCAtIHRvIGNhbGN1bGF0ZSBzdHJhaWdodCB0YXNrIGxpc3QgdGV4dAogICAgICoKICAgICAqIEByZXR1cm5zIHtpbnR9CiAgICAgKi8KICAgIGdldE1heGltYWxFeHBhbmRlcldpZHRoKCkgewogICAgICByZXR1cm4gKAogICAgICAgIHRoaXMuZ2V0TWF4aW1hbExldmVsKCkgKiB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3QuZXhwYW5kZXIucGFkZGluZyArCiAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LmV4cGFuZGVyLm1hcmdpbgogICAgICApOwogICAgfSwKCiAgICAvKioKICAgICAqIFN5bmNocm9uaXplIHNjcm9sbFRvcCBwcm9wZXJ0eSB3aGVuIHJvdyBoZWlnaHQgaXMgY2hhbmdlZAogICAgICovCiAgICBzeW5jU2Nyb2xsVG9wKCkgewogICAgICBpZiAoCiAgICAgICAgdGhpcy5zdGF0ZS5yZWZzLnRhc2tMaXN0SXRlbXMgJiYKICAgICAgICB0aGlzLnN0YXRlLnJlZnMuY2hhcnRHcmFwaC5zY3JvbGxUb3AgIT09IHRoaXMuc3RhdGUucmVmcy50YXNrTGlzdEl0ZW1zLnNjcm9sbFRvcAogICAgICApIHsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLnRvcCA9IHRoaXMuc3RhdGUucmVmcy50YXNrTGlzdEl0ZW1zLnNjcm9sbFRvcCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydFNjcm9sbENvbnRhaW5lclZlcnRpY2FsLnNjcm9sbFRvcCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydEdyYXBoLnNjcm9sbFRvcDsKICAgICAgfQogICAgfSwKCiAgICAvKioKICAgICAqIENhbGN1bGF0ZSB0YXNrIGxpc3QgY29sdW1ucyBkaW1lbnNpb25zCiAgICAgKi8KICAgIGNhbGN1bGF0ZVRhc2tMaXN0Q29sdW1uc0RpbWVuc2lvbnMoKSB7CiAgICAgIGxldCBmaW5hbCA9IDA7CiAgICAgIGxldCBwZXJjZW50YWdlID0gMDsKICAgICAgZm9yIChsZXQgY29sdW1uIG9mIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zKSB7CiAgICAgICAgaWYgKGNvbHVtbi5leHBhbmRlcikgewogICAgICAgICAgY29sdW1uLndpZHRoRnJvbVBlcmNlbnRhZ2UgPQogICAgICAgICAgICAoKHRoaXMuZ2V0TWF4aW1hbEV4cGFuZGVyV2lkdGgoKSArIGNvbHVtbi53aWR0aCkgLyAxMDApICogdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LnBlcmNlbnQ7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbHVtbi53aWR0aEZyb21QZXJjZW50YWdlID0gKGNvbHVtbi53aWR0aCAvIDEwMCkgKiB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3QucGVyY2VudDsKICAgICAgICB9CiAgICAgICAgcGVyY2VudGFnZSArPSBjb2x1bW4ud2lkdGhGcm9tUGVyY2VudGFnZTsKICAgICAgICBjb2x1bW4uZmluYWxXaWR0aCA9IChjb2x1bW4udGhyZXNob2xkUGVyY2VudCAqIGNvbHVtbi53aWR0aEZyb21QZXJjZW50YWdlKSAvIDEwMDsKICAgICAgICBmaW5hbCArPSBjb2x1bW4uZmluYWxXaWR0aDsKICAgICAgICBjb2x1bW4uaGVpZ2h0ID0gdGhpcy5nZXRUYXNrSGVpZ2h0KCkgLSB0aGlzLnN0eWxlWydncmlkLWxpbmUtaG9yaXpvbnRhbCddWydzdHJva2Utd2lkdGgnXTsKICAgICAgfQogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3Qud2lkdGhGcm9tUGVyY2VudGFnZSA9IHBlcmNlbnRhZ2U7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC5maW5hbFdpZHRoID0gZmluYWw7CiAgICB9LAoKICAgIC8qKgogICAgICogUmVzZXQgdGFzayB0cmVlIC0gd2hpY2ggaXMgdXNlZCB0byBjcmVhdGUgdHJlZSBsaWtlIHN0cnVjdHVyZSBpbnNpZGUgdGFzayBsaXN0CiAgICAgKi8KICAgIHJlc2V0VGFza1RyZWUodGFza3MpIHsKICAgICAgdGhpcy4kc2V0KHRoaXMuc3RhdGUsICdyb290VGFzaycsIHsKICAgICAgICBpZDogbnVsbCwKICAgICAgICBsYWJlbDogJ3Jvb3QnLAogICAgICAgIGNoaWxkcmVuOiBbXSwKICAgICAgICBhbGxDaGlsZHJlbjogW10sCiAgICAgICAgcGFyZW50czogW10sCiAgICAgICAgcGFyZW50OiBudWxsLAogICAgICAgIF9fcm9vdDogdHJ1ZQogICAgICB9KTsKICAgICAgY29uc3QgdGFza3NCeUlkID0ge307CiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0YXNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykgewogICAgICAgIGxldCBjdXJyZW50ID0gdGFza3NbaV07CiAgICAgICAgY3VycmVudC5jaGlsZHJlbiA9IFtdOwogICAgICAgIGN1cnJlbnQuYWxsQ2hpbGRyZW4gPSBbXTsKICAgICAgICBjdXJyZW50LnBhcmVudCA9IG51bGw7CiAgICAgICAgY3VycmVudC5wYXJlbnRzID0gW107CiAgICAgICAgdGFza3NCeUlkW2N1cnJlbnQuaWRdID0gY3VycmVudDsKICAgICAgfQogICAgICByZXR1cm4gdGFza3NCeUlkOwogICAgfSwKCiAgICAvKioKICAgICAqIE1ha2UgdGFzayB0cmVlLCBhZnRlciByZXNldCAtIGxvb2sgYWJvdmUKICAgICAqCiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFzawogICAgICogQHJldHVybnMge29iamVjdH0gdGFza3Mgd2l0aCBjaGlsZHJlbiBhbmQgcGFyZW50cwogICAgICovCiAgICBtYWtlVGFza1RyZWUodGFzaywgdGFza3MpIHsKICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRhc2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXNrc1tpXTsKICAgICAgICBpZiAoY3VycmVudC5wYXJlbnRJZCA9PT0gdGFzay5pZCkgewogICAgICAgICAgaWYgKHRhc2sucGFyZW50cy5sZW5ndGgpIHsKICAgICAgICAgICAgdGFzay5wYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IGN1cnJlbnQucGFyZW50cy5wdXNoKHBhcmVudCkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCF0YXNrLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdfX3Jvb3QnKSkgewogICAgICAgICAgICBjdXJyZW50LnBhcmVudHMucHVzaCh0YXNrLmlkKTsKICAgICAgICAgICAgY3VycmVudC5wYXJlbnQgPSB0YXNrLmlkOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY3VycmVudC5wYXJlbnRzID0gW107CiAgICAgICAgICAgIGN1cnJlbnQucGFyZW50ID0gbnVsbDsKICAgICAgICAgIH0KICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLm1ha2VUYXNrVHJlZShjdXJyZW50LCB0YXNrcyk7CiAgICAgICAgICB0YXNrLmFsbENoaWxkcmVuLnB1c2goY3VycmVudC5pZCk7CiAgICAgICAgICB0YXNrLmNoaWxkcmVuLnB1c2goY3VycmVudC5pZCk7CiAgICAgICAgICBjdXJyZW50LmFsbENoaWxkcmVuLmZvckVhY2goY2hpbGRJZCA9PiB0YXNrLmFsbENoaWxkcmVuLnB1c2goY2hpbGRJZCkpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gdGFzazsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgdGFzayBieSBpZAogICAgICoKICAgICAqIEBwYXJhbSB7YW55fSB0YXNrSWQKICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH0gdGFzawogICAgICovCiAgICBnZXRUYXNrKHRhc2tJZCkgewogICAgICBpZiAodHlwZW9mIHRoaXMuc3RhdGUudGFza3NCeUlkW3Rhc2tJZF0gIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudGFza3NCeUlkW3Rhc2tJZF07CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGw7CiAgICB9LAoKICAgIC8qKgogICAgICogR2V0IGNoaWxkcmVuIHRhc2tzIGZvciBzcGVjaWZpZWQgdGFza0lkCiAgICAgKgogICAgICogQHBhcmFtIHthbnl9IHRhc2tJZAogICAgICogQHJldHVybnMge2FycmF5fSBjaGlsZHJlbgogICAgICovCiAgICBnZXRDaGlsZHJlbih0YXNrSWQpIHsKICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudGFza3MuZmlsdGVyKHRhc2sgPT4gdGFzay5wYXJlbnQgPT09IHRhc2tJZCk7CiAgICB9LAoKICAgIC8qKgogICAgICogSXMgdGFzayB2aXNpYmxlCiAgICAgKgogICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfFRhc2t9IHRhc2sKICAgICAqLwogICAgaXNUYXNrVmlzaWJsZSh0YXNrKSB7CiAgICAgIGlmICh0eXBlb2YgdGFzayA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRhc2sgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgdGFzayA9IHRoaXMuZ2V0VGFzayh0YXNrKTsKICAgICAgfQogICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGFzay5wYXJlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgaWYgKHRoaXMuZ2V0VGFzayh0YXNrLnBhcmVudHNbaV0pLmNvbGxhcHNlZCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgc3ZnCiAgICAgKgogICAgICogQHJldHVybnMge3N0cmluZ30gaHRtbCBzdmcgaW1hZ2Ugb2YgZ2FudHQKICAgICAqLwogICAgZ2V0U1ZHKCkgewogICAgICByZXR1cm4gdGhpcy5zdGF0ZS5vcHRpb25zLm1haW5WaWV3Lm91dGVySFRNTDsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgaW1hZ2UKICAgICAqCiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBpbWFnZSBmb3JtYXQKICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB3aGVuIHJlc29sdmVkIHJldHVybnMgYmFzZTY0IGltYWdlIHN0cmluZyBvZiBnYW50dAogICAgICovCiAgICBnZXRJbWFnZSh0eXBlID0gJ2ltYWdlL3BuZycpIHsKICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gewogICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpOwogICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7CiAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsKICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc3RhdGUub3B0aW9ucy5tYWluVmlldy5jbGllbnRXaWR0aDsKICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnN0YXRlLm9wdGlvbnMucm93c0hlaWdodDsKICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWcsIDAsIDApOwogICAgICAgICAgcmVzb2x2ZShjYW52YXMudG9EYXRhVVJMKHR5cGUpKTsKICAgICAgICB9OwogICAgICAgIGltZy5zcmMgPSAnZGF0YTppbWFnZS9zdmcreG1sLCcgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5nZXRTVkcoKSk7CiAgICAgIH0pOwogICAgfSwKCiAgICAvKioKICAgICAqIEdldCBnYW50dCB0b3RhbCBoZWlnaHQKICAgICAqCiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfQogICAgICovCiAgICBnZXRIZWlnaHQodmlzaWJsZVRhc2tzLCBvdXRlciA9IGZhbHNlKSB7CiAgICAgIGxldCBoZWlnaHQgPQogICAgICAgIHZpc2libGVUYXNrcy5sZW5ndGggKiAodGhpcy5zdGF0ZS5vcHRpb25zLnJvdy5oZWlnaHQgKyB0aGlzLnN0YXRlLm9wdGlvbnMuY2hhcnQuZ3JpZC5ob3Jpem9udGFsLmdhcCAqIDIpICsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaGVpZ2h0ICsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuc3Ryb2tlV2lkdGggKwogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5nYXA7CiAgICAgIGlmIChvdXRlcikgewogICAgICAgIGhlaWdodCArPSB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsQmFySGVpZ2h0OwogICAgICB9CiAgICAgIHJldHVybiBoZWlnaHQ7CiAgICB9LAoKICAgIC8qKgogICAgICogR2V0IG9uZSB0YXNrIGhlaWdodAogICAgICoKICAgICAqIEByZXR1cm5zIHtudW1iZXJ9CiAgICAgKi8KICAgIGdldFRhc2tIZWlnaHQod2l0aFN0cm9rZSA9IGZhbHNlKSB7CiAgICAgIGlmICh3aXRoU3Ryb2tlKSB7CiAgICAgICAgcmV0dXJuICgKICAgICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0ICsKICAgICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jaGFydC5ncmlkLmhvcml6b250YWwuZ2FwICogMiArCiAgICAgICAgICB0aGlzLnN0eWxlWydncmlkLWxpbmUtaG9yaXpvbnRhbCddWydzdHJva2Utd2lkdGgnXQogICAgICAgICk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0ICsgdGhpcy5zdGF0ZS5vcHRpb25zLmNoYXJ0LmdyaWQuaG9yaXpvbnRhbC5nYXAgKiAyOwogICAgfSwKCiAgICAvKioKICAgICAqIEdldCBzcGVjaWZpZWQgdGFza3MgaGVpZ2h0CiAgICAgKgogICAgICogQHJldHVybnMge251bWJlcn0KICAgICAqLwogICAgZ2V0VGFza3NIZWlnaHQodmlzaWJsZVRhc2tzKSB7CiAgICAgIHJldHVybiB2aXNpYmxlVGFza3MubGVuZ3RoICogdGhpcy5nZXRUYXNrSGVpZ2h0KCk7CiAgICB9LAoKICAgIC8qKgogICAgICogQ29udmVydCB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRvIHBpeGVsIG9mZnNldCBpbnNpZGUgY2hhcnQKICAgICAqCiAgICAgKiBAcGFyYW0ge2ludH0gbXMKICAgICAqIEByZXR1cm5zIHtudW1iZXJ9CiAgICAgKi8KICAgIHRpbWVUb1BpeGVsT2Zmc2V0WChtcykgewogICAgICBsZXQgeCA9IG1zIC0gdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZTsKICAgICAgaWYgKHgpIHsKICAgICAgICB4ID0geCAvIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lUGVyUGl4ZWw7CiAgICAgIH0KICAgICAgcmV0dXJuIHg7CiAgICB9LAoKICAgIC8qKgogICAgICogQ29udmVydCBwaXhlbCBvZmZzZXQgaW5zaWRlIGNoYXJ0IHRvIGNvcnJlc3BvbmRpbmcgdGltZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzCiAgICAgKgogICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsT2Zmc2V0WAogICAgICogQHJldHVybnMge2ludH0gbWlsbGlzZWNvbmRzCiAgICAgKi8KICAgIHBpeGVsT2Zmc2V0WFRvVGltZShwaXhlbE9mZnNldFgpIHsKICAgICAgbGV0IG9mZnNldCA9IHBpeGVsT2Zmc2V0WCArIHRoaXMuc3R5bGVbJ2dyaWQtbGluZS12ZXJ0aWNhbCddWydzdHJva2Utd2lkdGgnXSAvIDI7CiAgICAgIHJldHVybiBvZmZzZXQgKiB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVBlclBpeGVsICsgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBEZXRlcm1pbmUgaWYgZWxlbWVudCBpcyBpbnNpZGUgY3VycmVudCB2aWV3IHBvcnQKICAgICAqCiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIGVsZW1lbnQgcGxhY2VtZW50CiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBlbGVtZW50IHdpZHRoCiAgICAgKiBAcGFyYW0ge2ludH0gYnVmZmVyIC0gb3IgdGhyZXNob2xkLCBpZiBlbGVtZW50IGlzIG91dHNpZGUgdmlld3BvcnQgYnV0IG9mZnNldCBmcm9tIHZpZXcgcG9ydCBpcyBiZWxvdyB0aGlzIHZhbHVlIHJldHVybiB0cnVlCiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0KICAgICAqLwogICAgaXNJbnNpZGVWaWV3UG9ydCh4LCB3aWR0aCwgYnVmZmVyID0gNTAwMCkgewogICAgICByZXR1cm4gKAogICAgICAgICh4ICsgd2lkdGggKyBidWZmZXIgPj0gdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5sZWZ0ICYmCiAgICAgICAgICB4IC0gYnVmZmVyIDw9IHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQucmlnaHQpIHx8CiAgICAgICAgKHggLSBidWZmZXIgPD0gdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5sZWZ0ICYmCiAgICAgICAgICB4ICsgd2lkdGggKyBidWZmZXIgPj0gdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5yaWdodCkKICAgICAgKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBDaGFydCBzY3JvbGwgZXZlbnQgaGFuZGxlcgogICAgICoKICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2CiAgICAgKi8KICAgIG9uU2Nyb2xsQ2hhcnQoZXYpIHsKICAgICAgdGhpcy5fb25TY3JvbGxDaGFydCgKICAgICAgICB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJIb3Jpem9udGFsLnNjcm9sbExlZnQsCiAgICAgICAgdGhpcy5zdGF0ZS5yZWZzLmNoYXJ0U2Nyb2xsQ29udGFpbmVyVmVydGljYWwuc2Nyb2xsVG9wCiAgICAgICk7CiAgICB9LAoKICAgIC8qKgogICAgICogQWZ0ZXIgc2FtZSBhcyBhYm92ZSBidXQgd2l0aCBkaWZmZXJlbnQgYXJndW1lbnRzIC0gbm9ybWFsaXplZAogICAgICoKICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0CiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wCiAgICAgKi8KICAgIF9vblNjcm9sbENoYXJ0KGxlZnQsIHRvcCkgewogICAgICBpZiAodGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5sZWZ0ID09PSBsZWZ0ICYmIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQudG9wID09PSB0b3ApIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgY29uc3QgY2hhcnRDb250YWluZXJXaWR0aCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydENvbnRhaW5lci5jbGllbnRXaWR0aDsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5sZWZ0ID0gbGVmdDsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5yaWdodCA9IGxlZnQgKyBjaGFydENvbnRhaW5lcldpZHRoOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LnBlcmNlbnQgPSAobGVmdCAvIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50b3RhbFZpZXdEdXJhdGlvblB4KSAqIDEwMDsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC50b3AgPSB0b3A7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQudGltZSA9IHRoaXMucGl4ZWxPZmZzZXRYVG9UaW1lKGxlZnQpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LnRpbWVDZW50ZXIgPSB0aGlzLnBpeGVsT2Zmc2V0WFRvVGltZShsZWZ0ICsgY2hhcnRDb250YWluZXJXaWR0aCAvIDIpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LmRhdGVUaW1lLmxlZnQgPSBkYXlqcyh0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmNoYXJ0LnRpbWUpLnZhbHVlT2YoKTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC5jaGFydC5kYXRlVGltZS5yaWdodCA9IGRheWpzKAogICAgICAgIHRoaXMucGl4ZWxPZmZzZXRYVG9UaW1lKGxlZnQgKyB0aGlzLnN0YXRlLnJlZnMuY2hhcnQuY2xpZW50V2lkdGgpCiAgICAgICkudmFsdWVPZigpOwogICAgICB0aGlzLnNjcm9sbFRvKGxlZnQsIHRvcCk7CiAgICB9LAoKICAgIC8qKgogICAgICogU2Nyb2xsIGN1cnJlbnQgY2hhcnQgdG8gc3BlY2lmaWVkIHRpbWUgKGluIG1pbGxpc2Vjb25kcykKICAgICAqCiAgICAgKiBAcGFyYW0ge2ludH0gdGltZQogICAgICovCiAgICBzY3JvbGxUb1RpbWUodGltZSkgewogICAgICBsZXQgcG9zID0gdGhpcy50aW1lVG9QaXhlbE9mZnNldFgodGltZSk7CiAgICAgIGNvbnN0IGNoYXJ0Q29udGFpbmVyV2lkdGggPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRDb250YWluZXIuY2xpZW50V2lkdGg7CiAgICAgIHBvcyA9IHBvcyAtIGNoYXJ0Q29udGFpbmVyV2lkdGggLyAyOwogICAgICBpZiAocG9zID4gdGhpcy5zdGF0ZS5vcHRpb25zLndpZHRoKSB7CiAgICAgICAgcG9zID0gdGhpcy5zdGF0ZS5vcHRpb25zLndpZHRoIC0gY2hhcnRDb250YWluZXJXaWR0aDsKICAgICAgfQogICAgICB0aGlzLnNjcm9sbFRvKHBvcyk7CiAgICB9LAoKICAgIC8qKgogICAgICogU2Nyb2xsIGNoYXJ0IG9yIHRhc2sgbGlzdCB0byBzcGVjaWZpZWQgcGl4ZWwgdmFsdWVzCiAgICAgKgogICAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gbGVmdAogICAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gdG9wCiAgICAgKi8KICAgIHNjcm9sbFRvKGxlZnQgPSBudWxsLCB0b3AgPSBudWxsKSB7CiAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7CiAgICAgICAgdGhpcy5zdGF0ZS5yZWZzLmNoYXJ0Q2FsZW5kYXJDb250YWluZXIuc2Nyb2xsTGVmdCA9IGxlZnQ7CiAgICAgICAgdGhpcy5zdGF0ZS5yZWZzLmNoYXJ0R3JhcGhDb250YWluZXIuc2Nyb2xsTGVmdCA9IGxlZnQ7CiAgICAgICAgdGhpcy5zdGF0ZS5yZWZzLmNoYXJ0U2Nyb2xsQ29udGFpbmVySG9yaXpvbnRhbC5zY3JvbGxMZWZ0ID0gbGVmdDsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmxlZnQgPSBsZWZ0OwogICAgICB9CiAgICAgIGlmICh0b3AgIT09IG51bGwpIHsKICAgICAgICB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJWZXJ0aWNhbC5zY3JvbGxUb3AgPSB0b3A7CiAgICAgICAgdGhpcy5zdGF0ZS5yZWZzLmNoYXJ0R3JhcGguc2Nyb2xsVG9wID0gdG9wOwogICAgICAgIHRoaXMuc3RhdGUucmVmcy50YXNrTGlzdEl0ZW1zLnNjcm9sbFRvcCA9IHRvcDsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLnRvcCA9IHRvcDsKICAgICAgICB0aGlzLnN5bmNTY3JvbGxUb3AoKTsKICAgICAgfQogICAgfSwKCiAgICAvKioKICAgICAqIEFmdGVyIHNvbWUgYWN0aW9ucyBsaWtlIHRpbWUgem9vbSBjaGFuZ2Ugd2UgbmVlZCB0byByZWNvbXBlbnNhdGUgc2Nyb2xsIHBvc2l0aW9uCiAgICAgKiBzbyBhcyBhIHJlc3VsdCBldmVyeXRoaW5nIHdpbGwgYmUgaW4gc2FtZSBwbGFjZQogICAgICovCiAgICBmaXhTY3JvbGxQb3MoKSB7CiAgICAgIHRoaXMuc2Nyb2xsVG9UaW1lKHRoaXMuc3RhdGUub3B0aW9ucy5zY3JvbGwuY2hhcnQudGltZUNlbnRlcik7CiAgICB9LAoKICAgIC8qKgogICAgICogTW91c2Ugd2hlZWwgZXZlbnQgaGFuZGxlcgogICAgICovCiAgICBvbldoZWVsQ2hhcnQoZXYpIHsKICAgICAgaWYgKCFldi5zaGlmdEtleSAmJiBldi5kZWx0YVggPT09IDApIHsKICAgICAgICBsZXQgdG9wID0gdGhpcy5zdGF0ZS5vcHRpb25zLnNjcm9sbC50b3AgKyBldi5kZWx0YVk7CiAgICAgICAgY29uc3QgY2hhcnRDbGllbnRIZWlnaHQgPSB0aGlzLnN0YXRlLm9wdGlvbnMucm93c0hlaWdodDsKICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRHcmFwaC5zY3JvbGxIZWlnaHQgLSBjaGFydENsaWVudEhlaWdodDsKICAgICAgICBpZiAodG9wIDwgMCkgewogICAgICAgICAgdG9wID0gMDsKICAgICAgICB9IGVsc2UgaWYgKHRvcCA+IHNjcm9sbEhlaWdodCkgewogICAgICAgICAgdG9wID0gc2Nyb2xsSGVpZ2h0OwogICAgICAgIH0KICAgICAgICB0aGlzLnNjcm9sbFRvKG51bGwsIHRvcCk7CiAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkgJiYgZXYuZGVsdGFYID09PSAwKSB7CiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmxlZnQgKyBldi5kZWx0YVk7CiAgICAgICAgY29uc3QgY2hhcnRDbGllbnRXaWR0aCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydFNjcm9sbENvbnRhaW5lckhvcml6b250YWwuY2xpZW50V2lkdGg7CiAgICAgICAgY29uc3Qgc2Nyb2xsV2lkdGggPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJIb3Jpem9udGFsLnNjcm9sbFdpZHRoIC0gY2hhcnRDbGllbnRXaWR0aDsKICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgIGxlZnQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAobGVmdCA+IHNjcm9sbFdpZHRoKSB7CiAgICAgICAgICBsZWZ0ID0gc2Nyb2xsV2lkdGg7CiAgICAgICAgfQogICAgICAgIHRoaXMuc2Nyb2xsVG8obGVmdCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnN0YXRlLm9wdGlvbnMuc2Nyb2xsLmxlZnQgKyBldi5kZWx0YVg7CiAgICAgICAgY29uc3QgY2hhcnRDbGllbnRXaWR0aCA9IHRoaXMuc3RhdGUucmVmcy5jaGFydFNjcm9sbENvbnRhaW5lckhvcml6b250YWwuY2xpZW50V2lkdGg7CiAgICAgICAgY29uc3Qgc2Nyb2xsV2lkdGggPSB0aGlzLnN0YXRlLnJlZnMuY2hhcnRTY3JvbGxDb250YWluZXJIb3Jpem9udGFsLnNjcm9sbFdpZHRoIC0gY2hhcnRDbGllbnRXaWR0aDsKICAgICAgICBpZiAobGVmdCA8IDApIHsKICAgICAgICAgIGxlZnQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAobGVmdCA+IHNjcm9sbFdpZHRoKSB7CiAgICAgICAgICBsZWZ0ID0gc2Nyb2xsV2lkdGg7CiAgICAgICAgfQogICAgICAgIHRoaXMuc2Nyb2xsVG8obGVmdCk7CiAgICAgIH0KICAgIH0sCgogICAgLyoqCiAgICAgKiBUaW1lIHpvb20gY2hhbmdlIGV2ZW50IGhhbmRsZXIKICAgICAqLwogICAgb25UaW1lWm9vbUNoYW5nZSh0aW1lWm9vbSkgewogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVpvb20gPSB0aW1lWm9vbTsKICAgICAgdGhpcy5yZWNhbGN1bGF0ZVRpbWVzKCk7CiAgICAgIHRoaXMuY2FsY3VsYXRlU3RlcHMoKTsKICAgICAgdGhpcy5maXhTY3JvbGxQb3MoKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBSb3cgaGVpZ2h0IGNoYW5nZSBldmVudCBoYW5kbGVyCiAgICAgKi8KICAgIG9uUm93SGVpZ2h0Q2hhbmdlKGhlaWdodCkgewogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMucm93LmhlaWdodCA9IGhlaWdodDsKICAgICAgdGhpcy5jYWxjdWxhdGVUYXNrTGlzdENvbHVtbnNEaW1lbnNpb25zKCk7CiAgICAgIHRoaXMuc3luY1Njcm9sbFRvcCgpOwogICAgfSwKCiAgICAvKioKICAgICAqIFNjb3BlIGNoYW5nZSBldmVudCBoYW5kbGVyCiAgICAgKi8KICAgIG9uU2NvcGVDaGFuZ2UodmFsdWUpIHsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnNjb3BlLmJlZm9yZSA9IHZhbHVlOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuc2NvcGUuYWZ0ZXIgPSB2YWx1ZTsKICAgICAgdGhpcy5pbml0VGltZXMoKTsKICAgICAgdGhpcy5jYWxjdWxhdGVTdGVwcygpOwogICAgICB0aGlzLmNvbXB1dGVDYWxlbmRhcldpZHRocygpOwogICAgICB0aGlzLmZpeFNjcm9sbFBvcygpOwogICAgfSwKCiAgICAvKioKICAgICAqIFRhc2sgbGlzdCB3aWR0aCBjaGFuZ2UgZXZlbnQgaGFuZGxlcgogICAgICovCiAgICBvblRhc2tMaXN0V2lkdGhDaGFuZ2UodmFsdWUpIHsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LnBlcmNlbnQgPSB2YWx1ZTsKICAgICAgdGhpcy5jYWxjdWxhdGVUYXNrTGlzdENvbHVtbnNEaW1lbnNpb25zKCk7CiAgICAgIHRoaXMuZml4U2Nyb2xsUG9zKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogVGFzayBsaXN0IGNvbHVtbiB3aWR0aCBjaGFuZ2UgZXZlbnQgaGFuZGxlcgogICAgICovCiAgICBvblRhc2tMaXN0Q29sdW1uV2lkdGhDaGFuZ2UoKSB7CiAgICAgIHRoaXMuY2FsY3VsYXRlVGFza0xpc3RDb2x1bW5zRGltZW5zaW9ucygpOwogICAgICB0aGlzLmZpeFNjcm9sbFBvcygpOwogICAgfSwKCiAgICAvKioKICAgICAqIExpc3RlbiB0byBzcGVjaWZpZWQgZXZlbnQgbmFtZXMKICAgICAqLwogICAgaW5pdGlhbGl6ZUV2ZW50cygpIHsKICAgICAgdGhpcy4kb24oJ2NoYXJ0LXNjcm9sbC1ob3Jpem9udGFsJywgdGhpcy5vblNjcm9sbENoYXJ0KTsKICAgICAgdGhpcy4kb24oJ2NoYXJ0LXNjcm9sbC12ZXJ0aWNhbCcsIHRoaXMub25TY3JvbGxDaGFydCk7CiAgICAgIHRoaXMuJG9uKCdjaGFydC13aGVlbCcsIHRoaXMub25XaGVlbENoYXJ0KTsKICAgICAgdGhpcy4kb24oJ3RpbWVzLXRpbWVab29tLWNoYW5nZScsIHRoaXMub25UaW1lWm9vbUNoYW5nZSk7CiAgICAgIHRoaXMuJG9uKCdyb3ctaGVpZ2h0LWNoYW5nZScsIHRoaXMub25Sb3dIZWlnaHRDaGFuZ2UpOwogICAgICB0aGlzLiRvbignc2NvcGUtY2hhbmdlJywgdGhpcy5vblNjb3BlQ2hhbmdlKTsKICAgICAgdGhpcy4kb24oJ3Rhc2tMaXN0LXdpZHRoLWNoYW5nZScsIHRoaXMub25UYXNrTGlzdFdpZHRoQ2hhbmdlKTsKICAgICAgdGhpcy4kb24oJ3Rhc2tMaXN0LWNvbHVtbi13aWR0aC1jaGFuZ2UnLCB0aGlzLm9uVGFza0xpc3RDb2x1bW5XaWR0aENoYW5nZSk7CiAgICB9LAoKICAgIC8qKgogICAgICogV2hlbiBzb21lIGFjdGlvbiB3YXMgcGVyZm9ybWVkIChzY2FsZSBjaGFuZ2UgZm9yIGV4YW1wbGUpIC0gcmVjYWxjdWxhdGUgdGltZSB2YXJpYWJsZXMKICAgICAqLwogICAgcmVjYWxjdWxhdGVUaW1lcygpIHsKICAgICAgbGV0IG1heCA9IHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lU2NhbGUgKiA2MDsKICAgICAgbGV0IG1pbiA9IHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lU2NhbGU7CiAgICAgIGxldCBzdGVwcyA9IG1heCAvIG1pbjsKICAgICAgbGV0IHBlcmNlbnQgPSB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVpvb20gLyAxMDA7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lUGVyUGl4ZWwgPQogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lU2NhbGUgKiBzdGVwcyAqIHBlcmNlbnQgKyBNYXRoLnBvdygyLCB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudGltZVpvb20pOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudG90YWxWaWV3RHVyYXRpb25NcyA9IGRheWpzKHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5sYXN0VGltZSkuZGlmZigKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuZmlyc3RUaW1lLAogICAgICAgICdtaWxsaXNlY29uZHMnCiAgICAgICk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50b3RhbFZpZXdEdXJhdGlvblB4ID0KICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudG90YWxWaWV3RHVyYXRpb25NcyAvIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lUGVyUGl4ZWw7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy53aWR0aCA9CiAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRvdGFsVmlld0R1cmF0aW9uUHggKyB0aGlzLnN0eWxlWydncmlkLWxpbmUtdmVydGljYWwnXVsnc3Ryb2tlLXdpZHRoJ107CiAgICB9LAoKICAgIC8qKgogICAgICogSW5pdGlhbGl6ZSB0aW1lIHZhcmlhYmxlcwogICAgICovCiAgICBpbml0VGltZXMoKSB7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRpbWUgPSBkYXlqcyh0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuZmlyc3RUYXNrVGltZSkKICAgICAgICAubG9jYWxlKHRoaXMuc3RhdGUub3B0aW9ucy5sb2NhbGUubmFtZSkKICAgICAgICAuc3RhcnRPZignZGF5JykKICAgICAgICAuc3VidHJhY3QodGhpcy5zdGF0ZS5vcHRpb25zLnNjb3BlLmJlZm9yZSwgJ2RheXMnKQogICAgICAgIC5zdGFydE9mKCdkYXknKQogICAgICAgIC52YWx1ZU9mKCk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5sYXN0VGltZSA9IGRheWpzKHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5sYXN0VGFza1RpbWUpCiAgICAgICAgLmxvY2FsZSh0aGlzLnN0YXRlLm9wdGlvbnMubG9jYWxlLm5hbWUpCiAgICAgICAgLmVuZE9mKCdkYXknKQogICAgICAgIC5hZGQodGhpcy5zdGF0ZS5vcHRpb25zLnNjb3BlLmFmdGVyLCAnZGF5cycpCiAgICAgICAgLmVuZE9mKCdkYXknKQogICAgICAgIC52YWx1ZU9mKCk7CiAgICAgIHRoaXMucmVjYWxjdWxhdGVUaW1lcygpOwogICAgfSwKCiAgICAvKioKICAgICAqIENhbGN1bGF0ZSBzdGVwcwogICAgICogU3RlcHMgYXJlIGRheXMgYnkgZGVmYXVsdAogICAgICogRWFjaCBzdGVwIGNvbnRhaW4gaW5mb3JtYXRpb24gYWJvdXQgdGltZSBvZmZzZXQgYW5kIHBpeGVsIG9mZnNldCBvZiB0aGlzIHRpbWUgaW5zaWRlIGdhbnR0IGNoYXJ0CiAgICAgKi8KICAgIGNhbGN1bGF0ZVN0ZXBzKCkgewogICAgICBjb25zdCBzdGVwcyA9IFtdOwogICAgICBjb25zdCBsYXN0TXMgPSBkYXlqcyh0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWUpLnZhbHVlT2YoKTsKICAgICAgY29uc3QgY3VycmVudERhdGUgPSBkYXlqcyh0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuZmlyc3RUaW1lKTsKICAgICAgc3RlcHMucHVzaCh7CiAgICAgICAgdGltZTogY3VycmVudERhdGUudmFsdWVPZigpLAogICAgICAgIG9mZnNldDogewogICAgICAgICAgbXM6IDAsCiAgICAgICAgICBweDogMAogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZvciAoCiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gZGF5anModGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSkKICAgICAgICAgIC5hZGQoMSwgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBEdXJhdGlvbikKICAgICAgICAgIC5zdGFydE9mKCdkYXknKTsKICAgICAgICBjdXJyZW50RGF0ZS52YWx1ZU9mKCkgPD0gbGFzdE1zOwogICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGUuYWRkKDEsIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwRHVyYXRpb24pLnN0YXJ0T2YoJ2RheScpCiAgICAgICkgewogICAgICAgIGNvbnN0IG9mZnNldE1zID0gY3VycmVudERhdGUuZGlmZih0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuZmlyc3RUaW1lLCAnbWlsbGlzZWNvbmRzJyk7CiAgICAgICAgY29uc3Qgb2Zmc2V0UHggPSBvZmZzZXRNcyAvIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50aW1lUGVyUGl4ZWw7CiAgICAgICAgY29uc3Qgc3RlcCA9IHsKICAgICAgICAgIHRpbWU6IGN1cnJlbnREYXRlLnZhbHVlT2YoKSwKICAgICAgICAgIG9mZnNldDogewogICAgICAgICAgICBtczogb2Zmc2V0TXMsCiAgICAgICAgICAgIHB4OiBvZmZzZXRQeAogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgY29uc3QgcHJldmlvdXNTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07CiAgICAgICAgcHJldmlvdXNTdGVwLndpZHRoID0gewogICAgICAgICAgbXM6IG9mZnNldE1zIC0gcHJldmlvdXNTdGVwLm9mZnNldC5tcywKICAgICAgICAgIHB4OiBvZmZzZXRQeCAtIHByZXZpb3VzU3RlcC5vZmZzZXQucHgKICAgICAgICB9OwogICAgICAgIHN0ZXBzLnB1c2goc3RlcCk7CiAgICAgIH0KICAgICAgY29uc3QgbGFzdFN0ZXAgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTsKICAgICAgbGFzdFN0ZXAud2lkdGggPSB7CiAgICAgICAgbXM6IHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy50b3RhbFZpZXdEdXJhdGlvbk1zIC0gbGFzdFN0ZXAub2Zmc2V0Lm1zLAogICAgICAgIHB4OiB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMudG90YWxWaWV3RHVyYXRpb25QeCAtIGxhc3RTdGVwLm9mZnNldC5weAogICAgICB9OwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcHMgPSBzdGVwczsKICAgIH0sCgogICAgLyoqCiAgICAgKiBDYWxjdWxhdGUgY2FsZW5kYXIgd2lkdGhzIC0gd2hlbiBzY2FsZSB3YXMgY2hhbmdlZCBmb3IgZXhhbXBsZQogICAgICovCiAgICBjb21wdXRlQ2FsZW5kYXJXaWR0aHMoKSB7CiAgICAgIHRoaXMuY29tcHV0ZURheVdpZHRocygpOwogICAgICB0aGlzLmNvbXB1dGVIb3VyV2lkdGhzKCk7CiAgICAgIHRoaXMuY29tcHV0ZU1vbnRoV2lkdGhzKCk7CiAgICB9LAoKICAgIC8qKgogICAgICogQ29tcHV0ZSB3aWR0aCBvZiBjYWxlbmRhciBob3VycyBjb2x1bW4gd2lkdGhzIGJhc2luZyBvbiB0ZXh0IHdpZHRocwogICAgICovCiAgICBjb21wdXRlSG91cldpZHRocygpIHsKICAgICAgY29uc3Qgc3R5bGUgPSB7IC4uLnRoaXMuc3R5bGVbJ2NhbGVuZGFyLXJvdy10ZXh0J10sIC4uLnRoaXMuc3R5bGVbJ2NhbGVuZGFyLXJvdy10ZXh0LS1ob3VyJ10gfTsKICAgICAgdGhpcy5zdGF0ZS5jdHguZm9udCA9IHN0eWxlWydmb250LXNpemUnXSArICcgJyArIHN0eWxlWydmb250LWZhbWlseSddOwogICAgICBjb25zdCBsb2NhbGVOYW1lID0gdGhpcy5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lOwogICAgICBsZXQgY3VycmVudERhdGUgPSBkYXlqcygnMjAxOC0wMS0wMVQwMDowMDowMCcpLmxvY2FsZShsb2NhbGVOYW1lKTsgLy8gYW55IGRhdGUgd2lsbCBiZSBnb29kIGZvciBob3VycwogICAgICBsZXQgbWF4V2lkdGhzID0gdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIubWF4V2lkdGhzOwogICAgICBpZiAobWF4V2lkdGhzLmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBmb3IgKGxldCBmb3JtYXROYW1lIGluIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLmZvcm1hdCkgewogICAgICAgIG1heFdpZHRoc1tmb3JtYXROYW1lXSA9IDA7CiAgICAgIH0KICAgICAgZm9yIChsZXQgaG91ciA9IDA7IGhvdXIgPCAyNDsgaG91cisrKSB7CiAgICAgICAgbGV0IHdpZHRocyA9IHsgaG91ciB9OwogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgaW4gdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuZm9ybWF0KSB7CiAgICAgICAgICBjb25zdCBob3VyRm9ybWF0dGVkID0gdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIuZm9ybWF0W2Zvcm1hdE5hbWVdKGN1cnJlbnREYXRlKTsKICAgICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLmZvcm1hdHRlZFtmb3JtYXROYW1lXS5wdXNoKGhvdXJGb3JtYXR0ZWQpOwogICAgICAgICAgd2lkdGhzW2Zvcm1hdE5hbWVdID0gdGhpcy5zdGF0ZS5jdHgubWVhc3VyZVRleHQoaG91ckZvcm1hdHRlZCkud2lkdGg7CiAgICAgICAgfQogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLndpZHRocy5wdXNoKHdpZHRocyk7CiAgICAgICAgZm9yIChsZXQgZm9ybWF0TmFtZSBpbiB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5mb3JtYXQpIHsKICAgICAgICAgIGlmICh3aWR0aHNbZm9ybWF0TmFtZV0gPiBtYXhXaWR0aHNbZm9ybWF0TmFtZV0pIHsKICAgICAgICAgICAgbWF4V2lkdGhzW2Zvcm1hdE5hbWVdID0gd2lkdGhzW2Zvcm1hdE5hbWVdOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlLmFkZCgxLCAnaG91cicpOwogICAgICB9CiAgICB9LAoKICAgIC8qKgogICAgICogQ29tcHV0ZSBjYWxlbmRhciBkYXlzIGNvbHVtbiB3aWR0aHMgYmFzaW5nIG9uIHRleHQgd2lkdGhzCiAgICAgKi8KICAgIGNvbXB1dGVEYXlXaWR0aHMoKSB7CiAgICAgIGNvbnN0IHN0eWxlID0geyAuLi50aGlzLnN0eWxlWydjYWxlbmRhci1yb3ctdGV4dCddLCAuLi50aGlzLnN0eWxlWydjYWxlbmRhci1yb3ctdGV4dC0tZGF5J10gfTsKICAgICAgdGhpcy5zdGF0ZS5jdHguZm9udCA9IHN0eWxlWydmb250LXNpemUnXSArICcgJyArIHN0eWxlWydmb250LWZhbWlseSddOwogICAgICBjb25zdCBsb2NhbGVOYW1lID0gdGhpcy5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lOwogICAgICBsZXQgY3VycmVudERhdGUgPSBkYXlqcyh0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcHNbMF0udGltZSkubG9jYWxlKGxvY2FsZU5hbWUpOwogICAgICBsZXQgbWF4V2lkdGhzID0gdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5tYXhXaWR0aHM7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkud2lkdGhzID0gW107CiAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuZm9ybWF0KS5mb3JFYWNoKGZvcm1hdE5hbWUgPT4gewogICAgICAgIG1heFdpZHRoc1tmb3JtYXROYW1lXSA9IDA7CiAgICAgIH0pOwogICAgICBmb3IgKGxldCBkYXkgPSAwLCBkYXlzTGVuID0gdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBzLmxlbmd0aDsgZGF5IDwgZGF5c0xlbjsgZGF5KyspIHsKICAgICAgICBjb25zdCB3aWR0aHMgPSB7CiAgICAgICAgICBkYXkKICAgICAgICB9OwogICAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuZm9ybWF0KS5mb3JFYWNoKGZvcm1hdE5hbWUgPT4gewogICAgICAgICAgd2lkdGhzW2Zvcm1hdE5hbWVdID0gdGhpcy5zdGF0ZS5jdHgubWVhc3VyZVRleHQoCiAgICAgICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuZm9ybWF0W2Zvcm1hdE5hbWVdKGN1cnJlbnREYXRlKQogICAgICAgICAgKS53aWR0aDsKICAgICAgICB9KTsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LndpZHRocy5wdXNoKHdpZHRocyk7CiAgICAgICAgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5mb3JtYXQpLmZvckVhY2goZm9ybWF0TmFtZSA9PiB7CiAgICAgICAgICBpZiAod2lkdGhzW2Zvcm1hdE5hbWVdID4gbWF4V2lkdGhzW2Zvcm1hdE5hbWVdKSB7CiAgICAgICAgICAgIG1heFdpZHRoc1tmb3JtYXROYW1lXSA9IHdpZHRoc1tmb3JtYXROYW1lXTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlLmFkZCgxLCAnZGF5Jyk7CiAgICAgIH0KICAgIH0sCgogICAgLyoqCiAgICAgKiBNb250aHMgY291bnQKICAgICAqCiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBudW1iZXIgb2YgZGlmZmVyZW50IG1vbnRocyBpbiBzcGVjaWZpZWQgdGltZSByYW5nZQogICAgICoKICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tVGltZSAtIGRhdGUgaW4gbXMKICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1RpbWUgLSBkYXRlIGluIG1zCiAgICAgKgogICAgICogQHJldHVybnMge251bWJlcn0gZGlmZmVyZW50IG1vbnRocyBjb3VudAogICAgICovCiAgICBtb250aHNDb3VudChmcm9tVGltZSwgdG9UaW1lKSB7CiAgICAgIGlmIChmcm9tVGltZSA+IHRvVGltZSkgewogICAgICAgIHJldHVybiAwOwogICAgICB9CiAgICAgIGxldCBjdXJyZW50TW9udGggPSBkYXlqcyhmcm9tVGltZSk7CiAgICAgIGxldCBwcmV2aW91c01vbnRoID0gY3VycmVudE1vbnRoLmNsb25lKCk7CiAgICAgIGxldCBtb250aHNDb3VudCA9IDE7CiAgICAgIHdoaWxlIChjdXJyZW50TW9udGgudmFsdWVPZigpIDw9IHRvVGltZSkgewogICAgICAgIGN1cnJlbnRNb250aCA9IGN1cnJlbnRNb250aC5hZGQoMSwgJ2RheScpOwogICAgICAgIGlmIChwcmV2aW91c01vbnRoLm1vbnRoKCkgIT09IGN1cnJlbnRNb250aC5tb250aCgpKSB7CiAgICAgICAgICBtb250aHNDb3VudCsrOwogICAgICAgIH0KICAgICAgICBwcmV2aW91c01vbnRoID0gY3VycmVudE1vbnRoLmNsb25lKCk7CiAgICAgIH0KICAgICAgcmV0dXJuIG1vbnRoc0NvdW50OwogICAgfSwKCiAgICAvKioKICAgICAqIENvbXB1dGUgbW9udGggY2FsZW5kYXIgY29sdW1ucyB3aWR0aHMgYmFzaW5nIG9uIHRleHQgd2lkdGhzCiAgICAgKi8KICAgIGNvbXB1dGVNb250aFdpZHRocygpIHsKICAgICAgY29uc3Qgc3R5bGUgPSB7IC4uLnRoaXMuc3R5bGVbJ2NhbGVuZGFyLXJvdy10ZXh0J10sIC4uLnRoaXMuc3R5bGVbJ2NhbGVuZGFyLXJvdy10ZXh0LS1tb250aCddIH07CiAgICAgIHRoaXMuc3RhdGUuY3R4LmZvbnQgPSBzdHlsZVsnZm9udC1zaXplJ10gKyAnICcgKyBzdHlsZVsnZm9udC1mYW1pbHknXTsKICAgICAgbGV0IG1heFdpZHRocyA9IHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5tYXhXaWR0aHM7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC53aWR0aHMgPSBbXTsKICAgICAgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmZvcm1hdCkuZm9yRWFjaChmb3JtYXROYW1lID0+IHsKICAgICAgICBtYXhXaWR0aHNbZm9ybWF0TmFtZV0gPSAwOwogICAgICB9KTsKICAgICAgY29uc3QgbG9jYWxlTmFtZSA9IHRoaXMuc3RhdGUub3B0aW9ucy5sb2NhbGUubmFtZTsKICAgICAgbGV0IGN1cnJlbnREYXRlID0gZGF5anModGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSkubG9jYWxlKGxvY2FsZU5hbWUpOwogICAgICBjb25zdCBtb250aHNDb3VudCA9IHRoaXMubW9udGhzQ291bnQodGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSwgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lKTsKICAgICAgZm9yIChsZXQgbW9udGggPSAwOyBtb250aCA8IG1vbnRoc0NvdW50OyBtb250aCsrKSB7CiAgICAgICAgY29uc3Qgd2lkdGhzID0gewogICAgICAgICAgbW9udGgKICAgICAgICB9OwogICAgICAgIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5mb3JtYXQpLmZvckVhY2goZm9ybWF0TmFtZSA9PiB7CiAgICAgICAgICB3aWR0aHNbZm9ybWF0TmFtZV0gPSB0aGlzLnN0YXRlLmN0eC5tZWFzdXJlVGV4dCgKICAgICAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmZvcm1hdFtmb3JtYXROYW1lXShjdXJyZW50RGF0ZSkKICAgICAgICAgICkud2lkdGg7CiAgICAgICAgfSk7CiAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLndpZHRocy5wdXNoKHdpZHRocyk7CiAgICAgICAgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmZvcm1hdCkuZm9yRWFjaChmb3JtYXROYW1lID0+IHsKICAgICAgICAgIGlmICh3aWR0aHNbZm9ybWF0TmFtZV0gPiBtYXhXaWR0aHNbZm9ybWF0TmFtZV0pIHsKICAgICAgICAgICAgbWF4V2lkdGhzW2Zvcm1hdE5hbWVdID0gd2lkdGhzW2Zvcm1hdE5hbWVdOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGUuYWRkKDEsICdtb250aCcpOwogICAgICB9CiAgICB9LAoKICAgIC8qKgogICAgICogUHJlcGFyZSB0aW1lIGFuZCBkYXRlIHZhcmlhYmxlcyBmb3IgZ2FudHQKICAgICAqLwogICAgcHJlcGFyZURhdGVzKCkgewogICAgICBsZXQgZmlyc3RUYXNrVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOwogICAgICBsZXQgbGFzdFRhc2tUaW1lID0gMDsKICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW4gPSB0aGlzLnN0YXRlLnRhc2tzLmxlbmd0aDsgaW5kZXggPCBsZW47IGluZGV4KyspIHsKICAgICAgICBsZXQgdGFzayA9IHRoaXMuc3RhdGUudGFza3NbaW5kZXhdOwogICAgICAgIGlmICh0YXNrLnN0YXJ0VGltZSA8IGZpcnN0VGFza1RpbWUpIHsKICAgICAgICAgIGZpcnN0VGFza1RpbWUgPSB0YXNrLnN0YXJ0VGltZTsKICAgICAgICB9CiAgICAgICAgaWYgKHRhc2suc3RhcnRUaW1lICsgdGFzay5kdXJhdGlvbiA+IGxhc3RUYXNrVGltZSkgewogICAgICAgICAgbGFzdFRhc2tUaW1lID0gdGFzay5zdGFydFRpbWUgKyB0YXNrLmR1cmF0aW9uOwogICAgICAgIH0KICAgICAgfQogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGltZXMuZmlyc3RUYXNrVGltZSA9IGZpcnN0VGFza1RpbWU7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5sYXN0VGFza1RpbWUgPSBsYXN0VGFza1RpbWU7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRpbWUgPSBkYXlqcyhmaXJzdFRhc2tUaW1lKQogICAgICAgIC5sb2NhbGUodGhpcy5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lKQogICAgICAgIC5zdGFydE9mKCdkYXknKQogICAgICAgIC5zdWJ0cmFjdCh0aGlzLnN0YXRlLm9wdGlvbnMuc2NvcGUuYmVmb3JlLCAnZGF5cycpCiAgICAgICAgLnN0YXJ0T2YoJ2RheScpCiAgICAgICAgLnZhbHVlT2YoKTsKICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lID0gZGF5anMobGFzdFRhc2tUaW1lKQogICAgICAgIC5sb2NhbGUodGhpcy5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lKQogICAgICAgIC5lbmRPZignZGF5JykKICAgICAgICAuYWRkKHRoaXMuc3RhdGUub3B0aW9ucy5zY29wZS5hZnRlciwgJ2RheXMnKQogICAgICAgIC5lbmRPZignZGF5JykKICAgICAgICAudmFsdWVPZigpOwogICAgfSwKCiAgICAvKioKICAgICAqIFNldHVwIGFuZCBjYWxjdWxhdGUgZXZlcnl0aGluZwogICAgICovCiAgICBzZXR1cChpdHNVcGRhdGUgPSAnJykgewogICAgICB0aGlzLmluaXRpYWxpemUoaXRzVXBkYXRlKTsKICAgICAgdGhpcy5wcmVwYXJlRGF0ZXMoKTsKICAgICAgdGhpcy5pbml0VGltZXMoKTsKICAgICAgdGhpcy5jYWxjdWxhdGVTdGVwcygpOwogICAgICB0aGlzLmNvbXB1dGVDYWxlbmRhcldpZHRocygpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3Qud2lkdGggPSB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3QuY29sdW1ucy5yZWR1Y2UoCiAgICAgICAgKHByZXYsIGN1cnJlbnQpID0+IHsKICAgICAgICAgIHJldHVybiB7IHdpZHRoOiBwcmV2LndpZHRoICsgY3VycmVudC53aWR0aCB9OwogICAgICAgIH0sCiAgICAgICAgeyB3aWR0aDogMCB9CiAgICAgICkud2lkdGg7CiAgICB9LAoKICAgIC8qKgogICAgICogR2xvYmFsIHJlc2l6ZSBldmVudCAoZnJvbSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikKICAgICAqLwogICAgZ2xvYmFsT25SZXNpemUoKSB7CiAgICAgIGlmICh0eXBlb2YgdGhpcy4kZWwgPT09ICd1bmRlZmluZWQnIHx8ICF0aGlzLiRlbCkgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuY2xpZW50V2lkdGggPSB0aGlzLiRlbC5jbGllbnRXaWR0aDsKICAgICAgaWYgKAogICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC53aWR0aEZyb21QZXJjZW50YWdlID4KICAgICAgICAodGhpcy5zdGF0ZS5vcHRpb25zLmNsaWVudFdpZHRoIC8gMTAwKSAqIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC53aWR0aFRocmVzaG9sZAogICAgICApIHsKICAgICAgICBjb25zdCBkaWZmID0KICAgICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC53aWR0aEZyb21QZXJjZW50YWdlIC0KICAgICAgICAgICh0aGlzLnN0YXRlLm9wdGlvbnMuY2xpZW50V2lkdGggLyAxMDApICogdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LndpZHRoVGhyZXNob2xkOwogICAgICAgIGxldCBkaWZmUGVyY2VudCA9IDEwMCAtIChkaWZmIC8gdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LndpZHRoRnJvbVBlcmNlbnRhZ2UpICogMTAwOwogICAgICAgIGlmIChkaWZmUGVyY2VudCA8IDApIHsKICAgICAgICAgIGRpZmZQZXJjZW50ID0gMDsKICAgICAgICB9CiAgICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLnRhc2tMaXN0LmNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4gewogICAgICAgICAgY29sdW1uLnRocmVzaG9sZFBlcmNlbnQgPSBkaWZmUGVyY2VudDsKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMudGFza0xpc3QuY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7CiAgICAgICAgICBjb2x1bW4udGhyZXNob2xkUGVyY2VudCA9IDEwMDsKICAgICAgICB9KTsKICAgICAgfQogICAgICB0aGlzLmNhbGN1bGF0ZVRhc2tMaXN0Q29sdW1uc0RpbWVuc2lvbnMoKTsKICAgICAgdGhpcy4kZW1pdCgnY2FsZW5kYXItcmVjYWxjdWxhdGUnKTsKICAgICAgdGhpcy5zeW5jU2Nyb2xsVG9wKCk7CiAgICB9CiAgfSwKCiAgY29tcHV0ZWQ6IHsKICAgIC8qKgogICAgICogR2V0IHZpc2libGUgdGFza3MKICAgICAqIFZlcnkgaW1wb3J0YW50IG1ldGhvZCB3aGljaCB3aWxsIGJyaW5nIHVzIG9ubHkgdGhvc2UgdGFza3MgdGhhdCBhcmUgdmlzaWJsZSBpbnNpZGUgZ2FudHQgY2hhcnQKICAgICAqIEZvciBleGFtcGxlIHdoZW4gdGFzayBpcyBjb2xsYXBzZWQgLSBjaGlsZHJlbiBvZiB0aGlzIHRhc2sgYXJlIG5vdCB2aXNpYmxlIC0gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlbQogICAgICovCiAgICB2aXNpYmxlVGFza3MoKSB7CiAgICAgIGNvbnN0IHZpc2libGVUYXNrcyA9IHRoaXMuc3RhdGUudGFza3MuZmlsdGVyKHRhc2sgPT4gdGhpcy5pc1Rhc2tWaXNpYmxlKHRhc2spKTsKICAgICAgY29uc3QgbWF4Um93cyA9IHZpc2libGVUYXNrcy5zbGljZSgwLCB0aGlzLnN0YXRlLm9wdGlvbnMubWF4Um93cyk7CiAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5yb3dzSGVpZ2h0ID0gdGhpcy5nZXRUYXNrc0hlaWdodChtYXhSb3dzKTsKICAgICAgbGV0IGhlaWdodENvbXBlbnNhdGlvbiA9IDA7CiAgICAgIGlmICh0aGlzLnN0YXRlLm9wdGlvbnMubWF4SGVpZ2h0ICYmIHRoaXMuc3RhdGUub3B0aW9ucy5yb3dzSGVpZ2h0ID4gdGhpcy5zdGF0ZS5vcHRpb25zLm1heEhlaWdodCkgewogICAgICAgIGhlaWdodENvbXBlbnNhdGlvbiA9IHRoaXMuc3RhdGUub3B0aW9ucy5yb3dzSGVpZ2h0IC0gdGhpcy5zdGF0ZS5vcHRpb25zLm1heEhlaWdodDsKICAgICAgICB0aGlzLnN0YXRlLm9wdGlvbnMucm93c0hlaWdodCA9IHRoaXMuc3RhdGUub3B0aW9ucy5tYXhIZWlnaHQ7CiAgICAgIH0KICAgICAgdGhpcy5zdGF0ZS5vcHRpb25zLmhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KG1heFJvd3MpIC0gaGVpZ2h0Q29tcGVuc2F0aW9uOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMuYWxsVmlzaWJsZVRhc2tzSGVpZ2h0ID0gdGhpcy5nZXRUYXNrc0hlaWdodCh2aXNpYmxlVGFza3MpOwogICAgICB0aGlzLnN0YXRlLm9wdGlvbnMub3V0ZXJIZWlnaHQgPSB0aGlzLmdldEhlaWdodChtYXhSb3dzLCB0cnVlKSAtIGhlaWdodENvbXBlbnNhdGlvbjsKICAgICAgbGV0IGxlbiA9IHZpc2libGVUYXNrcy5sZW5ndGg7CiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHsKICAgICAgICBsZXQgdGFzayA9IHZpc2libGVUYXNrc1tpbmRleF07CiAgICAgICAgdGFzay53aWR0aCA9CiAgICAgICAgICB0YXNrLmR1cmF0aW9uIC8gdGhpcy5zdGF0ZS5vcHRpb25zLnRpbWVzLnRpbWVQZXJQaXhlbCAtIHRoaXMuc3R5bGVbJ2dyaWQtbGluZS12ZXJ0aWNhbCddWydzdHJva2Utd2lkdGgnXTsKICAgICAgICBpZiAodGFzay53aWR0aCA8IDApIHsKICAgICAgICAgIHRhc2sud2lkdGggPSAwOwogICAgICAgIH0KICAgICAgICB0YXNrLmhlaWdodCA9IHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0OwogICAgICAgIHRhc2sueCA9IHRoaXMudGltZVRvUGl4ZWxPZmZzZXRYKHRhc2suc3RhcnRUaW1lKTsKICAgICAgICB0YXNrLnkgPQogICAgICAgICAgKHRoaXMuc3RhdGUub3B0aW9ucy5yb3cuaGVpZ2h0ICsgdGhpcy5zdGF0ZS5vcHRpb25zLmNoYXJ0LmdyaWQuaG9yaXpvbnRhbC5nYXAgKiAyKSAqIGluZGV4ICsKICAgICAgICAgIHRoaXMuc3RhdGUub3B0aW9ucy5jaGFydC5ncmlkLmhvcml6b250YWwuZ2FwOwogICAgICB9CiAgICAgIHJldHVybiB2aXNpYmxlVGFza3M7CiAgICB9LAoKICAgIC8qKgogICAgICogU3R5bGUgc2hvcnRjdXQKICAgICAqLwogICAgc3R5bGUoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmR5bmFtaWNTdHlsZTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZXQgY29sdW1ucyBhbmQgY29tcHV0ZSBkaW1lbnNpb25zIG9uIHRoZSBmbHkKICAgICAqLwogICAgZ2V0VGFza0xpc3RDb2x1bW5zKCkgewogICAgICB0aGlzLmNhbGN1bGF0ZVRhc2tMaXN0Q29sdW1uc0RpbWVuc2lvbnMoKTsKICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub3B0aW9ucy50YXNrTGlzdC5jb2x1bW5zOwogICAgfSwKCiAgICAvKioKICAgICAqIFRhc2tzIHVzZWQgZm9yIGNvbW11bmljYXRlIHdpdGggcGFyZW50IGNvbXBvbmVudAogICAgICovCiAgICBvdXRwdXRUYXNrcygpIHsKICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudGFza3M7CiAgICB9LAoKICAgIC8qKgogICAgICogT3B0aW9ucyB1c2VkIHRvIGNvbW11bmljYXRlIHdpdGggcGFyZW50IGNvbXBvbmVudAogICAgICovCiAgICBvdXRwdXRPcHRpb25zKCkgewogICAgICByZXR1cm4gdGhpcy5zdGF0ZS5vcHRpb25zOwogICAgfQogIH0sCgogIC8qKgogICAqIFdhdGNoIHRhc2tzIGFmdGVyIGdhbnR0IGluc3RhbmNlIGlzIGNyZWF0ZWQgYW5kIHJlYWN0IHdoZW4gd2UgaGF2ZSBuZXcga2lkcyBvbiB0aGUgYmxvY2sKICAgKi8KICBjcmVhdGVkKCkgewogICAgdGhpcy5pbml0aWFsaXplRXZlbnRzKCk7CiAgICB0aGlzLnNldHVwKCk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hUYXNrcyA9IHRoaXMuJHdhdGNoKAogICAgICAndGFza3MnLAogICAgICB0YXNrcyA9PiB7CiAgICAgICAgY29uc3Qgbm90RXF1YWwgPSBub3RFcXVhbERlZXAodGFza3MsIHRoaXMub3V0cHV0VGFza3MpOwogICAgICAgIGlmIChub3RFcXVhbCkgewogICAgICAgICAgdGhpcy5zZXR1cCgndGFza3MnKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIHsgZGVlcDogdHJ1ZSB9CiAgICApOwogICAgdGhpcy5zdGF0ZS51bndhdGNoT3B0aW9ucyA9IHRoaXMuJHdhdGNoKAogICAgICAnb3B0aW9ucycsCiAgICAgIG9wdHMgPT4gewogICAgICAgIGNvbnN0IG5vdEVxdWFsID0gbm90RXF1YWxEZWVwKG9wdHMsIHRoaXMub3V0cHV0T3B0aW9ucyk7CiAgICAgICAgaWYgKG5vdEVxdWFsKSB7CiAgICAgICAgICB0aGlzLnNldHVwKCdvcHRpb25zJyk7CiAgICAgICAgfQogICAgICB9LAogICAgICB7IGRlZXA6IHRydWUgfQogICAgKTsKICAgIHRoaXMuc3RhdGUudW53YXRjaFN0eWxlID0gdGhpcy4kd2F0Y2goCiAgICAgICdkeW5hbWljU3R5bGUnLAogICAgICBzdHlsZSA9PiB7CiAgICAgICAgY29uc3Qgbm90RXF1YWwgPSBub3RFcXVhbERlZXAoc3R5bGUsIHRoaXMuZHluYW1pY1N0eWxlKTsKICAgICAgICBpZiAobm90RXF1YWwpIHsKICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVN0eWxlKCk7CiAgICAgICAgfQogICAgICB9LAogICAgICB7IGRlZXA6IHRydWUsIGltbWVkaWF0ZTogdHJ1ZSB9CiAgICApOwoKICAgIHRoaXMuc3RhdGUudW53YXRjaE91dHB1dFRhc2tzID0gdGhpcy4kd2F0Y2goCiAgICAgICdvdXRwdXRUYXNrcycsCiAgICAgIHRhc2tzID0+IHsKICAgICAgICB0aGlzLiRlbWl0KCd0YXNrcy1jaGFuZ2VkJywgdGFza3MubWFwKHRhc2sgPT4gdGFzaykpOwogICAgICB9LAogICAgICB7IGRlZXA6IHRydWUgfQogICAgKTsKICAgIHRoaXMuc3RhdGUudW53YXRjaE91dHB1dE9wdGlvbnMgPSB0aGlzLiR3YXRjaCgKICAgICAgJ291dHB1dE9wdGlvbnMnLAogICAgICBvcHRpb25zID0+IHsKICAgICAgICB0aGlzLiRlbWl0KCdvcHRpb25zLWNoYW5nZWQnLCBtZXJnZURlZXAoe30sIG9wdGlvbnMpKTsKICAgICAgfSwKICAgICAgeyBkZWVwOiB0cnVlIH0KICAgICk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hPdXRwdXRTdHlsZSA9IHRoaXMuJHdhdGNoKAogICAgICAnc3R5bGUnLAogICAgICBzdHlsZSA9PiB7CiAgICAgICAgdGhpcy4kZW1pdCgnZHluYW1pYy1zdHlsZS1jaGFuZ2VkJywgbWVyZ2VEZWVwKHt9LCBzdHlsZSkpOwogICAgICB9LAogICAgICB7IGRlZXA6IHRydWUgfQogICAgKTsKCiAgICB0aGlzLiRyb290LiRlbWl0KCdnYW50dC1lbGFzdGljLWNyZWF0ZWQnLCB0aGlzKTsKICAgIHRoaXMuJGVtaXQoJ2NyZWF0ZWQnLCB0aGlzKTsKICB9LAoKICAvKioKICAgKiBFbWl0IGJlZm9yZS1tb3VudCBldmVudAogICAqLwogIGJlZm9yZU1vdW50KCkgewogICAgdGhpcy4kZW1pdCgnYmVmb3JlLW1vdW50JywgdGhpcyk7CiAgfSwKCiAgLyoqCiAgICogRW1pdCByZWFkeS9tb3VudGVkIGV2ZW50cyBhbmQgZGVsaXZlciB0aGlzIGdhbnR0IGluc3RhbmNlIHRvIG91dHNpZGUgd29ybGQgd2hlbiBuZWVkZWQKICAgKi8KICBtb3VudGVkKCkgewogICAgdGhpcy5zdGF0ZS5vcHRpb25zLmNsaWVudFdpZHRoID0gdGhpcy4kZWwuY2xpZW50V2lkdGg7CiAgICB0aGlzLnN0YXRlLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4gewogICAgICB0aGlzLmdsb2JhbE9uUmVzaXplKCk7CiAgICB9KTsKICAgIHRoaXMuc3RhdGUucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbC5wYXJlbnROb2RlKTsKICAgIHRoaXMuZ2xvYmFsT25SZXNpemUoKTsKICAgIHRoaXMuJGVtaXQoJ3JlYWR5JywgdGhpcyk7CiAgICB0aGlzLiRyb290LiRlbWl0KCdnYW50dC1lbGFzdGljLW1vdW50ZWQnLCB0aGlzKTsKICAgIHRoaXMuJGVtaXQoJ21vdW50ZWQnLCB0aGlzKTsKICAgIHRoaXMuJHJvb3QuJGVtaXQoJ2dhbnR0LWVsYXN0aWMtcmVhZHknLCB0aGlzKTsKICB9LAoKICAvKioKICAgKiBFbWl0IGV2ZW50IHdoZW4gZGF0YSB3YXMgY2hhbmdlZCBhbmQgYmVmb3JlIHVwZGF0ZSAoeW91IGNhbiBjbGVhbnVwIGRvbSBldmVudHMgaGVyZSBmb3IgZXhhbXBsZSkKICAgKi8KICBiZWZvcmVVcGRhdGUoKSB7CiAgICB0aGlzLiRlbWl0KCdiZWZvcmUtdXBkYXRlJyk7CiAgfSwKCiAgLyoqCiAgICogRW1pdCBldmVudCB3aGVuIGdhbnR0LWVsYXN0aWMgdmlldyB3YXMgdXBkYXRlZAogICAqLwogIHVwZGF0ZWQoKSB7CiAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7CiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZWQnKTsKICAgIH0pOwogIH0sCgogIC8qKgogICAqIEJlZm9yZSBkZXN0cm95IGV2ZW50IC0gY2xlYW4gdXAKICAgKi8KICBiZWZvcmVEZXN0cm95KCkgewogICAgdGhpcy5zdGF0ZS5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy4kZWwucGFyZW50Tm9kZSk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hUYXNrcygpOwogICAgdGhpcy5zdGF0ZS51bndhdGNoT3B0aW9ucygpOwogICAgdGhpcy5zdGF0ZS51bndhdGNoU3R5bGUoKTsKICAgIHRoaXMuc3RhdGUudW53YXRjaE91dHB1dFRhc2tzKCk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hPdXRwdXRPcHRpb25zKCk7CiAgICB0aGlzLnN0YXRlLnVud2F0Y2hPdXRwdXRTdHlsZSgpOwogICAgdGhpcy4kZW1pdCgnYmVmb3JlLWRlc3Ryb3knKTsKICB9LAoKICAvKioKICAgKiBFbWl0IGV2ZW50IGFmdGVyIGdhbnR0LWVsYXN0aWMgd2FzIGRlc3Ryb3llZAogICAqLwogIGRlc3Ryb3llZCgpIHsKICAgIHRoaXMuJGVtaXQoJ2Rlc3Ryb3llZCcpOwogIH0KfTsKZXhwb3J0IGRlZmF1bHQgR2FudHRFbGFzdGljOwo="},{"version":3,"sources":["GanttElastic.vue"],"names":[],"mappings":";AAiBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"GanttElastic.vue","sourceRoot":"node_modules/_gantt-elastic@1.0.12@gantt-elastic/src","sourcesContent":["<!--\n/**\n * @fileoverview GanttElastic component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <div class=\"gantt-elastic\" style=\"width:100%\">\n    <slot name=\"header\"></slot>\n    <main-view ref=\"mainView\"></main-view>\n    <slot name=\"footer\"></slot>\n  </div>\n</template>\n\n<script>\nimport VueInstance from 'vue';\nimport dayjs from 'dayjs';\nimport MainView from './components/MainView.vue';\nimport getStyle from './style.js';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nconst ctx = document.createElement('canvas').getContext('2d');\nlet VueInst = VueInstance;\nfunction initVue() {\n  if (typeof Vue !== 'undefined' && typeof VueInst === 'undefined') {\n    VueInst = Vue;\n  }\n}\ninitVue();\n\nlet hourWidthCache = null;\n\n/**\n * Helper function to fill out empty options in user settings\n *\n * @param {object} userOptions - initial user options that will merge with those below\n * @returns {object} merged options\n */\nfunction getOptions(userOptions) {\n  let localeName = 'en';\n  if (typeof userOptions.locale !== 'undefined' && typeof userOptions.locale.name !== 'undefined') {\n    localeName = userOptions.locale.name;\n  }\n  return {\n    slots: {\n      header: {}\n    },\n    taskMapping: {\n      //*\n      id: 'id',\n      start: 'start',\n      label: 'label',\n      duration: 'duration',\n      progress: 'progress',\n      type: 'type',\n      style: 'style',\n      collapsed: 'collapsed'\n    },\n    width: 0,\n    height: 0,\n    clientWidth: 0,\n    outerHeight: 0,\n    rowsHeight: 0,\n    allVisibleTasksHeight: 0,\n    scroll: {\n      scrolling: false,\n      dragXMoveMultiplier: 3, //*\n      dragYMoveMultiplier: 2, //*\n      top: 0,\n      taskList: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      chart: {\n        left: 0,\n        right: 0,\n        percent: 0,\n        timePercent: 0,\n        top: 0,\n        bottom: 0,\n        time: 0,\n        timeCenter: 0,\n        dateTime: {\n          left: '',\n          right: ''\n        }\n      }\n    },\n    scope: {\n      //*\n      before: 1,\n      after: 1\n    },\n    times: {\n      timeScale: 60 * 1000,\n      timeZoom: 17, //*\n      timePerPixel: 0,\n      firstTime: null,\n      lastTime: null,\n      firstTaskTime: 0,\n      lastTaskTime: 0,\n      totalViewDurationMs: 0,\n      totalViewDurationPx: 0,\n      stepDuration: 'day',\n      steps: []\n    },\n    row: {\n      height: 24 //*\n    },\n    maxRows: 20, //*\n    maxHeight: 0, //*\n    chart: {\n      grid: {\n        horizontal: {\n          gap: 6 //*\n        }\n      },\n      progress: {\n        width: 20, //*\n        height: 6, //*\n        pattern: true,\n        bar: false\n      },\n      text: {\n        offset: 4, //*\n        xPadding: 10, //*\n        display: true //*\n      },\n      expander: {\n        type: 'chart',\n        display: false, //*\n        displayIfTaskListHidden: true, //*\n        offset: 4, //*\n        size: 18\n      }\n    },\n    taskList: {\n      display: true, //*\n      resizeAfterThreshold: true, //*\n      widthThreshold: 75, //*\n      columns: [\n        //*\n        {\n          id: 0,\n          label: 'ID',\n          value: 'id',\n          width: 40\n        }\n      ],\n      percent: 100, //*\n      width: 0,\n      finalWidth: 0,\n      widthFromPercentage: 0,\n      minWidth: 18,\n      expander: {\n        type: 'task-list',\n        size: 16,\n        columnWidth: 24,\n        padding: 16,\n        margin: 10,\n        straight: false\n      }\n    },\n    calendar: {\n      workingDays: [1, 2, 3, 4, 5], //*\n      gap: 6, //*\n      height: 0,\n      strokeWidth: 1,\n      hour: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        formatted: {\n          long: [],\n          medium: [],\n          short: []\n        },\n        format: {\n          //*\n          long(date) {\n            return date.format('HH:mm');\n          },\n          medium(date) {\n            return date.format('HH:mm');\n          },\n          short(date) {\n            return date.format('HH');\n          }\n        }\n      },\n      day: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        format: {\n          long(date) {\n            return date.format('DD dddd');\n          },\n          medium(date) {\n            return date.format('DD ddd');\n          },\n          short(date) {\n            return date.format('DD');\n          }\n        }\n      },\n      month: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        format: {\n          //*\n          short(date) {\n            return date.format('MM');\n          },\n          medium(date) {\n            return date.format(\"MMM 'YY\");\n          },\n          long(date) {\n            return date.format('MMMM YYYY');\n          }\n        }\n      }\n    },\n    locale: {\n      //*\n      name: 'en',\n      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n      weekStart: 1,\n      relativeTime: {\n        future: 'in %s',\n        past: '%s ago',\n        s: 'a few seconds',\n        m: 'a minute',\n        mm: '%d minutes',\n        h: 'an hour',\n        hh: '%d hours',\n        d: 'a day',\n        dd: '%d days',\n        M: 'a month',\n        MM: '%d months',\n        y: 'a year',\n        yy: '%d years'\n      },\n      formats: {\n        LT: 'HH:mm',\n        LTS: 'HH:mm:ss',\n        L: 'DD/MM/YYYY',\n        LL: 'D MMMM YYYY',\n        LLL: 'D MMMM YYYY HH:mm',\n        LLLL: 'dddd, D MMMM YYYY HH:mm'\n      },\n      ordinal: n => {\n        const s = ['th', 'st', 'nd', 'rd'];\n        const v = n % 100;\n        return `[${n}${s[(v - 20) % 10] || s[v] || s[0]}]`;\n      }\n    }\n  };\n}\n\n/**\n * Prepare style\n *\n * @returns {object}\n */\nfunction prepareStyle(userStyle) {\n  let fontSize = '12px';\n  let fontFamily = window\n    .getComputedStyle(document.body)\n    .getPropertyValue('font-family')\n    .toString();\n  if (typeof userStyle !== 'undefined') {\n    if (typeof userStyle.fontSize !== 'undefined') {\n      fontSize = userStyle.fontSize;\n    }\n    if (typeof userStyle.fontFamily !== 'undefined') {\n      fontFamily = userStyle.fontFamily;\n    }\n  }\n  return getStyle(fontSize, fontFamily);\n}\n\n/**\n * Helper function to determine if specified variable is an object\n *\n * @param {any} item\n *\n * @returns {boolean}\n */\nfunction isObject(item) {\n  return (\n    item &&\n    typeof item === 'object' &&\n    !Array.isArray(item) &&\n    !(item instanceof HTMLElement) &&\n    !(item instanceof CanvasRenderingContext2D) &&\n    typeof item !== 'function'\n  );\n}\n\n/**\n * Helper function which will merge objects recursively - creating brand new one - like clone\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\nexport function mergeDeep(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          target[key] = {};\n        }\n        target[key] = mergeDeep(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = [];\n        for (let item of source[key]) {\n          if (isObject(item)) {\n            target[key].push(mergeDeep({}, item));\n            continue;\n          }\n          target[key].push(item);\n        }\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n}\n\n/**\n * Detect if object or array is observable\n *\n * @param {object|array} obj\n *\n * @returns {boolean}\n */\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj.hasOwnProperty('__ob__');\n}\n\n/**\n * Same as above but with reactivity in mind\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\nexport function mergeDeepReactive(component, target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          component.$set(target, key, {});\n        }\n        mergeDeepReactive(component, target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        component.$set(target, key, source[key]);\n      } else if (typeof source[key] === 'function') {\n        if (source[key].toString().indexOf('[native code]') === -1) {\n          target[key] = source[key];\n        }\n      } else {\n        component.$set(target, key, source[key]);\n      }\n    }\n  }\n  return mergeDeepReactive(component, target, ...sources);\n}\n/**\n * Check if objects or arrays are equal by comparing nested values\n *\n * @param {object|array} left\n * @param {object|array} right\n *\n * @returns {boolean}\n */\nexport function notEqualDeep(left, right, cache = [], path = '') {\n  if (typeof right !== typeof left) {\n    return { left, right, what: path + '.typeof' };\n  } else if (Array.isArray(left) && !Array.isArray(right)) {\n    return { left, right, what: path + '.isArray' };\n  } else if (Array.isArray(right) && !Array.isArray(left)) {\n    return { left, right, what: path + '.isArray' };\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    if (left.length !== right.length) {\n      return { left, right, what: path + '.length' };\n    }\n    let what;\n    for (let index = 0, len = left.length; index < len; index++) {\n      if ((what = notEqualDeep(left[index], right[index], cache, path + '.' + index))) {\n        return what;\n      }\n    }\n  } else if (isObject(left) && !isObject(right)) {\n    return { left, right, what: path + '.isObject' };\n  } else if (isObject(right) && !isObject(left)) {\n    return { left, right, what: path + '.isObject' };\n  } else if (isObject(left) && isObject(right)) {\n    for (let key in left) {\n      if (!left.hasOwnProperty(key) || !left.propertyIsEnumerable(key)) {\n        continue;\n      }\n      if (!right.hasOwnProperty(key)) {\n        return { left, right, what: path + '.' + key };\n      }\n      let what;\n      if ((what = notEqualDeep(left[key], right[key], cache, path + '.' + key))) {\n        return what;\n      }\n    }\n  } else if (left !== right) {\n    return { left, right, what: path + '. !==' };\n  }\n  return false;\n}\n\n/**\n * GanttElastic\n * Main vue component\n */\nconst GanttElastic = {\n  name: 'GanttElastic',\n  components: {\n    MainView\n  },\n  props: ['tasks', 'options', 'dynamicStyle'],\n  provide() {\n    const provider = {};\n    const self = this;\n    Object.defineProperty(provider, 'root', {\n      enumerable: true,\n      get: () => self\n    });\n    return provider;\n  },\n  data() {\n    return {\n      state: {\n        tasks: [],\n        options: {\n          scrollBarHeight: 0,\n          allVisibleTasksHeight: 0,\n          outerHeight: 0,\n          scroll: {\n            left: 0,\n            top: 0\n          }\n        },\n        dynamicStyle: {},\n        refs: {},\n        tasksById: {},\n        taskTree: {},\n        ctx,\n        emitTasksChanges: true, // some operations may pause emitting changes to parent component\n        emitOptionsChanges: true, // some operations may pause emitting changes to parent component\n        resizeObserver: null,\n        unwatchTasks: null,\n        unwatchOptions: null,\n        unwatchStyle: null,\n        unwatchOutputTasks: null,\n        unwatchOutputOptions: null,\n        unwatchOutputStyle: null\n      }\n    };\n  },\n  methods: {\n    mergeDeep,\n    mergeDeepReactive,\n\n    /**\n     * Calculate height of scrollbar in current browser\n     *\n     * @returns {number}\n     */\n    getScrollBarHeight() {\n      const outer = document.createElement('div');\n      outer.style.visibility = 'hidden';\n      outer.style.height = '100px';\n      outer.style.msOverflowStyle = 'scrollbar';\n      document.body.appendChild(outer);\n      var noScroll = outer.offsetHeight;\n      outer.style.overflow = 'scroll';\n      var inner = document.createElement('div');\n      inner.style.height = '100%';\n      outer.appendChild(inner);\n      var withScroll = inner.offsetHeight;\n      outer.parentNode.removeChild(outer);\n      const height = noScroll - withScroll;\n      this.style['chart-scroll-container--vertical']['margin-left'] = `-${height}px`;\n      return (this.state.options.scrollBarHeight = height);\n    },\n\n    /**\n     * Fill out empty task properties and make it reactive\n     *\n     * @param {array} tasks\n     */\n    fillTasks(tasks) {\n      for (let task of tasks) {\n        if (typeof task.x === 'undefined') {\n          task.x = 0;\n        }\n        if (typeof task.y === 'undefined') {\n          task.y = 0;\n        }\n        if (typeof task.width === 'undefined') {\n          task.width = 0;\n        }\n        if (typeof task.height === 'undefined') {\n          task.height = 0;\n        }\n        if (typeof task.mouseOver === 'undefined') {\n          task.mouseOver = false;\n        }\n        if (typeof task.collapsed === 'undefined') {\n          task.collapsed = false;\n        }\n        if (typeof task.dependentOn === 'undefined') {\n          task.dependentOn = [];\n        }\n        if (typeof task.parentId === 'undefined') {\n          task.parentId = null;\n        }\n        if (typeof task.style === 'undefined') {\n          task.style = {};\n        }\n        if (typeof task.children === 'undefined') {\n          task.children = [];\n        }\n        if (typeof task.allChildren === 'undefined') {\n          task.allChildren = [];\n        }\n        if (typeof task.parents === 'undefined') {\n          task.parents = [];\n        }\n        if (typeof task.parent === 'undefined') {\n          task.parent = null;\n        }\n        if (typeof task.startTime === 'undefined') {\n          task.startTime = dayjs(task.start).valueOf();\n        }\n        if (typeof task.endTime === 'undefined' && task.hasOwnProperty('end')) {\n          task.endTime = dayjs(task.end).valueOf();\n        } else if (typeof task.endTime === 'undefined' && task.hasOwnProperty('duration')) {\n          task.endTime = task.startTime + task.duration;\n        }\n        if (typeof task.duration === 'undefined' && task.hasOwnProperty('endTime')) {\n          task.duration = task.endTime - task.startTime;\n        }\n      }\n      return tasks;\n    },\n\n    /**\n     * Map tasks\n     *\n     * @param {Array} tasks\n     * @param {Object} options\n     */\n    mapTasks(tasks, options) {\n      for (let [index, task] of tasks.entries()) {\n        tasks[index] = {\n          ...task,\n          id: task[options.taskMapping.id],\n          start: task[options.taskMapping.start],\n          label: task[options.taskMapping.label],\n          duration: task[options.taskMapping.duration],\n          progress: task[options.taskMapping.progress],\n          type: task[options.taskMapping.type],\n          style: task[options.taskMapping.style],\n          collapsed: task[options.taskMapping.collapsed]\n        };\n      }\n      return tasks;\n    },\n\n    /**\n     * Initialize component\n     */\n    initialize(itsUpdate = '') {\n      let options = mergeDeep({}, this.state.options, getOptions(this.options), this.options);\n      let tasks = this.mapTasks(this.tasks, options);\n      if (Object.keys(this.state.dynamicStyle).length === 0) {\n        this.initializeStyle();\n      }\n      dayjs.locale(options.locale, null, true);\n      dayjs.locale(options.locale.name);\n      if (typeof options.taskList === 'undefined') {\n        options.taskList = {};\n      }\n      options.taskList.columns = options.taskList.columns.map((column, index) => {\n        column.thresholdPercent = 100;\n        column.widthFromPercentage = 0;\n        column.finalWidth = 0;\n        if (typeof column.height === 'undefined') {\n          column.height = 0;\n        }\n        if (typeof column.style === 'undefined') {\n          column.style = {};\n        }\n        column._id = `${index}-${column.label}`;\n        return column;\n      });\n      this.state.options = options;\n      tasks = this.fillTasks(tasks);\n      this.state.tasksById = this.resetTaskTree(tasks);\n      this.state.taskTree = this.makeTaskTree(this.state.rootTask, tasks);\n      this.state.tasks = this.state.taskTree.allChildren.map(childId => this.getTask(childId));\n      this.calculateTaskListColumnsDimensions();\n      this.state.options.scrollBarHeight = this.getScrollBarHeight();\n      this.state.options.outerHeight = this.state.options.height + this.state.options.scrollBarHeight;\n      this.globalOnResize();\n    },\n\n    /**\n     * Initialize style\n     */\n    initializeStyle() {\n      this.state.dynamicStyle = mergeDeep({}, prepareStyle(this.dynamicStyle), this.dynamicStyle);\n    },\n\n    /**\n     * Get calendar rows outer height\n     *\n     * @returns {int}\n     */\n    getCalendarHeight() {\n      return this.state.options.calendar.height + this.state.options.calendar.strokeWidth;\n    },\n\n    /**\n     * Get maximal level of nested task children\n     *\n     * @returns {int}\n     */\n    getMaximalLevel() {\n      let maximalLevel = 0;\n      this.state.tasks.forEach(task => {\n        if (task.parents.length > maximalLevel) {\n          maximalLevel = task.parents.length;\n        }\n      });\n      return maximalLevel - 1;\n    },\n\n    /**\n     * Get maximal expander width - to calculate straight task list text\n     *\n     * @returns {int}\n     */\n    getMaximalExpanderWidth() {\n      return (\n        this.getMaximalLevel() * this.state.options.taskList.expander.padding +\n        this.state.options.taskList.expander.margin\n      );\n    },\n\n    /**\n     * Synchronize scrollTop property when row height is changed\n     */\n    syncScrollTop() {\n      if (\n        this.state.refs.taskListItems &&\n        this.state.refs.chartGraph.scrollTop !== this.state.refs.taskListItems.scrollTop\n      ) {\n        this.state.options.scroll.top = this.state.refs.taskListItems.scrollTop = this.state.refs.chartScrollContainerVertical.scrollTop = this.state.refs.chartGraph.scrollTop;\n      }\n    },\n\n    /**\n     * Calculate task list columns dimensions\n     */\n    calculateTaskListColumnsDimensions() {\n      let final = 0;\n      let percentage = 0;\n      for (let column of this.state.options.taskList.columns) {\n        if (column.expander) {\n          column.widthFromPercentage =\n            ((this.getMaximalExpanderWidth() + column.width) / 100) * this.state.options.taskList.percent;\n        } else {\n          column.widthFromPercentage = (column.width / 100) * this.state.options.taskList.percent;\n        }\n        percentage += column.widthFromPercentage;\n        column.finalWidth = (column.thresholdPercent * column.widthFromPercentage) / 100;\n        final += column.finalWidth;\n        column.height = this.getTaskHeight() - this.style['grid-line-horizontal']['stroke-width'];\n      }\n      this.state.options.taskList.widthFromPercentage = percentage;\n      this.state.options.taskList.finalWidth = final;\n    },\n\n    /**\n     * Reset task tree - which is used to create tree like structure inside task list\n     */\n    resetTaskTree(tasks) {\n      this.$set(this.state, 'rootTask', {\n        id: null,\n        label: 'root',\n        children: [],\n        allChildren: [],\n        parents: [],\n        parent: null,\n        __root: true\n      });\n      const tasksById = {};\n      for (let i = 0, len = tasks.length; i < len; i++) {\n        let current = tasks[i];\n        current.children = [];\n        current.allChildren = [];\n        current.parent = null;\n        current.parents = [];\n        tasksById[current.id] = current;\n      }\n      return tasksById;\n    },\n\n    /**\n     * Make task tree, after reset - look above\n     *\n     * @param {object} task\n     * @returns {object} tasks with children and parents\n     */\n    makeTaskTree(task, tasks) {\n      for (let i = 0, len = tasks.length; i < len; i++) {\n        let current = tasks[i];\n        if (current.parentId === task.id) {\n          if (task.parents.length) {\n            task.parents.forEach(parent => current.parents.push(parent));\n          }\n          if (!task.propertyIsEnumerable('__root')) {\n            current.parents.push(task.id);\n            current.parent = task.id;\n          } else {\n            current.parents = [];\n            current.parent = null;\n          }\n          current = this.makeTaskTree(current, tasks);\n          task.allChildren.push(current.id);\n          task.children.push(current.id);\n          current.allChildren.forEach(childId => task.allChildren.push(childId));\n        }\n      }\n      return task;\n    },\n\n    /**\n     * Get task by id\n     *\n     * @param {any} taskId\n     * @returns {object|null} task\n     */\n    getTask(taskId) {\n      if (typeof this.state.tasksById[taskId] !== 'undefined') {\n        return this.state.tasksById[taskId];\n      }\n      return null;\n    },\n\n    /**\n     * Get children tasks for specified taskId\n     *\n     * @param {any} taskId\n     * @returns {array} children\n     */\n    getChildren(taskId) {\n      return this.state.tasks.filter(task => task.parent === taskId);\n    },\n\n    /**\n     * Is task visible\n     *\n     * @param {Number|String|Task} task\n     */\n    isTaskVisible(task) {\n      if (typeof task === 'number' || typeof task === 'string') {\n        task = this.getTask(task);\n      }\n      for (let i = 0, len = task.parents.length; i < len; i++) {\n        if (this.getTask(task.parents[i]).collapsed) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Get svg\n     *\n     * @returns {string} html svg image of gantt\n     */\n    getSVG() {\n      return this.state.options.mainView.outerHTML;\n    },\n\n    /**\n     * Get image\n     *\n     * @param {string} type image format\n     * @returns {Promise} when resolved returns base64 image string of gantt\n     */\n    getImage(type = 'image/png') {\n      return new Promise(resolve => {\n        const img = new Image();\n        img.onload = () => {\n          const canvas = document.createElement('canvas');\n          canvas.width = this.state.options.mainView.clientWidth;\n          canvas.height = this.state.options.rowsHeight;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          resolve(canvas.toDataURL(type));\n        };\n        img.src = 'data:image/svg+xml,' + encodeURIComponent(this.getSVG());\n      });\n    },\n\n    /**\n     * Get gantt total height\n     *\n     * @returns {number}\n     */\n    getHeight(visibleTasks, outer = false) {\n      let height =\n        visibleTasks.length * (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) +\n        this.state.options.calendar.height +\n        this.state.options.calendar.strokeWidth +\n        this.state.options.calendar.gap;\n      if (outer) {\n        height += this.state.options.scrollBarHeight;\n      }\n      return height;\n    },\n\n    /**\n     * Get one task height\n     *\n     * @returns {number}\n     */\n    getTaskHeight(withStroke = false) {\n      if (withStroke) {\n        return (\n          this.state.options.row.height +\n          this.state.options.chart.grid.horizontal.gap * 2 +\n          this.style['grid-line-horizontal']['stroke-width']\n        );\n      }\n      return this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2;\n    },\n\n    /**\n     * Get specified tasks height\n     *\n     * @returns {number}\n     */\n    getTasksHeight(visibleTasks) {\n      return visibleTasks.length * this.getTaskHeight();\n    },\n\n    /**\n     * Convert time (in milliseconds) to pixel offset inside chart\n     *\n     * @param {int} ms\n     * @returns {number}\n     */\n    timeToPixelOffsetX(ms) {\n      let x = ms - this.state.options.times.firstTime;\n      if (x) {\n        x = x / this.state.options.times.timePerPixel;\n      }\n      return x;\n    },\n\n    /**\n     * Convert pixel offset inside chart to corresponding time offset in milliseconds\n     *\n     * @param {number} pixelOffsetX\n     * @returns {int} milliseconds\n     */\n    pixelOffsetXToTime(pixelOffsetX) {\n      let offset = pixelOffsetX + this.style['grid-line-vertical']['stroke-width'] / 2;\n      return offset * this.state.options.times.timePerPixel + this.state.options.times.firstTime;\n    },\n\n    /**\n     * Determine if element is inside current view port\n     *\n     * @param {number} x - element placement\n     * @param {number} width - element width\n     * @param {int} buffer - or threshold, if element is outside viewport but offset from view port is below this value return true\n     * @returns {boolean}\n     */\n    isInsideViewPort(x, width, buffer = 5000) {\n      return (\n        (x + width + buffer >= this.state.options.scroll.chart.left &&\n          x - buffer <= this.state.options.scroll.chart.right) ||\n        (x - buffer <= this.state.options.scroll.chart.left &&\n          x + width + buffer >= this.state.options.scroll.chart.right)\n      );\n    },\n\n    /**\n     * Chart scroll event handler\n     *\n     * @param {event} ev\n     */\n    onScrollChart(ev) {\n      this._onScrollChart(\n        this.state.refs.chartScrollContainerHorizontal.scrollLeft,\n        this.state.refs.chartScrollContainerVertical.scrollTop\n      );\n    },\n\n    /**\n     * After same as above but with different arguments - normalized\n     *\n     * @param {number} left\n     * @param {number} top\n     */\n    _onScrollChart(left, top) {\n      if (this.state.options.scroll.chart.left === left && this.state.options.scroll.chart.top === top) {\n        return;\n      }\n      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      this.state.options.scroll.chart.left = left;\n      this.state.options.scroll.chart.right = left + chartContainerWidth;\n      this.state.options.scroll.chart.percent = (left / this.state.options.times.totalViewDurationPx) * 100;\n      this.state.options.scroll.chart.top = top;\n      this.state.options.scroll.chart.time = this.pixelOffsetXToTime(left);\n      this.state.options.scroll.chart.timeCenter = this.pixelOffsetXToTime(left + chartContainerWidth / 2);\n      this.state.options.scroll.chart.dateTime.left = dayjs(this.state.options.scroll.chart.time).valueOf();\n      this.state.options.scroll.chart.dateTime.right = dayjs(\n        this.pixelOffsetXToTime(left + this.state.refs.chart.clientWidth)\n      ).valueOf();\n      this.scrollTo(left, top);\n    },\n\n    /**\n     * Scroll current chart to specified time (in milliseconds)\n     *\n     * @param {int} time\n     */\n    scrollToTime(time) {\n      let pos = this.timeToPixelOffsetX(time);\n      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      pos = pos - chartContainerWidth / 2;\n      if (pos > this.state.options.width) {\n        pos = this.state.options.width - chartContainerWidth;\n      }\n      this.scrollTo(pos);\n    },\n\n    /**\n     * Scroll chart or task list to specified pixel values\n     *\n     * @param {number|null} left\n     * @param {number|null} top\n     */\n    scrollTo(left = null, top = null) {\n      if (left !== null) {\n        this.state.refs.chartCalendarContainer.scrollLeft = left;\n        this.state.refs.chartGraphContainer.scrollLeft = left;\n        this.state.refs.chartScrollContainerHorizontal.scrollLeft = left;\n        this.state.options.scroll.left = left;\n      }\n      if (top !== null) {\n        this.state.refs.chartScrollContainerVertical.scrollTop = top;\n        this.state.refs.chartGraph.scrollTop = top;\n        this.state.refs.taskListItems.scrollTop = top;\n        this.state.options.scroll.top = top;\n        this.syncScrollTop();\n      }\n    },\n\n    /**\n     * After some actions like time zoom change we need to recompensate scroll position\n     * so as a result everything will be in same place\n     */\n    fixScrollPos() {\n      this.scrollToTime(this.state.options.scroll.chart.timeCenter);\n    },\n\n    /**\n     * Mouse wheel event handler\n     */\n    onWheelChart(ev) {\n      if (!ev.shiftKey && ev.deltaX === 0) {\n        let top = this.state.options.scroll.top + ev.deltaY;\n        const chartClientHeight = this.state.options.rowsHeight;\n        const scrollHeight = this.state.refs.chartGraph.scrollHeight - chartClientHeight;\n        if (top < 0) {\n          top = 0;\n        } else if (top > scrollHeight) {\n          top = scrollHeight;\n        }\n        this.scrollTo(null, top);\n      } else if (ev.shiftKey && ev.deltaX === 0) {\n        let left = this.state.options.scroll.left + ev.deltaY;\n        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;\n        if (left < 0) {\n          left = 0;\n        } else if (left > scrollWidth) {\n          left = scrollWidth;\n        }\n        this.scrollTo(left);\n      } else {\n        let left = this.state.options.scroll.left + ev.deltaX;\n        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;\n        if (left < 0) {\n          left = 0;\n        } else if (left > scrollWidth) {\n          left = scrollWidth;\n        }\n        this.scrollTo(left);\n      }\n    },\n\n    /**\n     * Time zoom change event handler\n     */\n    onTimeZoomChange(timeZoom) {\n      this.state.options.times.timeZoom = timeZoom;\n      this.recalculateTimes();\n      this.calculateSteps();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Row height change event handler\n     */\n    onRowHeightChange(height) {\n      this.state.options.row.height = height;\n      this.calculateTaskListColumnsDimensions();\n      this.syncScrollTop();\n    },\n\n    /**\n     * Scope change event handler\n     */\n    onScopeChange(value) {\n      this.state.options.scope.before = value;\n      this.state.options.scope.after = value;\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list width change event handler\n     */\n    onTaskListWidthChange(value) {\n      this.state.options.taskList.percent = value;\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list column width change event handler\n     */\n    onTaskListColumnWidthChange() {\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Listen to specified event names\n     */\n    initializeEvents() {\n      this.$on('chart-scroll-horizontal', this.onScrollChart);\n      this.$on('chart-scroll-vertical', this.onScrollChart);\n      this.$on('chart-wheel', this.onWheelChart);\n      this.$on('times-timeZoom-change', this.onTimeZoomChange);\n      this.$on('row-height-change', this.onRowHeightChange);\n      this.$on('scope-change', this.onScopeChange);\n      this.$on('taskList-width-change', this.onTaskListWidthChange);\n      this.$on('taskList-column-width-change', this.onTaskListColumnWidthChange);\n    },\n\n    /**\n     * When some action was performed (scale change for example) - recalculate time variables\n     */\n    recalculateTimes() {\n      let max = this.state.options.times.timeScale * 60;\n      let min = this.state.options.times.timeScale;\n      let steps = max / min;\n      let percent = this.state.options.times.timeZoom / 100;\n      this.state.options.times.timePerPixel =\n        this.state.options.times.timeScale * steps * percent + Math.pow(2, this.state.options.times.timeZoom);\n      this.state.options.times.totalViewDurationMs = dayjs(this.state.options.times.lastTime).diff(\n        this.state.options.times.firstTime,\n        'milliseconds'\n      );\n      this.state.options.times.totalViewDurationPx =\n        this.state.options.times.totalViewDurationMs / this.state.options.times.timePerPixel;\n      this.state.options.width =\n        this.state.options.times.totalViewDurationPx + this.style['grid-line-vertical']['stroke-width'];\n    },\n\n    /**\n     * Initialize time variables\n     */\n    initTimes() {\n      this.state.options.times.firstTime = dayjs(this.state.options.times.firstTaskTime)\n        .locale(this.state.options.locale.name)\n        .startOf('day')\n        .subtract(this.state.options.scope.before, 'days')\n        .startOf('day')\n        .valueOf();\n      this.state.options.times.lastTime = dayjs(this.state.options.times.lastTaskTime)\n        .locale(this.state.options.locale.name)\n        .endOf('day')\n        .add(this.state.options.scope.after, 'days')\n        .endOf('day')\n        .valueOf();\n      this.recalculateTimes();\n    },\n\n    /**\n     * Calculate steps\n     * Steps are days by default\n     * Each step contain information about time offset and pixel offset of this time inside gantt chart\n     */\n    calculateSteps() {\n      const steps = [];\n      const lastMs = dayjs(this.state.options.times.lastTime).valueOf();\n      const currentDate = dayjs(this.state.options.times.firstTime);\n      steps.push({\n        time: currentDate.valueOf(),\n        offset: {\n          ms: 0,\n          px: 0\n        }\n      });\n      for (\n        let currentDate = dayjs(this.state.options.times.firstTime)\n          .add(1, this.state.options.times.stepDuration)\n          .startOf('day');\n        currentDate.valueOf() <= lastMs;\n        currentDate = currentDate.add(1, this.state.options.times.stepDuration).startOf('day')\n      ) {\n        const offsetMs = currentDate.diff(this.state.options.times.firstTime, 'milliseconds');\n        const offsetPx = offsetMs / this.state.options.times.timePerPixel;\n        const step = {\n          time: currentDate.valueOf(),\n          offset: {\n            ms: offsetMs,\n            px: offsetPx\n          }\n        };\n        const previousStep = steps[steps.length - 1];\n        previousStep.width = {\n          ms: offsetMs - previousStep.offset.ms,\n          px: offsetPx - previousStep.offset.px\n        };\n        steps.push(step);\n      }\n      const lastStep = steps[steps.length - 1];\n      lastStep.width = {\n        ms: this.state.options.times.totalViewDurationMs - lastStep.offset.ms,\n        px: this.state.options.times.totalViewDurationPx - lastStep.offset.px\n      };\n      this.state.options.times.steps = steps;\n    },\n\n    /**\n     * Calculate calendar widths - when scale was changed for example\n     */\n    computeCalendarWidths() {\n      this.computeDayWidths();\n      this.computeHourWidths();\n      this.computeMonthWidths();\n    },\n\n    /**\n     * Compute width of calendar hours column widths basing on text widths\n     */\n    computeHourWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--hour'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs('2018-01-01T00:00:00').locale(localeName); // any date will be good for hours\n      let maxWidths = this.state.options.calendar.hour.maxWidths;\n      if (maxWidths.length) {\n        return;\n      }\n      for (let formatName in this.state.options.calendar.hour.format) {\n        maxWidths[formatName] = 0;\n      }\n      for (let hour = 0; hour < 24; hour++) {\n        let widths = { hour };\n        for (let formatName in this.state.options.calendar.hour.format) {\n          const hourFormatted = this.state.options.calendar.hour.format[formatName](currentDate);\n          this.state.options.calendar.hour.formatted[formatName].push(hourFormatted);\n          widths[formatName] = this.state.ctx.measureText(hourFormatted).width;\n        }\n        this.state.options.calendar.hour.widths.push(widths);\n        for (let formatName in this.state.options.calendar.hour.format) {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        }\n        currentDate = currentDate.add(1, 'hour');\n      }\n    },\n\n    /**\n     * Compute calendar days column widths basing on text widths\n     */\n    computeDayWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--day'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs(this.state.options.times.steps[0].time).locale(localeName);\n      let maxWidths = this.state.options.calendar.day.maxWidths;\n      this.state.options.calendar.day.widths = [];\n      Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n        maxWidths[formatName] = 0;\n      });\n      for (let day = 0, daysLen = this.state.options.times.steps.length; day < daysLen; day++) {\n        const widths = {\n          day\n        };\n        Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n          widths[formatName] = this.state.ctx.measureText(\n            this.state.options.calendar.day.format[formatName](currentDate)\n          ).width;\n        });\n        this.state.options.calendar.day.widths.push(widths);\n        Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'day');\n      }\n    },\n\n    /**\n     * Months count\n     *\n     * @description Returns number of different months in specified time range\n     *\n     * @param {number} fromTime - date in ms\n     * @param {number} toTime - date in ms\n     *\n     * @returns {number} different months count\n     */\n    monthsCount(fromTime, toTime) {\n      if (fromTime > toTime) {\n        return 0;\n      }\n      let currentMonth = dayjs(fromTime);\n      let previousMonth = currentMonth.clone();\n      let monthsCount = 1;\n      while (currentMonth.valueOf() <= toTime) {\n        currentMonth = currentMonth.add(1, 'day');\n        if (previousMonth.month() !== currentMonth.month()) {\n          monthsCount++;\n        }\n        previousMonth = currentMonth.clone();\n      }\n      return monthsCount;\n    },\n\n    /**\n     * Compute month calendar columns widths basing on text widths\n     */\n    computeMonthWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--month'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      let maxWidths = this.state.options.calendar.month.maxWidths;\n      this.state.options.calendar.month.widths = [];\n      Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n        maxWidths[formatName] = 0;\n      });\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs(this.state.options.times.firstTime).locale(localeName);\n      const monthsCount = this.monthsCount(this.state.options.times.firstTime, this.state.options.times.lastTime);\n      for (let month = 0; month < monthsCount; month++) {\n        const widths = {\n          month\n        };\n        Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n          widths[formatName] = this.state.ctx.measureText(\n            this.state.options.calendar.month.format[formatName](currentDate)\n          ).width;\n        });\n        this.state.options.calendar.month.widths.push(widths);\n        Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'month');\n      }\n    },\n\n    /**\n     * Prepare time and date variables for gantt\n     */\n    prepareDates() {\n      let firstTaskTime = Number.MAX_SAFE_INTEGER;\n      let lastTaskTime = 0;\n      for (let index = 0, len = this.state.tasks.length; index < len; index++) {\n        let task = this.state.tasks[index];\n        if (task.startTime < firstTaskTime) {\n          firstTaskTime = task.startTime;\n        }\n        if (task.startTime + task.duration > lastTaskTime) {\n          lastTaskTime = task.startTime + task.duration;\n        }\n      }\n      this.state.options.times.firstTaskTime = firstTaskTime;\n      this.state.options.times.lastTaskTime = lastTaskTime;\n      this.state.options.times.firstTime = dayjs(firstTaskTime)\n        .locale(this.state.options.locale.name)\n        .startOf('day')\n        .subtract(this.state.options.scope.before, 'days')\n        .startOf('day')\n        .valueOf();\n      this.state.options.times.lastTime = dayjs(lastTaskTime)\n        .locale(this.state.options.locale.name)\n        .endOf('day')\n        .add(this.state.options.scope.after, 'days')\n        .endOf('day')\n        .valueOf();\n    },\n\n    /**\n     * Setup and calculate everything\n     */\n    setup(itsUpdate = '') {\n      this.initialize(itsUpdate);\n      this.prepareDates();\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.state.options.taskList.width = this.state.options.taskList.columns.reduce(\n        (prev, current) => {\n          return { width: prev.width + current.width };\n        },\n        { width: 0 }\n      ).width;\n    },\n\n    /**\n     * Global resize event (from window.addEventListener)\n     */\n    globalOnResize() {\n      if (typeof this.$el === 'undefined' || !this.$el) {\n        return;\n      }\n      this.state.options.clientWidth = this.$el.clientWidth;\n      if (\n        this.state.options.taskList.widthFromPercentage >\n        (this.state.options.clientWidth / 100) * this.state.options.taskList.widthThreshold\n      ) {\n        const diff =\n          this.state.options.taskList.widthFromPercentage -\n          (this.state.options.clientWidth / 100) * this.state.options.taskList.widthThreshold;\n        let diffPercent = 100 - (diff / this.state.options.taskList.widthFromPercentage) * 100;\n        if (diffPercent < 0) {\n          diffPercent = 0;\n        }\n        this.state.options.taskList.columns.forEach(column => {\n          column.thresholdPercent = diffPercent;\n        });\n      } else {\n        this.state.options.taskList.columns.forEach(column => {\n          column.thresholdPercent = 100;\n        });\n      }\n      this.calculateTaskListColumnsDimensions();\n      this.$emit('calendar-recalculate');\n      this.syncScrollTop();\n    }\n  },\n\n  computed: {\n    /**\n     * Get visible tasks\n     * Very important method which will bring us only those tasks that are visible inside gantt chart\n     * For example when task is collapsed - children of this task are not visible - we should not render them\n     */\n    visibleTasks() {\n      const visibleTasks = this.state.tasks.filter(task => this.isTaskVisible(task));\n      const maxRows = visibleTasks.slice(0, this.state.options.maxRows);\n      this.state.options.rowsHeight = this.getTasksHeight(maxRows);\n      let heightCompensation = 0;\n      if (this.state.options.maxHeight && this.state.options.rowsHeight > this.state.options.maxHeight) {\n        heightCompensation = this.state.options.rowsHeight - this.state.options.maxHeight;\n        this.state.options.rowsHeight = this.state.options.maxHeight;\n      }\n      this.state.options.height = this.getHeight(maxRows) - heightCompensation;\n      this.state.options.allVisibleTasksHeight = this.getTasksHeight(visibleTasks);\n      this.state.options.outerHeight = this.getHeight(maxRows, true) - heightCompensation;\n      let len = visibleTasks.length;\n      for (let index = 0; index < len; index++) {\n        let task = visibleTasks[index];\n        task.width =\n          task.duration / this.state.options.times.timePerPixel - this.style['grid-line-vertical']['stroke-width'];\n        if (task.width < 0) {\n          task.width = 0;\n        }\n        task.height = this.state.options.row.height;\n        task.x = this.timeToPixelOffsetX(task.startTime);\n        task.y =\n          (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) * index +\n          this.state.options.chart.grid.horizontal.gap;\n      }\n      return visibleTasks;\n    },\n\n    /**\n     * Style shortcut\n     */\n    style() {\n      return this.state.dynamicStyle;\n    },\n\n    /**\n     * Get columns and compute dimensions on the fly\n     */\n    getTaskListColumns() {\n      this.calculateTaskListColumnsDimensions();\n      return this.state.options.taskList.columns;\n    },\n\n    /**\n     * Tasks used for communicate with parent component\n     */\n    outputTasks() {\n      return this.state.tasks;\n    },\n\n    /**\n     * Options used to communicate with parent component\n     */\n    outputOptions() {\n      return this.state.options;\n    }\n  },\n\n  /**\n   * Watch tasks after gantt instance is created and react when we have new kids on the block\n   */\n  created() {\n    this.initializeEvents();\n    this.setup();\n    this.state.unwatchTasks = this.$watch(\n      'tasks',\n      tasks => {\n        const notEqual = notEqualDeep(tasks, this.outputTasks);\n        if (notEqual) {\n          this.setup('tasks');\n        }\n      },\n      { deep: true }\n    );\n    this.state.unwatchOptions = this.$watch(\n      'options',\n      opts => {\n        const notEqual = notEqualDeep(opts, this.outputOptions);\n        if (notEqual) {\n          this.setup('options');\n        }\n      },\n      { deep: true }\n    );\n    this.state.unwatchStyle = this.$watch(\n      'dynamicStyle',\n      style => {\n        const notEqual = notEqualDeep(style, this.dynamicStyle);\n        if (notEqual) {\n          this.initializeStyle();\n        }\n      },\n      { deep: true, immediate: true }\n    );\n\n    this.state.unwatchOutputTasks = this.$watch(\n      'outputTasks',\n      tasks => {\n        this.$emit('tasks-changed', tasks.map(task => task));\n      },\n      { deep: true }\n    );\n    this.state.unwatchOutputOptions = this.$watch(\n      'outputOptions',\n      options => {\n        this.$emit('options-changed', mergeDeep({}, options));\n      },\n      { deep: true }\n    );\n    this.state.unwatchOutputStyle = this.$watch(\n      'style',\n      style => {\n        this.$emit('dynamic-style-changed', mergeDeep({}, style));\n      },\n      { deep: true }\n    );\n\n    this.$root.$emit('gantt-elastic-created', this);\n    this.$emit('created', this);\n  },\n\n  /**\n   * Emit before-mount event\n   */\n  beforeMount() {\n    this.$emit('before-mount', this);\n  },\n\n  /**\n   * Emit ready/mounted events and deliver this gantt instance to outside world when needed\n   */\n  mounted() {\n    this.state.options.clientWidth = this.$el.clientWidth;\n    this.state.resizeObserver = new ResizeObserver((entries, observer) => {\n      this.globalOnResize();\n    });\n    this.state.resizeObserver.observe(this.$el.parentNode);\n    this.globalOnResize();\n    this.$emit('ready', this);\n    this.$root.$emit('gantt-elastic-mounted', this);\n    this.$emit('mounted', this);\n    this.$root.$emit('gantt-elastic-ready', this);\n  },\n\n  /**\n   * Emit event when data was changed and before update (you can cleanup dom events here for example)\n   */\n  beforeUpdate() {\n    this.$emit('before-update');\n  },\n\n  /**\n   * Emit event when gantt-elastic view was updated\n   */\n  updated() {\n    this.$nextTick(() => {\n      this.$emit('updated');\n    });\n  },\n\n  /**\n   * Before destroy event - clean up\n   */\n  beforeDestroy() {\n    this.state.resizeObserver.unobserve(this.$el.parentNode);\n    this.state.unwatchTasks();\n    this.state.unwatchOptions();\n    this.state.unwatchStyle();\n    this.state.unwatchOutputTasks();\n    this.state.unwatchOutputOptions();\n    this.state.unwatchOutputStyle();\n    this.$emit('before-destroy');\n  },\n\n  /**\n   * Emit event after gantt-elastic was destroyed\n   */\n  destroyed() {\n    this.$emit('destroyed');\n  }\n};\nexport default GanttElastic;\n</script>\n\n<style>\n[class^='gantt-elastic'],\n[class*=' gantt-elastic'] {\n  box-sizing: border-box;\n}\n.gantt-elastic__main-view svg {\n  display: block;\n}\n.gantt-elastic__grid-horizontal-line,\n.gantt-elastic__grid-vertical-line {\n  stroke: #a0a0a0;\n  stroke-width: 1;\n}\nforeignObject > * {\n  margin: 0px;\n}\n.gantt-elastic .p-2 {\n  padding: 10rem;\n}\n.gantt-elastic__main-view-main-container,\n.gantt-elastic__main-view-container {\n  overflow: hidden;\n  max-width: 100%;\n}\n.gantt-elastic__task-list-header-column:last-of-type {\n  border-right: 1px solid #00000050;\n}\n.gantt-elastic__task-list-item:last-of-type {\n  border-bottom: 1px solid #00000050;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover {\n  overflow: visible !important;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover > .gantt-elastic__task-list-item-value-container {\n  position: relative;\n  overflow: visible !important;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover > .gantt-elastic__task-list-item-value {\n  position: absolute;\n}\n</style>\n"]}]}