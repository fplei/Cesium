{"remainingRequest":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js??vue-loader-options!/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/components/Calendar/Calendar.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/components/Calendar/Calendar.vue","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_babel-loader@8.2.5@babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fanpenglei/Study/Code/cesium-demoV1.1/node_modules/_vue-loader@15.10.0@vue-loader/lib/index.js","mtime":1655715099000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBkYXlqcyBmcm9tICdkYXlqcyc7CmltcG9ydCBDYWxlbmRhclJvdyBmcm9tICcuL0NhbGVuZGFyUm93LnZ1ZSc7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0NhbGVuZGFyJywKICBjb21wb25lbnRzOiB7CiAgICBDYWxlbmRhclJvdwogIH0sCiAgaW5qZWN0OiBbJ3Jvb3QnXSwKICBkYXRhKCkgewogICAgcmV0dXJuIHt9OwogIH0sCgogIG1ldGhvZHM6IHsKICAgIC8qKgogICAgICogSG93IG1hbnkgaG91cnMgd2lsbCBmaXQ/CiAgICAgKgogICAgICogQHJldHVybnMge29iamVjdH0KICAgICAqLwogICAgaG93TWFueUhvdXJzRml0KGRheUluZGV4KSB7CiAgICAgIGNvbnN0IHN0cm9rZSA9IDE7CiAgICAgIGNvbnN0IGFkZGl0aW9uYWxTcGFjZSA9IHN0cm9rZSArIDI7CiAgICAgIGxldCBmdWxsQ2VsbFdpZHRoID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcHNbZGF5SW5kZXhdLndpZHRoLnB4OwogICAgICBsZXQgZm9ybWF0TmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLmZvcm1hdCk7CiAgICAgIGZvciAobGV0IGhvdXJzID0gMjQ7IGhvdXJzID4gMTsgaG91cnMgPSBNYXRoLmNlaWwoaG91cnMgLyAyKSkgewogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgb2YgZm9ybWF0TmFtZXMpIHsKICAgICAgICAgIGlmICgKICAgICAgICAgICAgKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIubWF4V2lkdGhzW2Zvcm1hdE5hbWVdICsgYWRkaXRpb25hbFNwYWNlKSAqIGhvdXJzIDw9IGZ1bGxDZWxsV2lkdGggJiYKICAgICAgICAgICAgaG91cnMgPiAxCiAgICAgICAgICApIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBjb3VudDogaG91cnMsCiAgICAgICAgICAgICAgdHlwZTogZm9ybWF0TmFtZQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gewogICAgICAgIGNvdW50OiAwLAogICAgICAgIHR5cGU6ICcnCiAgICAgIH07CiAgICB9LAoKICAgIC8qKgogICAgICogSG93IG1hbnkgZGF5cyB3aWxsIGZpdD8KICAgICAqCiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fQogICAgICovCiAgICBob3dNYW55RGF5c0ZpdCgpIHsKICAgICAgY29uc3Qgc3Ryb2tlID0gMTsKICAgICAgY29uc3QgYWRkaXRpb25hbFNwYWNlID0gc3Ryb2tlICsgMjsKICAgICAgbGV0IGZ1bGxXaWR0aCA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLndpZHRoOwogICAgICBsZXQgZm9ybWF0TmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuZm9ybWF0KTsKICAgICAgZm9yIChsZXQgZGF5cyA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBzLmxlbmd0aDsgZGF5cyA+IDE7IGRheXMgPSBNYXRoLmNlaWwoZGF5cyAvIDIpKSB7CiAgICAgICAgZm9yIChsZXQgZm9ybWF0TmFtZSBvZiBmb3JtYXROYW1lcykgewogICAgICAgICAgaWYgKAogICAgICAgICAgICAodGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5Lm1heFdpZHRoc1tmb3JtYXROYW1lXSArIGFkZGl0aW9uYWxTcGFjZSkgKiBkYXlzIDw9IGZ1bGxXaWR0aCAmJgogICAgICAgICAgICBkYXlzID4gMQogICAgICAgICAgKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgY291bnQ6IGRheXMsCiAgICAgICAgICAgICAgdHlwZTogZm9ybWF0TmFtZQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gewogICAgICAgIGNvdW50OiAwLAogICAgICAgIHR5cGU6ICcnCiAgICAgIH07CiAgICB9LAoKICAgIC8qKgogICAgICogSG93IG1hbnkgbW9udGhzIHdpbGwgZml0PwogICAgICoKICAgICAqIEByZXR1cm5zIHtvYmplY3R9CiAgICAgKi8KICAgIGhvd01hbnlNb250aHNGaXQoKSB7CiAgICAgIGNvbnN0IHN0cm9rZSA9IDE7CiAgICAgIGNvbnN0IGFkZGl0aW9uYWxTcGFjZSA9IHN0cm9rZSArIDI7CiAgICAgIGxldCBmdWxsV2lkdGggPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy53aWR0aDsKICAgICAgbGV0IGZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGguZm9ybWF0KTsKICAgICAgbGV0IGN1cnJlbnRNb250aCA9IGRheWpzKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSk7CiAgICAgIGxldCBwcmV2aW91c01vbnRoID0gY3VycmVudE1vbnRoLmNsb25lKCk7CiAgICAgIGNvbnN0IGxhc3RUaW1lID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWU7CiAgICAgIGxldCBtb250aHNDb3VudCA9IHRoaXMucm9vdC5tb250aHNDb3VudCgKICAgICAgICB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5maXJzdFRpbWUsCiAgICAgICAgdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWUKICAgICAgKTsKICAgICAgaWYgKG1vbnRoc0NvdW50ID09PSAxKSB7CiAgICAgICAgZm9yIChsZXQgZm9ybWF0TmFtZSBvZiBmb3JtYXROYW1lcykgewogICAgICAgICAgaWYgKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLm1heFdpZHRoc1tmb3JtYXROYW1lXSArIGFkZGl0aW9uYWxTcGFjZSA8PSBmdWxsV2lkdGgpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBjb3VudDogMSwKICAgICAgICAgICAgICB0eXBlOiBmb3JtYXROYW1lCiAgICAgICAgICAgIH07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAobGV0IG1vbnRocyA9IG1vbnRoc0NvdW50OyBtb250aHMgPiAxOyBtb250aHMgPSBNYXRoLmNlaWwobW9udGhzIC8gMikpIHsKICAgICAgICBmb3IgKGxldCBmb3JtYXROYW1lIG9mIGZvcm1hdE5hbWVzKSB7CiAgICAgICAgICBpZiAoCiAgICAgICAgICAgICh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5tYXhXaWR0aHNbZm9ybWF0TmFtZV0gKyBhZGRpdGlvbmFsU3BhY2UpICogbW9udGhzIDw9IGZ1bGxXaWR0aCAmJgogICAgICAgICAgICBtb250aHMgPiAxCiAgICAgICAgICApIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICBjb3VudDogbW9udGhzLAogICAgICAgICAgICAgIHR5cGU6IGZvcm1hdE5hbWUKICAgICAgICAgICAgfTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHsKICAgICAgICBjb3VudDogMCwKICAgICAgICB0eXBlOiBmb3JtYXROYW1lc1swXQogICAgICB9OwogICAgfSwKCiAgICAvKioKICAgICAqIEdlbmVyYXRlIGhvdXJzCiAgICAgKgogICAgICogQHJldHVybnMge2FycmF5fQogICAgICovCiAgICBnZW5lcmF0ZUhvdXJzKCkgewogICAgICBsZXQgYWxsSG91cnMgPSBbXTsKICAgICAgaWYgKCF0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLmRpc3BsYXkpIHsKICAgICAgICByZXR1cm4gYWxsSG91cnM7CiAgICAgIH0KICAgICAgY29uc3Qgc3RlcHMgPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwczsKICAgICAgY29uc3QgbG9jYWxlTmFtZSA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmxvY2FsZS5uYW1lOwogICAgICBmb3IgKGxldCBob3VySW5kZXggPSAwLCBsZW4gPSBzdGVwcy5sZW5ndGg7IGhvdXJJbmRleCA8IGxlbjsgaG91ckluZGV4KyspIHsKICAgICAgICBjb25zdCBob3Vyc0NvdW50ID0gdGhpcy5ob3dNYW55SG91cnNGaXQoaG91ckluZGV4KTsKICAgICAgICBpZiAoaG91cnNDb3VudC5jb3VudCA9PT0gMCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGhvdXJzID0geyBrZXk6IGhvdXJJbmRleCArICdzdGVwJywgY2hpbGRyZW46IFtdIH07CiAgICAgICAgY29uc3QgaG91clN0ZXAgPSAyNCAvIGhvdXJzQ291bnQuY291bnQ7CiAgICAgICAgY29uc3QgaG91cldpZHRoUHggPSBzdGVwc1tob3VySW5kZXhdLndpZHRoLnB4IC8gaG91cnNDb3VudC5jb3VudDsKICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaG91cnNDb3VudC5jb3VudDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgICBjb25zdCBob3VyID0gaSAqIGhvdXJTdGVwOwogICAgICAgICAgbGV0IGluZGV4ID0gaG91ckluZGV4OwogICAgICAgICAgaWYgKGhvdXJJbmRleCA+IDApIHsKICAgICAgICAgICAgaW5kZXggPSBob3VySW5kZXggLSBNYXRoLmZsb29yKGhvdXJJbmRleCAvIDI0KSAqIDI0OwogICAgICAgICAgfQogICAgICAgICAgbGV0IHRleHRXaWR0aCA9IDA7CiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmhvdXIud2lkdGhzW2luZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci53aWR0aHNbaW5kZXhdW2hvdXJzQ291bnQudHlwZV07CiAgICAgICAgICB9CiAgICAgICAgICBsZXQgeCA9IHN0ZXBzW2hvdXJJbmRleF0ub2Zmc2V0LnB4ICsgaG91cldpZHRoUHggKiBpOwogICAgICAgICAgaG91cnMuY2hpbGRyZW4ucHVzaCh7CiAgICAgICAgICAgIGluZGV4OiBob3VySW5kZXgsCiAgICAgICAgICAgIGtleTogJ2gnICsgaSwKICAgICAgICAgICAgeCwKICAgICAgICAgICAgeTogdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuZGF5LmhlaWdodCArIHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmhlaWdodCwKICAgICAgICAgICAgd2lkdGg6IGhvdXJXaWR0aFB4LAogICAgICAgICAgICB0ZXh0V2lkdGgsCiAgICAgICAgICAgIGhlaWdodDogdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5oZWlnaHQsCiAgICAgICAgICAgIGxhYmVsOiB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5ob3VyLmZvcm1hdHRlZFtob3Vyc0NvdW50LnR5cGVdW2hvdXJdCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgYWxsSG91cnMucHVzaChob3Vycyk7CiAgICAgIH0KICAgICAgcmV0dXJuIGFsbEhvdXJzOwogICAgfSwKCiAgICAvKioKICAgICAqIEdlbmVyYXRlIGRheXMKICAgICAqCiAgICAgKiBAcmV0dXJucyB7YXJyYXl9CiAgICAgKi8KICAgIGdlbmVyYXRlRGF5cygpIHsKICAgICAgbGV0IGRheXMgPSBbXTsKICAgICAgaWYgKCF0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuZGlzcGxheSkgewogICAgICAgIHJldHVybiBkYXlzOwogICAgICB9CiAgICAgIGNvbnN0IGRheXNDb3VudCA9IHRoaXMuaG93TWFueURheXNGaXQoKTsKICAgICAgaWYgKGRheXNDb3VudC5jb3VudCA9PT0gMCkgewogICAgICAgIHJldHVybiBkYXlzOwogICAgICB9CiAgICAgIGNvbnN0IHN0ZXBzID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcHM7CiAgICAgIGNvbnN0IGxvY2FsZU5hbWUgPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5sb2NhbGUubmFtZTsKICAgICAgY29uc3QgZGF5U3RlcCA9IE1hdGguY2VpbChzdGVwcy5sZW5ndGggLyBkYXlzQ291bnQuY291bnQpOwogICAgICBmb3IgKGxldCBkYXlJbmRleCA9IDAsIGxlbiA9IHN0ZXBzLmxlbmd0aDsgZGF5SW5kZXggPCBsZW47IGRheUluZGV4ICs9IGRheVN0ZXApIHsKICAgICAgICBsZXQgZGF5V2lkdGhQeCA9IDA7CiAgICAgICAgLy8gZGF5IGNvdWxkIGJlIHNob3J0ZXIgKGRheWxpZ2h0IHNhdmluZyB0aW1lKSBzbyBqb2luIHdpZHRocyBhbmQgZGl2aWRlCiAgICAgICAgZm9yIChsZXQgY3VycmVudFN0ZXAgPSAwOyBjdXJyZW50U3RlcCA8IGRheVN0ZXA7IGN1cnJlbnRTdGVwKyspIHsKICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcHNbZGF5SW5kZXggKyBjdXJyZW50U3RlcF0gIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgIGRheVdpZHRoUHggKz0gc3RlcHNbZGF5SW5kZXggKyBjdXJyZW50U3RlcF0ud2lkdGgucHg7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGNvbnN0IGRhdGUgPSBkYXlqcyhzdGVwc1tkYXlJbmRleF0udGltZSk7CiAgICAgICAgbGV0IHRleHRXaWR0aCA9IDA7CiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkud2lkdGhzW2RheUluZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS53aWR0aHNbZGF5SW5kZXhdW2RheXNDb3VudC50eXBlXTsKICAgICAgICB9CiAgICAgICAgbGV0IHggPSBzdGVwc1tkYXlJbmRleF0ub2Zmc2V0LnB4OwogICAgICAgIGRheXMucHVzaCh7CiAgICAgICAgICBpbmRleDogZGF5SW5kZXgsCiAgICAgICAgICBrZXk6IHN0ZXBzW2RheUluZGV4XS50aW1lICsgJ2QnLAogICAgICAgICAgeCwKICAgICAgICAgIHk6IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmhlaWdodCwKICAgICAgICAgIHdpZHRoOiBkYXlXaWR0aFB4LAogICAgICAgICAgdGV4dFdpZHRoLAogICAgICAgICAgaGVpZ2h0OiB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuaGVpZ2h0LAogICAgICAgICAgbGFiZWw6IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5mb3JtYXRbZGF5c0NvdW50LnR5cGVdKGRhdGUubG9jYWxlKGxvY2FsZU5hbWUpKQogICAgICAgIH0pOwogICAgICB9CiAgICAgIHJldHVybiBkYXlzLm1hcChpdGVtID0+ICh7CiAgICAgICAga2V5OiBpdGVtLmtleSwKICAgICAgICBjaGlsZHJlbjogW2l0ZW1dCiAgICAgIH0pKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBHZW5lcmF0ZSBtb250aHMKICAgICAqCiAgICAgKiBAcmV0dXJucyB7YXJyYXl9CiAgICAgKi8KICAgIGdlbmVyYXRlTW9udGhzKCkgewogICAgICBsZXQgbW9udGhzID0gW107CiAgICAgIGlmICghdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIubW9udGguZGlzcGxheSkgewogICAgICAgIHJldHVybiBtb250aHM7CiAgICAgIH0KICAgICAgY29uc3QgbW9udGhzQ291bnQgPSB0aGlzLmhvd01hbnlNb250aHNGaXQoKTsKICAgICAgaWYgKG1vbnRoc0NvdW50LmNvdW50ID09PSAwKSB7CiAgICAgICAgcmV0dXJuIG1vbnRoczsKICAgICAgfQogICAgICBjb25zdCBzdGVwcyA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLnN0ZXBzOwogICAgICBjb25zdCBsb2NhbGVOYW1lID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMubG9jYWxlLm5hbWU7CiAgICAgIGxldCBmb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmZvcm1hdCk7CiAgICAgIGxldCBjdXJyZW50RGF0ZSA9IGRheWpzKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmZpcnN0VGltZSk7CiAgICAgIGZvciAobGV0IG1vbnRoSW5kZXggPSAwOyBtb250aEluZGV4IDwgbW9udGhzQ291bnQuY291bnQ7IG1vbnRoSW5kZXgrKykgewogICAgICAgIGxldCBtb250aFdpZHRoID0gMDsKICAgICAgICBsZXQgbW9udGhPZmZzZXQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjsKICAgICAgICBsZXQgZmluYWxEYXRlID0gZGF5anMoY3VycmVudERhdGUpCiAgICAgICAgICAuYWRkKDEsICdtb250aCcpCiAgICAgICAgICAuc3RhcnRPZignbW9udGgnKTsKICAgICAgICBpZiAoZmluYWxEYXRlLnZhbHVlT2YoKSA+IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLnRpbWVzLmxhc3RUaW1lKSB7CiAgICAgICAgICBmaW5hbERhdGUgPSBkYXlqcyh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5sYXN0VGltZSk7CiAgICAgICAgfQogICAgICAgIC8vIHdlIG11c3QgZmluZCBmaXJzdCBhbmQgbGFzdCBzdGVwIHRvIGdldCB0aGUgb2Zmc2V0cyAvIHdpZHRocwogICAgICAgIGZvciAobGV0IHN0ZXAgPSAwLCBsZW4gPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy50aW1lcy5zdGVwcy5sZW5ndGg7IHN0ZXAgPCBsZW47IHN0ZXArKykgewogICAgICAgICAgbGV0IGN1cnJlbnRTdGVwID0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMuc3RlcHNbc3RlcF07CiAgICAgICAgICBpZiAoY3VycmVudFN0ZXAudGltZSA+PSBjdXJyZW50RGF0ZS52YWx1ZU9mKCkgJiYgY3VycmVudFN0ZXAudGltZSA8IGZpbmFsRGF0ZS52YWx1ZU9mKCkpIHsKICAgICAgICAgICAgbW9udGhXaWR0aCArPSBjdXJyZW50U3RlcC53aWR0aC5weDsKICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGVwLm9mZnNldC5weCA8IG1vbnRoT2Zmc2V0KSB7CiAgICAgICAgICAgICAgbW9udGhPZmZzZXQgPSBjdXJyZW50U3RlcC5vZmZzZXQucHg7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbGV0IGxhYmVsID0gJyc7CiAgICAgICAgbGV0IGNob29zZW5Gb3JtYXROYW1lOwogICAgICAgIGZvciAobGV0IGZvcm1hdE5hbWUgb2YgZm9ybWF0TmFtZXMpIHsKICAgICAgICAgIGlmICh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5tYXhXaWR0aHNbZm9ybWF0TmFtZV0gKyAyIDw9IG1vbnRoV2lkdGgpIHsKICAgICAgICAgICAgbGFiZWwgPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5mb3JtYXRbZm9ybWF0TmFtZV0oY3VycmVudERhdGUubG9jYWxlKGxvY2FsZU5hbWUpKTsKICAgICAgICAgICAgY2hvb3NlbkZvcm1hdE5hbWUgPSBmb3JtYXROYW1lOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsZXQgdGV4dFdpZHRoID0gMDsKICAgICAgICBpZiAodHlwZW9mIHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLndpZHRoc1ttb250aEluZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLndpZHRoc1ttb250aEluZGV4XVtjaG9vc2VuRm9ybWF0TmFtZV07CiAgICAgICAgfQogICAgICAgIGxldCB4ID0gbW9udGhPZmZzZXQ7CiAgICAgICAgbW9udGhzLnB1c2goewogICAgICAgICAgaW5kZXg6IG1vbnRoSW5kZXgsCiAgICAgICAgICBrZXk6IG1vbnRoSW5kZXggKyAnbScsCiAgICAgICAgICB4LAogICAgICAgICAgeTogMCwKICAgICAgICAgIHdpZHRoOiBtb250aFdpZHRoLAogICAgICAgICAgdGV4dFdpZHRoLAogICAgICAgICAgY2hvb3NlbkZvcm1hdE5hbWUsCiAgICAgICAgICBoZWlnaHQ6IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmhlaWdodCwKICAgICAgICAgIGxhYmVsCiAgICAgICAgfSk7CiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZS5hZGQoMSwgJ21vbnRoJykuc3RhcnRPZignbW9udGgnKTsKICAgICAgICBpZiAoY3VycmVudERhdGUudmFsdWVPZigpID4gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWUpIHsKICAgICAgICAgIGN1cnJlbnREYXRlID0gZGF5anModGhpcy5yb290LnN0YXRlLm9wdGlvbnMudGltZXMubGFzdFRpbWUpOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gbW9udGhzLm1hcChpdGVtID0+ICh7CiAgICAgICAga2V5OiBpdGVtLmtleSwKICAgICAgICBjaGlsZHJlbjogW2l0ZW1dCiAgICAgIH0pKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBTdW0gYWxsIGNhbGVuZGFyIHJvd3MgaGVpZ2h0IGFuZCByZXR1cm4gcmVzdWx0CiAgICAgKgogICAgICogQHJldHVybnMge2ludH0KICAgICAqLwogICAgY2FsY3VsYXRlQ2FsZW5kYXJEaW1lbnNpb25zKHsgaG91cnMsIGRheXMsIG1vbnRocyB9KSB7CiAgICAgIGxldCBoZWlnaHQgPSAwOwogICAgICBpZiAodGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5kaXNwbGF5ICYmIGhvdXJzLmxlbmd0aCA+IDApIHsKICAgICAgICBoZWlnaHQgKz0gdGhpcy5yb290LnN0YXRlLm9wdGlvbnMuY2FsZW5kYXIuaG91ci5oZWlnaHQ7CiAgICAgIH0KICAgICAgaWYgKHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLmRheS5kaXNwbGF5ICYmIGRheXMubGVuZ3RoID4gMCkgewogICAgICAgIGhlaWdodCArPSB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5kYXkuaGVpZ2h0OwogICAgICB9CiAgICAgIGlmICh0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5tb250aC5kaXNwbGF5ICYmIG1vbnRocy5sZW5ndGggPiAwKSB7CiAgICAgICAgaGVpZ2h0ICs9IHRoaXMucm9vdC5zdGF0ZS5vcHRpb25zLmNhbGVuZGFyLm1vbnRoLmhlaWdodDsKICAgICAgfQogICAgICB0aGlzLnJvb3Quc3RhdGUub3B0aW9ucy5jYWxlbmRhci5oZWlnaHQgPSBoZWlnaHQ7CiAgICB9CiAgfSwKCiAgY29tcHV0ZWQ6IHsKICAgIGRhdGVzKCkgewogICAgICBjb25zdCBob3VycyA9IHRoaXMuZ2VuZXJhdGVIb3VycygpOwogICAgICBjb25zdCBkYXlzID0gdGhpcy5nZW5lcmF0ZURheXMoKTsKICAgICAgY29uc3QgbW9udGhzID0gdGhpcy5nZW5lcmF0ZU1vbnRocygpOwogICAgICBjb25zdCBhbGxEYXRlcyA9IHsgaG91cnMsIGRheXMsIG1vbnRocyB9OwogICAgICB0aGlzLmNhbGN1bGF0ZUNhbGVuZGFyRGltZW5zaW9ucyhhbGxEYXRlcyk7CiAgICAgIHJldHVybiBhbGxEYXRlczsKICAgIH0KICB9Cn07Cg=="},{"version":3,"sources":["Calendar.vue"],"names":[],"mappings":";AAsBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Calendar.vue","sourceRoot":"node_modules/_gantt-elastic@1.0.12@gantt-elastic/src/components/Calendar","sourcesContent":["<!--\n/**\n * @fileoverview Calendar component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <div\n    class=\"gantt-elastic__calendar-wrapper\"\n    :style=\"{ ...root.style['calendar-wrapper'], width: root.state.options.width + 'px' }\"\n  >\n    <div class=\"gantt-elastic__calendar\" :style=\"{ ...root.style['calendar'], width: root.state.options.width + 'px' }\">\n      <calendar-row :items=\"dates.months\" which=\"month\" v-if=\"root.state.options.calendar.month.display\"></calendar-row>\n      <calendar-row :items=\"dates.days\" which=\"day\" v-if=\"root.state.options.calendar.day.display\"></calendar-row>\n      <calendar-row :items=\"dates.hours\" which=\"hour\" v-if=\"root.state.options.calendar.hour.display\"></calendar-row>\n    </div>\n  </div>\n</template>\n\n<script>\nimport dayjs from 'dayjs';\nimport CalendarRow from './CalendarRow.vue';\n\nexport default {\n  name: 'Calendar',\n  components: {\n    CalendarRow\n  },\n  inject: ['root'],\n  data() {\n    return {};\n  },\n\n  methods: {\n    /**\n     * How many hours will fit?\n     *\n     * @returns {object}\n     */\n    howManyHoursFit(dayIndex) {\n      const stroke = 1;\n      const additionalSpace = stroke + 2;\n      let fullCellWidth = this.root.state.options.times.steps[dayIndex].width.px;\n      let formatNames = Object.keys(this.root.state.options.calendar.hour.format);\n      for (let hours = 24; hours > 1; hours = Math.ceil(hours / 2)) {\n        for (let formatName of formatNames) {\n          if (\n            (this.root.state.options.calendar.hour.maxWidths[formatName] + additionalSpace) * hours <= fullCellWidth &&\n            hours > 1\n          ) {\n            return {\n              count: hours,\n              type: formatName\n            };\n          }\n        }\n      }\n      return {\n        count: 0,\n        type: ''\n      };\n    },\n\n    /**\n     * How many days will fit?\n     *\n     * @returns {object}\n     */\n    howManyDaysFit() {\n      const stroke = 1;\n      const additionalSpace = stroke + 2;\n      let fullWidth = this.root.state.options.width;\n      let formatNames = Object.keys(this.root.state.options.calendar.day.format);\n      for (let days = this.root.state.options.times.steps.length; days > 1; days = Math.ceil(days / 2)) {\n        for (let formatName of formatNames) {\n          if (\n            (this.root.state.options.calendar.day.maxWidths[formatName] + additionalSpace) * days <= fullWidth &&\n            days > 1\n          ) {\n            return {\n              count: days,\n              type: formatName\n            };\n          }\n        }\n      }\n      return {\n        count: 0,\n        type: ''\n      };\n    },\n\n    /**\n     * How many months will fit?\n     *\n     * @returns {object}\n     */\n    howManyMonthsFit() {\n      const stroke = 1;\n      const additionalSpace = stroke + 2;\n      let fullWidth = this.root.state.options.width;\n      let formatNames = Object.keys(this.root.state.options.calendar.month.format);\n      let currentMonth = dayjs(this.root.state.options.times.firstTime);\n      let previousMonth = currentMonth.clone();\n      const lastTime = this.root.state.options.times.lastTime;\n      let monthsCount = this.root.monthsCount(\n        this.root.state.options.times.firstTime,\n        this.root.state.options.times.lastTime\n      );\n      if (monthsCount === 1) {\n        for (let formatName of formatNames) {\n          if (this.root.state.options.calendar.month.maxWidths[formatName] + additionalSpace <= fullWidth) {\n            return {\n              count: 1,\n              type: formatName\n            };\n          }\n        }\n      }\n      for (let months = monthsCount; months > 1; months = Math.ceil(months / 2)) {\n        for (let formatName of formatNames) {\n          if (\n            (this.root.state.options.calendar.month.maxWidths[formatName] + additionalSpace) * months <= fullWidth &&\n            months > 1\n          ) {\n            return {\n              count: months,\n              type: formatName\n            };\n          }\n        }\n      }\n      return {\n        count: 0,\n        type: formatNames[0]\n      };\n    },\n\n    /**\n     * Generate hours\n     *\n     * @returns {array}\n     */\n    generateHours() {\n      let allHours = [];\n      if (!this.root.state.options.calendar.hour.display) {\n        return allHours;\n      }\n      const steps = this.root.state.options.times.steps;\n      const localeName = this.root.state.options.locale.name;\n      for (let hourIndex = 0, len = steps.length; hourIndex < len; hourIndex++) {\n        const hoursCount = this.howManyHoursFit(hourIndex);\n        if (hoursCount.count === 0) {\n          continue;\n        }\n        const hours = { key: hourIndex + 'step', children: [] };\n        const hourStep = 24 / hoursCount.count;\n        const hourWidthPx = steps[hourIndex].width.px / hoursCount.count;\n        for (let i = 0, len = hoursCount.count; i < len; i++) {\n          const hour = i * hourStep;\n          let index = hourIndex;\n          if (hourIndex > 0) {\n            index = hourIndex - Math.floor(hourIndex / 24) * 24;\n          }\n          let textWidth = 0;\n          if (typeof this.root.state.options.calendar.hour.widths[index] !== 'undefined') {\n            textWidth = this.root.state.options.calendar.hour.widths[index][hoursCount.type];\n          }\n          let x = steps[hourIndex].offset.px + hourWidthPx * i;\n          hours.children.push({\n            index: hourIndex,\n            key: 'h' + i,\n            x,\n            y: this.root.state.options.calendar.day.height + this.root.state.options.calendar.month.height,\n            width: hourWidthPx,\n            textWidth,\n            height: this.root.state.options.calendar.hour.height,\n            label: this.root.state.options.calendar.hour.formatted[hoursCount.type][hour]\n          });\n        }\n        allHours.push(hours);\n      }\n      return allHours;\n    },\n\n    /**\n     * Generate days\n     *\n     * @returns {array}\n     */\n    generateDays() {\n      let days = [];\n      if (!this.root.state.options.calendar.day.display) {\n        return days;\n      }\n      const daysCount = this.howManyDaysFit();\n      if (daysCount.count === 0) {\n        return days;\n      }\n      const steps = this.root.state.options.times.steps;\n      const localeName = this.root.state.options.locale.name;\n      const dayStep = Math.ceil(steps.length / daysCount.count);\n      for (let dayIndex = 0, len = steps.length; dayIndex < len; dayIndex += dayStep) {\n        let dayWidthPx = 0;\n        // day could be shorter (daylight saving time) so join widths and divide\n        for (let currentStep = 0; currentStep < dayStep; currentStep++) {\n          if (typeof steps[dayIndex + currentStep] !== 'undefined') {\n            dayWidthPx += steps[dayIndex + currentStep].width.px;\n          }\n        }\n        const date = dayjs(steps[dayIndex].time);\n        let textWidth = 0;\n        if (typeof this.root.state.options.calendar.day.widths[dayIndex] !== 'undefined') {\n          textWidth = this.root.state.options.calendar.day.widths[dayIndex][daysCount.type];\n        }\n        let x = steps[dayIndex].offset.px;\n        days.push({\n          index: dayIndex,\n          key: steps[dayIndex].time + 'd',\n          x,\n          y: this.root.state.options.calendar.month.height,\n          width: dayWidthPx,\n          textWidth,\n          height: this.root.state.options.calendar.day.height,\n          label: this.root.state.options.calendar.day.format[daysCount.type](date.locale(localeName))\n        });\n      }\n      return days.map(item => ({\n        key: item.key,\n        children: [item]\n      }));\n    },\n\n    /**\n     * Generate months\n     *\n     * @returns {array}\n     */\n    generateMonths() {\n      let months = [];\n      if (!this.root.state.options.calendar.month.display) {\n        return months;\n      }\n      const monthsCount = this.howManyMonthsFit();\n      if (monthsCount.count === 0) {\n        return months;\n      }\n      const steps = this.root.state.options.times.steps;\n      const localeName = this.root.state.options.locale.name;\n      let formatNames = Object.keys(this.root.state.options.calendar.month.format);\n      let currentDate = dayjs(this.root.state.options.times.firstTime);\n      for (let monthIndex = 0; monthIndex < monthsCount.count; monthIndex++) {\n        let monthWidth = 0;\n        let monthOffset = Number.MAX_SAFE_INTEGER;\n        let finalDate = dayjs(currentDate)\n          .add(1, 'month')\n          .startOf('month');\n        if (finalDate.valueOf() > this.root.state.options.times.lastTime) {\n          finalDate = dayjs(this.root.state.options.times.lastTime);\n        }\n        // we must find first and last step to get the offsets / widths\n        for (let step = 0, len = this.root.state.options.times.steps.length; step < len; step++) {\n          let currentStep = this.root.state.options.times.steps[step];\n          if (currentStep.time >= currentDate.valueOf() && currentStep.time < finalDate.valueOf()) {\n            monthWidth += currentStep.width.px;\n            if (currentStep.offset.px < monthOffset) {\n              monthOffset = currentStep.offset.px;\n            }\n          }\n        }\n        let label = '';\n        let choosenFormatName;\n        for (let formatName of formatNames) {\n          if (this.root.state.options.calendar.month.maxWidths[formatName] + 2 <= monthWidth) {\n            label = this.root.state.options.calendar.month.format[formatName](currentDate.locale(localeName));\n            choosenFormatName = formatName;\n          }\n        }\n        let textWidth = 0;\n        if (typeof this.root.state.options.calendar.month.widths[monthIndex] !== 'undefined') {\n          textWidth = this.root.state.options.calendar.month.widths[monthIndex][choosenFormatName];\n        }\n        let x = monthOffset;\n        months.push({\n          index: monthIndex,\n          key: monthIndex + 'm',\n          x,\n          y: 0,\n          width: monthWidth,\n          textWidth,\n          choosenFormatName,\n          height: this.root.state.options.calendar.month.height,\n          label\n        });\n        currentDate = currentDate.add(1, 'month').startOf('month');\n        if (currentDate.valueOf() > this.root.state.options.times.lastTime) {\n          currentDate = dayjs(this.root.state.options.times.lastTime);\n        }\n      }\n      return months.map(item => ({\n        key: item.key,\n        children: [item]\n      }));\n    },\n\n    /**\n     * Sum all calendar rows height and return result\n     *\n     * @returns {int}\n     */\n    calculateCalendarDimensions({ hours, days, months }) {\n      let height = 0;\n      if (this.root.state.options.calendar.hour.display && hours.length > 0) {\n        height += this.root.state.options.calendar.hour.height;\n      }\n      if (this.root.state.options.calendar.day.display && days.length > 0) {\n        height += this.root.state.options.calendar.day.height;\n      }\n      if (this.root.state.options.calendar.month.display && months.length > 0) {\n        height += this.root.state.options.calendar.month.height;\n      }\n      this.root.state.options.calendar.height = height;\n    }\n  },\n\n  computed: {\n    dates() {\n      const hours = this.generateHours();\n      const days = this.generateDays();\n      const months = this.generateMonths();\n      const allDates = { hours, days, months };\n      this.calculateCalendarDimensions(allDates);\n      return allDates;\n    }\n  }\n};\n</script>\n"]}]}